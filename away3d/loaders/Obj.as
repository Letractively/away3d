// note Only the geometry and mapping of one mesh is currently parsed. Group is not supported yet.// Class tested with the following 3D apps:// - Strata CX mac 5.0 ok// - Biturn ver 0.87b4 PC ok// - LightWave 3D OBJ Export v2.1 PC ok// - Max2Obj Version 4.0 PC --> ok, with no groups// - tags f,v,vt are being parsed// export from apps as polygon group or mesh as .obj file.package away3d.loaders{    import away3d.core.*;    import away3d.core.scene.*;    import away3d.core.geom.*;    import away3d.core.material.*;    import flash.net.URLRequest;    import flash.net.URLLoader;    import flash.events.EventDispatcher;    import flash.events.Event;    import flash.events.ProgressEvent;    import flash.events.IOErrorEvent;    public class Obj {        private var mesh:Mesh3D;        private var scaling:Number;        private var myURLLoader :URLLoader;        private var url:String;        private var mat:*;        public function Obj(url:String, material:IMaterial,init:Object=null, scale:Number = 1) {            url = url;            mat = material;            init=Init.parse(init);            scaling=scale;            mesh= new Mesh3D(null,init);                        myURLLoader = new URLLoader();            myURLLoader.addEventListener( Event.COMPLETE, parseObj);            myURLLoader.addEventListener( ProgressEvent.PROGRESS, progressHandler);            myURLLoader.addEventListener( IOErrorEvent.IO_ERROR, ioErrorHandler);            var request:URLRequest = new URLRequest(url);            try {                myURLLoader.load(request);            } catch (error:Error) {                trace("---> error request loading .obj file: '"+url+"'"+"error: "+error.message);            }        }        // file loader moet eigenlijk loss staan, zie Arno's xml loader...        private function ioErrorHandler(event:IOErrorEvent):void {            trace("---> ioError .obj file, probably not found");        }        private function progressHandler(event:ProgressEvent):void {            //trace("loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);        }        public static function parse(url:String,material:*=null,init:Object=null,scale:Number = 1):Mesh3D {            //            var obj:Obj= new Obj(url, material, init, scale);            return obj.mesh;        }        private function parseObj(e:Event):void {            var loader:URLLoader = URLLoader(e.target);            var filestring:String = unescape(loader.data);            var lines:Array=filestring.split('\n');            var line:String;            var trunk:Array;            var face0:Array;            var face1:Array;            var face2:Array;            var face3:Array;            var face:Face3D;            var uvA:UV;            var uvB:UV;            var uvC:UV;            var x:Number;            var y:Number;            var z:Number;            var UVs:Array=new Array;            var i:int;            //            while (lines.length) {                line=String(lines.shift());                i++;                /*                not used yet                if(line.substring(0,2) == "vn"){                //trace("line "+i+" = "+line);                //trunk = line.split(' ');                //extract the vector normal                }                //not used yet, extract the name of the mesh form group                if (line.substring(0,1) == "g" && line.length <= 2) {                trace("New mesh");                }                */                //vertices                if (line.substring(0,2) == "v ") {                    try {                        trunk=line.substring(2,line.length).split(' ');                        if (trunk.length == 4) {                            trunk.shift();                        }                        // y and z swap                        x = Number(trunk[0]) * scaling;                        y = - Number(trunk[2]) * scaling;                        z = Number(trunk[1]) * scaling;                        mesh.vertices.push(new Vertex3D(x,y,z));                    } catch (error:Error) {                        //trace("--> OBJParser ERROR:\n while parsing vertices'" + this.id + "',  in file at line " + i + ": " + error.message + "\n" + trunk);                    }                }                //textures uvs                if (line.substring(0,2) == "vt") {                    try {                        trunk=line.substring(2,line.length).split(' ');                        trunk.shift();                        if (trunk.length == 4) {                            trunk.shift();                        }                        UVs.push({u:parseFloat(trunk[0]),v:parseFloat(trunk[1])});                    } catch (error:Error) {                        //trace("--> OBJParser ERROR:\n while parsing uv s'" + this.id + "',  in file at line " + i + ": " + error.message + "\n" + trunk);                    }                }                //faces                if (line.substring(0,2) == "f ") {                    if (line.indexOf("-") != -1) {                        var myPattern:RegExp=new RegExp("-","g");                        line=line.substring(2,line.length).replace(myPattern,"");                        trunk=line.split(' ');                    } else {                        trunk=line.substring(2,line.length).split(' ');                    }                    try {                        if (trunk[0] && trunk[1] && trunk[2] && trunk[3]) {                            if (trunk[0].indexOf("/") != -1) {                                face0=trunk[0].split('/');                            } else {                                face0=[trunk[0]];                            }                            if (trunk[1].indexOf("/") != -1) {                                face1=trunk[1].split('/');                            } else {                                face1=[trunk[1]];                            }                            if (trunk[2].indexOf("/") != -1) {                                face2=trunk[2].split('/');                            } else {                                face2=[trunk[2]];                            }                            if (trunk[3].indexOf("/") != -1) {                                face3=trunk[3].split('/');                            } else {                                face3=[trunk[3]];                            }                            try {                                if (face0[1] && face1[1] && face2[1] && face3[1]) {                                    uvA = new UV(UVs[Number(face3[1]) - 1].u, UVs[Number(face3[1]) - 1].v);                                    uvB = new UV(UVs[Number(face0[1]) - 1].u, UVs[Number(face0[1]) - 1].v);                                    uvC = new UV(UVs[Number(face1[1]) - 1].u, UVs[Number(face1[1]) - 1].v);                                    face = new Face3D( mesh.vertices[Number(face1[0]) - 1], mesh.vertices[Number(face0[0]) - 1],mesh.vertices[Number(face3[0]) - 1], mat,  uvC, uvB, uvA);                                    mesh.faces.push(face);                                    uvA = new UV(UVs[Number(face3[1]) - 1].u, UVs[Number(face3[1]) - 1].v);                                    uvB = new UV(UVs[Number(face1[1]) - 1].u, UVs[Number(face1[1]) - 1].v);                                    uvC = new UV(UVs[Number(face2[1]) - 1].u, UVs[Number(face2[1]) - 1].v);                                    face = new Face3D(mesh.vertices[Number(face2[0]) - 1], mesh.vertices[Number(face1[0]) - 1], mesh.vertices[Number(face3[0]) - 1], mat, uvC, uvB, uvA );                                    mesh.faces.push(face);                                } else {                                    face = new Face3D(mesh.vertices[Number(face1[0]) - 1], mesh.vertices[Number(face0[0]) - 1],mesh.vertices[Number(face3[0]) - 1], mat, null, null, null);                                    mesh.faces.push(face);                                    face = new Face3D(mesh.vertices[Number(face2[0]) - 1], mesh.vertices[Number(face1[0]) - 1], mesh.vertices[Number(face3[0]) - 1], mat, null, null, null);                                    mesh.faces.push(face);                                }                            } catch (error:Error) {                                //trace("--> OBJParser [case 4 points face] ERROR:\n while parsing faces:'" + this.id + "', at line " + i + " in .obj file :" + error.message + "\n" + trunk);                            }                        } else if (trunk[0] && trunk[1] && trunk[2]) {                            if (trunk[0].indexOf("/") != -1) {                                face0=trunk[0].split('/');                            } else {                                face0=[trunk[0]];                            }                            if (trunk[1].indexOf("/") != -1) {                                face1=trunk[1].split('/');                            } else {                                face1=[trunk[1]];                            }                            if (trunk[2].indexOf("/") != -1) {                                face2=trunk[2].split('/');                            } else {                                face2=[trunk[2]];                            }                            try {                                if (face0[1] && face1[1] && face2[1]) {                                    uvA = new UV(UVs[Number(face0[1]) - 1].u, UVs[Number(face0[1]) - 1].v);                                    uvB = new UV(UVs[Number(face1[1]) - 1].u, UVs[Number(face1[1]) - 1].v);                                    uvC = new UV(UVs[Number(face2[1]) - 1].u, UVs[Number(face2[1]) - 1].v);                                    face = new Face3D( mesh.vertices[Number(face2[0]) - 1], mesh.vertices[Number(face1[0]) - 1], mesh.vertices[Number(face0[0]) - 1], mat, uvC, uvB, uvA );                                    mesh.faces.push(face);                                } else {                                    face = new Face3D(mesh.vertices[Number(face2[0]) - 1], mesh.vertices[Number(face1[0]) - 1], mesh.vertices[Number(face0[0]) - 1], mat, null, null, null);                                    mesh.faces.push(face);                                }                            } catch (error:Error) {                                //trace("--> OBJParser [case 3 points face] ERROR:\n while parsing faces:'" + this.id + "', at line " + i + " in .obj file :" + error.message + "\n" + trunk);                            }                        }                    } catch (error:Error) {                        //trace("--> OBJParser ERROR:\n while parsing faces '" + this.id + "', at line " + i + " in .obj file :" + error.message + "\n" + trunk);                    }                }            }            trace("parsed obj file :"+mesh.faces.length);        }    }}