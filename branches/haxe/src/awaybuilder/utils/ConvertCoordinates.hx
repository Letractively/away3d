package awaybuilder.utils;

import awaybuilder.CoordinateSystem;


class ConvertCoordinates  {
	
	

	public function new() {
		
		OPPOSITE_OR[X | X] = N;
		OPPOSITE_OR[XY | X] = Y;
		OPPOSITE_OR[XZ | X] = Z;
		OPPOSITE_OR[XYZ | X] = YZ;
		OPPOSITE_OR[Y | Y] = N;
		OPPOSITE_OR[XY | Y] = X;
		OPPOSITE_OR[XYZ | Y] = XZ;
		OPPOSITE_OR[YZ | Y] = Z;
		OPPOSITE_OR[Z | Z] = N;
		OPPOSITE_OR[XZ | Z] = X;
		OPPOSITE_OR[XYZ | Z] = XY;
		OPPOSITE_OR[YZ | Z] = Y;
		SCALINGS[1] = [1, 1, 1];
		SCALINGS[2] = [-1, 1, 1];
		SCALINGS[4] = [-1, 1, -1];
		SCALINGS[8] = [1, 1, -1];
		SCALINGS[16] = [1, -1, 1];
		SCALINGS[32] = [-1, -1, 1];
		SCALINGS[64] = [-1, -1, -1];
		SCALINGS[128] = [1, -1, -1];
		
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	// Public Methods
	//
	////////////////////////////////////////////////////////////////////////////////
	public static function groupPositionX(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.MAYA :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function groupPositionY(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.MAYA :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function groupPositionZ(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.MAYA :
				return n * -1;
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function positionX(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.MAYA :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function positionY(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.AFTER_EFFECTS :
				return -n;
			case CoordinateSystem.MAYA :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function positionZ(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.MAYA :
				return n * -1;
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function scale(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.AFTER_EFFECTS :
				return n / 100;
			case CoordinateSystem.MAYA :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function groupRotationX(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.MAYA :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function groupRotationY(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.MAYA :
				return n * -1;
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function groupRotationZ(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.MAYA :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function meshRotationX(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.MAYA :
				return n + 90;
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function meshRotationY(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.MAYA :
				return n * -1;
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function meshRotationZ(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.MAYA :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function colladaRotationX(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.MAYA :
				return n + 90;
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function colladaRotationY(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.MAYA :
				return n * -1;
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function colladaRotationZ(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.MAYA :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function cameraPositionX(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.MAYA :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function cameraPositionY(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.MAYA :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function cameraPositionZ(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.MAYA :
				return n * -1;
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function cameraRotationX(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.MAYA :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function cameraRotationY(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.MAYA :
				return n * -1;
			case CoordinateSystem.AFTER_EFFECTS :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

	public static function cameraRotationZ(n:Float, coordinateSystem:String):Float {
		
		switch (coordinateSystem) {
			case CoordinateSystem.AFTER_EFFECTS :
				return n * -1;
			case CoordinateSystem.MAYA :
			case CoordinateSystem.NATIVE :
			default :
				return n;
			

		}
		
		// autogenerated
		return 0;
	}

}

