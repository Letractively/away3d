package awaybuilder.parsers;

import away3d.haxeutils.Error;
import awaybuilder.abstracts.AbstractParser;
import awaybuilder.geometry.GeometryAttributes;
import awaybuilder.material.MaterialAttributes;
import awaybuilder.vo.DynamicAttributeVO;
import awaybuilder.vo.GroupVO;
import awaybuilder.vo.MaterialVO;
import awaybuilder.vo.SceneCameraVO;
import awaybuilder.vo.SceneGeometryVO;
import awaybuilder.vo.SceneObjectVO;
import awaybuilder.vo.SceneSectionVO;
import flash.events.Event;


class SceneXMLParser extends AbstractParser  {
	
	private static inline var NODE_CAMERAS:String = "cameras";
	private static inline var NODE_GEOMETRY:String = "geometry";
	private static inline var NODE_GROUP:String = "group";
	private static inline var NODE_GROUPS:String = "groups";
	private static inline var NODE_MATERIAL:String = "material";
	private static inline var NODE_MATERIALS:String = "materials";
	private static inline var NODE_POSITION:String = "position";
	private static inline var NODE_PROPERTIES:String = "properties";
	private static inline var NODE_ROTATION:String = "rotation";
	private static inline var NODE_SCALE:String = "scale";
	private static inline var NODE_SECTION:String = "section";
	private static inline var NODE_SECTIONS:String = "sections";
	private var groups:Array<Dynamic>;
	private var materials:Array<Dynamic>;
	

	public function new() {
		this.groups = [];
		this.materials = [];
		
		OPPOSITE_OR[X | X] = N;
		OPPOSITE_OR[XY | X] = Y;
		OPPOSITE_OR[XZ | X] = Z;
		OPPOSITE_OR[XYZ | X] = YZ;
		OPPOSITE_OR[Y | Y] = N;
		OPPOSITE_OR[XY | Y] = X;
		OPPOSITE_OR[XYZ | Y] = XZ;
		OPPOSITE_OR[YZ | Y] = Z;
		OPPOSITE_OR[Z | Z] = N;
		OPPOSITE_OR[XZ | Z] = X;
		OPPOSITE_OR[XYZ | Z] = XY;
		OPPOSITE_OR[YZ | Z] = Y;
		SCALINGS[1] = [1, 1, 1];
		SCALINGS[2] = [-1, 1, 1];
		SCALINGS[4] = [-1, 1, -1];
		SCALINGS[8] = [1, 1, -1];
		SCALINGS[16] = [1, -1, 1];
		SCALINGS[32] = [-1, -1, 1];
		SCALINGS[64] = [-1, -1, -1];
		SCALINGS[128] = [1, -1, -1];
		
		super();
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//	Override Methods
	//
	////////////////////////////////////////////////////////////////////////////////
	override public function parse(data:Dynamic):Void {
		
		var xml:Xml = new XML(data);
		this.parseGroups(Reflect.field(xml, NODE_GROUPS)[NODE_GROUP]);
		this.parseMaterials(Reflect.field(xml, NODE_MATERIALS));
		this.parseSections(Reflect.field(xml, NODE_SECTIONS)[NODE_SECTION]);
		this.dispatchEvent(new Event(Event.COMPLETE));
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	//	Protected Methods
	//
	////////////////////////////////////////////////////////////////////////////////
	private function parseGroups(list:XMLList):Void {
		
		for (__i in 0...list.length) {
			var item:Xml = list[__i];

			if (item != null) {
				var vo:GroupVO = new GroupVO();
				vo.id = item.@id;
				for (__i in 0...item.children().length) {
					var property:Xml = item.children()[__i];

					if (property != null) {
						this.pushProperty(property, vo.properties);
					}
				}

				this.groups.push(vo);
			}
		}

	}

	private function pushProperty(property:Xml, properties:Array<Dynamic>):Void {
		
		var attribute:DynamicAttributeVO = new DynamicAttributeVO();
		attribute.key = property.name().toString();
		attribute.value = property;
		properties.push(attribute);
	}

	private function parseMaterials(list:XMLList):Void {
		
		for (__i in 0...list.children().length) {
			var material:Xml = list.children()[__i];

			if (material != null) {
				var vo:MaterialVO = new MaterialVO();
				var type:DynamicAttributeVO = new DynamicAttributeVO();
				vo.id = material.@id;
				vo.name = material.name().toString();
				type.key = MaterialAttributes.CLASS;
				type.value = material.name().toString();
				vo.properties.push(type);
				for (__i in 0...material.children().length) {
					var property:Xml = material.children()[__i];

					if (property != null) {
						if (property.name().toString() == NODE_GROUP) {
							this.applyGroupProperties(property.@id, vo.properties);
						} else {
							this.pushProperty(property, vo.properties);
						}
					}
				}

				this.materials.push(vo);
			}
		}

	}

	private function applyGroupProperties(groupId:String, properties:Array<Dynamic>):Void {
		
		var group:GroupVO = this.getGroupById(groupId);
		for (__i in 0...group.properties.length) {
			var attribute:DynamicAttributeVO = group.properties[__i];

			if (attribute != null) {
				properties.push(attribute);
			}
		}

	}

	private function getGroupById(id:String):GroupVO {
		
		for (__i in 0...this.groups.length) {
			var vo:GroupVO = this.groups[__i];

			if (vo != null) {
				if (vo.id == id) {
					return vo;
				}
			}
		}

		throw new Error("group with id [" + id + "] not found");
		
		// autogenerated
		return null;
	}

	private function parseSections(list:XMLList):Void {
		
		for (__i in 0...list.length) {
			var item:Xml = list[__i];

			if (item != null) {
				var vo:SceneSectionVO = new SceneSectionVO();
				this.extractValues(item, vo.values);
				for (__i in 0...item.children().length) {
					var child:Xml = item.children()[__i];

					if (child != null) {
						switch (child.name().toString()) {
							case NODE_CAMERAS :
								this.parseCameras(child.children(), vo);
								break;
							case NODE_GEOMETRY :
								this.parseGeometry(child.children(), vo);
								break;
							

						}
					}
				}

				this._sections.push(vo);
			}
		}

	}

	private function extractValues(item:Xml, values:SceneObjectVO):Void {
		
		for (__i in 0...item.children().length) {
			var child:Xml = item.children()[__i];

			if (child != null) {
				switch (child.name().toString()) {
					case NODE_POSITION :
						values.x = child.@x;
						values.y = child.@y;
						values.z = child.@z;
						break;
					case NODE_ROTATION :
						values.rotationX = child.@x;
						values.rotationY = child.@y;
						values.rotationZ = child.@z;
						break;
					case NODE_SCALE :
						values.scaleX = child.@x;
						values.scaleY = child.@y;
						values.scaleZ = child.@z;
						break;
					

				}
			}
		}

	}

	private function parseCameras(list:XMLList, section:SceneSectionVO):Void {
		
		for (__i in 0...list.length) {
			var item:Xml = list[__i];

			if (item != null) {
				var vo:SceneCameraVO = new SceneCameraVO();
				vo.id = item.@id;
				this.extractValues(item, vo.values);
				for (__i in 0...item.children().length) {
					var child:Xml = item.children()[__i];

					if (child != null) {
						switch (child.name().toString()) {
							case NODE_PROPERTIES :
								for (__i in 0...child.children().length) {
									var property:Xml = child.children()[__i];

									if (property != null) {
										if (property.name().toString() == NODE_GROUP) {
											this.applyGroupProperties(property.@id, vo.extras);
										} else {
											this.pushProperty(property, vo.extras);
										}
									}
								}

								break;
							

						}
					}
				}

				section.cameras.push(vo);
			}
		}

	}

	private function parseGeometry(list:XMLList, section:SceneSectionVO):Void {
		
		for (__i in 0...list.length) {
			var item:Xml = list[__i];

			if (item != null) {
				var vo:SceneGeometryVO = new SceneGeometryVO();
				var type:DynamicAttributeVO = new DynamicAttributeVO();
				vo.id = item.@id;
				type.key = GeometryAttributes.CLASS;
				type.value = item.name().toString();
				vo.geometryExtras.push(type);
				this.extractValues(item, vo.values);
				for (__i in 0...item.children().length) {
					var child:Xml = item.children()[__i];

					if (child != null) {
						switch (child.name().toString()) {
							case NODE_PROPERTIES :
								for (__i in 0...child.children().length) {
									var property:Xml = child.children()[__i];

									if (property != null) {
										switch (property.name().toString()) {
											case NODE_GROUP :
												this.applyGroupProperties(property.@id, vo.geometryExtras);
												break;
											case NODE_MATERIAL :
												this.applyMaterialProperties(property.@id, vo.materialExtras);
												break;
											default :
												this.pushProperty(property, vo.geometryExtras);
												break;
											

										}
									}
								}

								break;
							

						}
					}
				}

				section.geometry.push(vo);
			}
		}

	}

	private function applyMaterialProperties(materialId:String, properties:Array<Dynamic>):Void {
		
		var material:MaterialVO = this.getMaterialById(materialId);
		for (__i in 0...material.properties.length) {
			var attribute:DynamicAttributeVO = material.properties[__i];

			if (attribute != null) {
				properties.push(attribute);
			}
		}

	}

	private function getMaterialById(id:String):MaterialVO {
		
		for (__i in 0...this.materials.length) {
			var vo:MaterialVO = this.materials[__i];

			if (vo != null) {
				if (vo.id == id) {
					return vo;
				}
			}
		}

		throw new Error("material with id [" + id + "] not found");
		
		// autogenerated
		return null;
	}

}

