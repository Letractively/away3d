package nochump.util.zip;

import flash.events.EventDispatcher;
import flash.events.ProgressEvent;
import flash.utils.ByteArray;
import flash.utils.Dictionary;
import flash.utils.Endian;
import flash.utils.IDataInput;


// [Event(name="entryParsed", type="nochump.util.zip.ZipEvent")]

// [Event(name="entryParseError", type="nochump.util.zip.ZipErrorEvent")]

// [Event(name="progress", type="flash.events.ProgressEvent")]

/**
 * This class represents a Zip archive.  You can ask for the contained
 * entries, or get an input stream for a file entry.  The entry is
 * automatically decompressed.
 * 
 * @author David Chang
 */
class ZipFile extends EventDispatcher  {
	public var entries(getEntries, null) : Array<Dynamic>;
	public var size(getSize, null) : Int;
	
	// data from which zip entries are read.
	private var buf:ByteArray;
	private var entryList:Array<Dynamic>;
	private var entryTable:Dictionary;
	private var locOffsetTable:Dictionary;
	

	/**
	 * Opens a Zip file reading the given data.
	 * 
	 * @param data
	 */
	public function new(data:IDataInput) {
		// autogenerated
		super();
		
		OPPOSITE_OR[X | X] = N;
		OPPOSITE_OR[XY | X] = Y;
		OPPOSITE_OR[XZ | X] = Z;
		OPPOSITE_OR[XYZ | X] = YZ;
		OPPOSITE_OR[Y | Y] = N;
		OPPOSITE_OR[XY | Y] = X;
		OPPOSITE_OR[XYZ | Y] = XZ;
		OPPOSITE_OR[YZ | Y] = Z;
		OPPOSITE_OR[Z | Z] = N;
		OPPOSITE_OR[XZ | Z] = X;
		OPPOSITE_OR[XYZ | Z] = XY;
		OPPOSITE_OR[YZ | Z] = Y;
		SCALINGS[1] = [1, 1, 1];
		SCALINGS[2] = [-1, 1, 1];
		SCALINGS[4] = [-1, 1, -1];
		SCALINGS[8] = [1, 1, -1];
		SCALINGS[16] = [1, -1, 1];
		SCALINGS[32] = [-1, -1, 1];
		SCALINGS[64] = [-1, -1, -1];
		SCALINGS[128] = [1, -1, -1];
		
		buf = new ByteArray();
		buf.endian = Endian.LITTLE_ENDIAN;
		data.readBytes(buf);
		readEntries();
	}

	/**
	 * Returns an array of all Zip entries in this Zip file.
	 */
	public function getEntries():Array<Dynamic> {
		
		return entryList;
	}

	/**
	 * Returns the number of entries in this zip file.
	 */
	public function getSize():Int {
		
		return entryList.length;
	}

	/**
	 * Searches for a zip entry in this archive with the given name.
	 *
	 * @param name the name. May contain directory components separated by
	 * slashes ('/').
	 * @return the zip entry, or null if no entry with that name exists.
	 */
	public function getEntry(name:String):ZipEntry {
		
		return entryTable[cast name];
	}

	/**
	 * Creates a byte array reading the given zip entry as
	 * uncompressed data.  Normally zip entry should be an entry
	 * returned by getEntry() or entries().
	 * 
	 * @param entry the entry to create a byte array for.
	 * @return the byte array, or null if the requested entry does not exist.
	 */
	public function getInput(entry:ZipEntry):ByteArray {
		// extra field for local file header may not match one in central directory header
		
		buf.position = locOffsetTable[cast entry.name] + ZipConstants.LOCHDR - 2;
		// extra length
		var len:Int = buf.readShort();
		buf.position += entry.name.length + len;
		var b1:ByteArray = new ByteArray();
		// read compressed data
		if (entry.compressedSize > 0) {
			buf.readBytes(b1, 0, entry.compressedSize);
		}
		switch (entry.method) {
			case ZipConstants.STORED :
				return b1;
			case ZipConstants.DEFLATED :
				/*
				 if(Security.sandboxType == Security.APPLICATION) {
				 // apollo environment
				 b1.inflate();
				 return b1;
				 }
				 /**/
				var b2:ByteArray = new ByteArray();
				var inflater:Inflater = new Inflater();
				inflater.setInput(b1);
				inflater.inflate(b2);
				dispatchEvent(new ZipEvent());
				return b2;
			default :
				throw new ZipError();
			

		}
		return null;
	}

	public function parseInput(entry:ZipEntry):Void {
		// extra field for local file header may not match one in central directory header
		
		buf.position = locOffsetTable[cast entry.name] + ZipConstants.LOCHDR - 2;
		// extra length
		var len:Int = buf.readShort();
		buf.position += entry.name.length + len;
		var b1:ByteArray = new ByteArray();
		// read compressed data
		if (entry.compressedSize > 0) {
			buf.readBytes(b1, 0, entry.compressedSize);
		}
		switch (entry.method) {
			case ZipConstants.STORED :
				dispatchEvent(new ZipEvent());
			case ZipConstants.DEFLATED :
				var inflater:Inflater = new Inflater();
				inflater.addEventListener(ZipEvent.ENTRY_PARSED, onZipEntryParsed);
				inflater.addEventListener(ProgressEvent.PROGRESS, onZipEntryProgress);
				var b2:ByteArray = new ByteArray();
				inflater.setInput(b1);
				inflater.queuedInflate(b2);
			default :
				throw new ZipError();
			

		}
	}

	private function onZipEntryParsed(event:ZipEvent):Void {
		
		dispatchEvent(new ZipEvent());
	}

	private function onZipEntryProgress(event:ProgressEvent):Void {
		
		dispatchEvent(new ProgressEvent());
	}

	/**
	 * Read the central directory of a zip file and fill the entries
	 * array.  This is called exactly once when first needed.
	 */
	private function readEntries():Void {
		
		readEND();
		entryTable = new Dictionary();
		locOffsetTable = new Dictionary();
		// read cen entries
		var i:Int = 0;
		while (i < entryList.length) {
			var tmpbuf:ByteArray = new ByteArray();
			tmpbuf.endian = Endian.LITTLE_ENDIAN;
			buf.readBytes(tmpbuf, 0, ZipConstants.CENHDR);
			if (tmpbuf.readUnsignedInt() != ZipConstants.CENSIG) {
				throw new ZipError();
			}
			// handle filename
			tmpbuf.position = ZipConstants.CENNAM;
			var len:Int = tmpbuf.readUnsignedShort();
			if (len == 0) {
				throw new ZipError();
			}
			var e:ZipEntry = new ZipEntry();
			// handle extra field
			len = tmpbuf.readUnsignedShort();
			e.extra = new ByteArray();
			if (len > 0) {
				buf.readBytes(e.extra, 0, len);
			}
			// handle file comment
			buf.position += tmpbuf.readUnsignedShort();
			// now get the remaining fields for the entry
			tmpbuf.position = ZipConstants.CENVER;
			e.version = tmpbuf.readUnsignedShort();
			e.flag = tmpbuf.readUnsignedShort();
			if ((e.flag & 1) == 1) {
				throw new ZipError();
			}
			e.method = tmpbuf.readUnsignedShort();
			e.dostime = tmpbuf.readUnsignedInt();
			e.crc = tmpbuf.readUnsignedInt();
			e.compressedSize = tmpbuf.readUnsignedInt();
			e.size = tmpbuf.readUnsignedInt();
			// add to entries and table
			entryList[i] = e;
			entryTable[cast e.name] = e;
			// loc offset
			tmpbuf.position = ZipConstants.CENOFF;
			locOffsetTable[cast e.name] = tmpbuf.readUnsignedInt();
			
			// update loop variables
			i++;
		}

	}

	/**
	 * Reads the total number of entries in the central dir and
	 * positions buf at the start of the central directory.
	 */
	private function readEND():Void {
		
		var b:ByteArray = new ByteArray();
		b.endian = Endian.LITTLE_ENDIAN;
		buf.position = findEND();
		buf.readBytes(b, 0, ZipConstants.ENDHDR);
		b.position = ZipConstants.ENDTOT;
		entryList = new Array<Dynamic>();
		b.position = ZipConstants.ENDOFF;
		buf.position = b.readUnsignedInt();
	}

	private function findEND():Int {
		
		var i:Int = buf.length - ZipConstants.ENDHDR;
		// 0xffff is max zip file comment length
		var n:Int = Math.max(0, i - 0xffff);
		// TODO: issue when n is 0 and ENDSIG not found (since variable i cannot be negative)
		i;
		while (i >= n) {
			if (Reflect.field(buf, i) != 0x50) {
				continue;
			}
			buf.position = i;
			if (buf.readUnsignedInt() == ZipConstants.ENDSIG) {
				return i;
			}
			
			// update loop variables
			i--;
		}

		throw new ZipError();
		return 0;
	}

}

