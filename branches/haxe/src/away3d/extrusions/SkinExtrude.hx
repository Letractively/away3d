package away3d.extrusions;    import away3d.core.math.*;    import away3d.containers.*;    import away3d.core.base.*;    import away3d.materials.*;    import away3d.core.utils.*;	class SkinExtrude extends Mesh {				var varr:Array<Dynamic>;				        public function new(aPoints:Dynamic, ?init:Dynamic = null)        {			init = Init.parse(init);		 	super(init);            var subdivision:Int = init.getInt("subdivision", 1, {min:1});			var scaling:Int = init.getNumber("scaling", 1);			var coverall:Bool = init.getBoolean("coverall", false);			var recenter:Bool = init.getBoolean("recenter", false);			var closepath:Bool = init.getBoolean("closepath", false);			var flip:Bool = init.getBoolean("flip", false);			 			if(Std.is( aPoints[0], Array) && aPoints[0].length>1){				if(closepath && aPoints.length <= 2) closepath = false;				generate(aPoints, subdivision, scaling, coverall, closepath, flip);			} else{				trace("SkinExtrude, at least 2 series of minimum 2 points are required per extrude!");			}			 			if(recenter) {				applyPosition( (this.minX+this.maxX)*.5,  (this.minY+this.maxY)*.5, (this.minZ+this.maxZ)*.5);			} else {				x =  aPoints[0][0].x;				y =  aPoints[0][0].y;				z =  aPoints[0][0].z;			}						varr = null;			type = "SkinExtrude";        	url = "Extrude";        }						function generate(aPoints:Array<Dynamic>, ?subdivision:Int = 1,  ?scaling:Int = 1, ?coverall:Bool = false, ?closepath:Bool = false, ?flip:Bool = false):Void		{				var uvlength:Int = (closepath)? aPoints.length : aPoints.length-1;			for(i in 0...aPoints.length-1){				varr = [];				extrudePoints(aPoints[i], aPoints[i+1], subdivision, coverall, (1/uvlength)*i, uvlength, flip);			}			if(closepath){				varr = [];				extrudePoints(aPoints[aPoints.length-1], aPoints[0], subdivision, coverall, (1/uvlength)*i, uvlength, flip);			}		}			 				function extrudePoints(points1:Array<Dynamic>, points2:Array<Dynamic>, subdivision:Int, coverall:Bool, vscale:Float, indexv:Int, flip:Bool):Void		{						var i:Int;			var j:Int;			var stepx:Float;			var stepy:Float;			var stepz:Float;						var uva:UV; //downleft			var uvb:UV; //topleft			var uvc:UV; //topright			var uvd:UV; //downright						var va:Vertex;			var vb:Vertex;			var vc:Vertex;			var vd:Vertex;						var u1:Float;			var u2:Float;			var index:Int = 0;			var bu:Int = 0;			var bincu:Int = 1/(points1.length-1);			var v1:Int = 0;			var v2:Int = 0;			 			for( i in 0...points1.length){				stepx = (points2[i].x - points1[i].x) / subdivision;				stepy = (points2[i].y - points1[i].y) / subdivision;				stepz = (points2[i].z - points1[i].z)  / subdivision;								for( j in 0...subdivision+1){					varr.push( new Vertex( points1[i].x+(stepx*j) , points1[i].y+(stepy*j), points1[i].z+(stepz*j)) );				}			}									for( i in 0...points1.length-1){				u1 = bu;				bu += bincu;				u2 = bu;								for( j in 0...subdivision){										v1 = (coverall)? vscale+((j/subdivision)/indexv) :  j/subdivision;					v2 = (coverall)? vscale+(( (j+1)/subdivision)/indexv) :  (j+1)/subdivision;										uva = new UV( u1 , v1);					uvb = new UV( u1 , v2 );					uvc = new UV( u2 , v2 );					uvd = new UV( u2 , v1 );											va = varr[index+j];					vb = varr[(index+j) + 1];					vc = varr[((index+j) + (subdivision + 2))];					vd = varr[((index+j) + (subdivision + 1))];					 					if(flip){						addFace(new Face(va,vb,vc, null, uva, uvb, uvc ));						addFace(new Face(va,vc,vd, null, uva, uvc, uvd));					}else{						addFace(new Face(vb,va,vc, null, uvb, uva, uvc ));						addFace(new Face(vc,va,vd, null, uvc, uva, uvd));											}				}				index += subdivision +1;			}					}			}	