package away3d.animators.utils;

import away3d.core.math.Number3D;
import away3d.core.math.Matrix3D;
import away3d.animators.data.Path;
import away3d.animators.data.CurveSegment;


/**
 * Geometry handlers for classes using Path objects
 */
class PathUtils  {
	
	

	public static function step(startVal:Number3D, endVal:Number3D, subdivision:Int):Array<Dynamic> {
		
		var aTween:Array<Dynamic> = [];
		var stepx:Float = (endVal.x - startVal.x) / subdivision;
		var stepy:Float = (endVal.y - startVal.y) / subdivision;
		var stepz:Float = (endVal.z - startVal.z) / subdivision;
		var step:Int = 1;
		var scalestep:Number3D;
		while (step < subdivision) {
			scalestep = new Number3D();
			scalestep.x = startVal.x + (stepx * step);
			scalestep.y = startVal.y + (stepy * step);
			scalestep.z = startVal.z + (stepz * step);
			aTween.push(scalestep);
			step++;
		}

		aTween.push(endVal);
		return aTween;
	}

	/*public static function step( startVal:Number3D, endVal:Number3D, subdivision:int):Array {
	 var aTween:Array = [];
	 var step:int = 1;
	 var stepx:Number =  (endVal.x-startVal.x) / subdivision;
	 var stepy:Number =  (endVal.y-startVal.y) / subdivision;
	 var stepz:Number =  (endVal.z-startVal.z) / subdivision;
	 var scalestep:Number3D;
	 while (step < subdivision) { 
	 scalestep = new Number3D();
	 scalestep.x = startVal.x+(stepx*step);
	 scalestep.y = startVal.y+(stepy*step);
	 scalestep.z = startVal.z+(stepz*step);
	 aTween.push(scalestep);
	 step ++;
	 }
	 aTween.push(endVal);
	 return aTween;
	 }*/
	public static function rotatePoint(aPoint:Number3D, rotation:Number3D):Number3D {
		
		if (rotation.x != 0 || rotation.y != 0 || rotation.z != 0) {
			var x1:Float;
			var y1:Float;
			var z1:Float;
			var rad:Float = Math.PI / 180;
			var rotx:Float = rotation.x * rad;
			var roty:Float = rotation.y * rad;
			var rotz:Float = rotation.z * rad;
			var sinx:Float = Math.sin(rotx);
			var cosx:Float = Math.cos(rotx);
			var siny:Float = Math.sin(roty);
			var cosy:Float = Math.cos(roty);
			var sinz:Float = Math.sin(rotz);
			var cosz:Float = Math.cos(rotz);
			var x:Float = aPoint.x;
			var y:Float = aPoint.y;
			var z:Float = aPoint.z;
			y1 = y;
			y = y1 * cosx + z * -sinx;
			z = y1 * sinx + z * cosx;
			x1 = x;
			x = x1 * cosy + z * siny;
			z = x1 * -siny + z * cosy;
			x1 = x;
			x = x1 * cosz + y * -sinz;
			y = x1 * sinz + y * cosz;
			aPoint.x = x;
			aPoint.y = y;
			aPoint.z = z;
		}
		return aPoint;
	}

	public static function getPointsOnCurve(_path:Path, subdivision:Int):Array<Dynamic> {
		
		var aSegPoints:Array<Dynamic> = [];
		var i:Int = 0;
		while (i < _path.length) {
			aSegPoints.push(PathUtils.getSegmentPoints(_path.array[i].v0, _path.array[i].vc, _path.array[i].v1, subdivision, (i == _path.length - 1)));
			
			// update loop variables
			++i;
		}

		return aSegPoints;
	}

	public static function getSegmentPoints(v0:Number3D, vc:Number3D, v1:Number3D, n:Float, last:Bool):Array<Dynamic> {
		
		var aPts:Array<Dynamic> = [];
		var i:Int = 0;
		while (i < n + ((last) ? 1 : 0)) {
			aPts.push(PathUtils.getNewPoint(v0.x, v0.y, v0.z, vc.x, vc.y, vc.z, v1.x, v1.y, v1.z, i / n));
			
			// update loop variables
			++i;
		}

		return aPts;
	}

	public static function getNewPoint(?x0:Float=0, ?y0:Float=0, ?z0:Float=0, ?aX:Float=0, ?aY:Float=0, ?aZ:Float=0, ?x1:Float=0, ?y1:Float=0, ?z1:Float=0, ?t:Float=0):Number3D {
		
		return new Number3D();
	}

	// autogenerated
	public function new () {
		
	}

	

}

