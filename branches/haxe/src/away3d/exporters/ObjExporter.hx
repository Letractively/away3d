package away3d.exporters;	import flash.system.*;   	import away3d.core.base.Vertex;	import away3d.core.base.UV;	import away3d.core.base.Mesh;	import away3d.core.base.Geometry;	import away3d.core.base.Object3D;	import away3d.containers.ObjectContainer3D;	import away3d.core.base.Face;	import away3d.core.math.Number3D;	import away3d.arcane;	import away3d.animators.utils.PathUtils;		use namespace arcane;		/**	* Class ObjExporter generates a string in the WaveFront obj format representing the object3D(s). Paste to a texteditor and save as filename.obj.	* 	*/	class ObjExporter	 {		public function new() {
		gcount = 0;
		indV = 0;
		indVn = 0;
		indVt = 0;
		indF = 0;
		nRotation = new Number3D();
		}
				var objString:String;		var gcount:Int ;		var indV:Int ;		var indVn:Int ;		var indVt:Int ;		var indF:Int ;		var _scaling:Float;		var _righthanded:Bool;		var nRotation:Number3D ;			function write(object3d:Object3D):Void		{			var aV:Array<Dynamic> = [];			var aVn:Array<Dynamic> = [];			var aVt:Array<Dynamic> = [];			var aF:Array<Dynamic> = [];					objString +="\n";						var aFaces:Array<Dynamic> = (cast( object3d, Mesh)).faces;			var face:Face;			 			var n0:Number3D;			var n1:Number3D;			var n2:Number3D;			 			var geometry:Geometry = (cast( object3d, Mesh)).geometry;						var va:Int;			var vb:Int;			var vc:Int;						var vta:Int;			var vtb:Int;			var vtc:Int;						var na:Int;			var nb:Int;			var nc:Int;						nRotation.x = object3d.rotationX;			nRotation.y = object3d.rotationY;			nRotation.z = object3d.rotationZ;			 			var nPos:Number3D = object3d.scenePosition;						var tmp:Number3D = new Number3D();			var j:Int;			var aRef:Array<Dynamic> = [vc, vb, va];						for(i in 0...aFaces.length )			{				face = aFaces[i];				j=2;				while (j>-1){					tmp.x =  (face["v"+j].x + nPos.x) *_scaling;					tmp.y =  (face["v"+j].y + nPos.y) *_scaling;					tmp.z =  (face["v"+j].z + nPos.z) *_scaling;					tmp = PathUtils.rotatePoint(tmp, nRotation);					if(_righthanded){						//will add Y up var						//tmp.y *= -1;						tmp.x *= -1;						tmp.z *= -1;					}					aRef[j] = checkDoubles( aV, ("v "+tmp.x.toFixed(10)+" "+tmp.y.toFixed(10)+" "+tmp.z.toFixed(10)+"\n") );					--j;				}								vta = checkDoubles( aVt, ("vt "+(_righthanded? 1-face.uv2.u : face.uv2.u)+" "+(_righthanded? face.uv2.v : 1-face.uv2.v)+"\n"));				vtb = checkDoubles( aVt, ("vt "+(_righthanded? 1-face.uv1.u : face.uv1.u)+" "+(_righthanded? face.uv1.v : 1-face.uv1.v)+"\n"));				vtc = checkDoubles( aVt, ("vt "+(_righthanded? 1-face.uv0.u : face.uv0.u)+" "+(_righthanded? face.uv0.v : 1-face.uv0.v)+"\n"));								n0 = geometry.getVertexNormal(face.v0);				n1 = geometry.getVertexNormal(face.v1);				n2 = geometry.getVertexNormal(face.v2);								na = checkDoubles( aVn, ("vn "+n2.x.toFixed(15)+" "+n2.y.toFixed(15)+" "+n2.z.toFixed(15)+"\n") );				nb = checkDoubles( aVn, ("vn "+n1.x.toFixed(15)+" "+n1.y.toFixed(15)+" "+n1.z.toFixed(15)+"\n") );			 	nc = checkDoubles( aVn, ("vn "+n0.x.toFixed(15)+" "+n0.y.toFixed(15)+" "+n0.z.toFixed(15)+"\n") );								aF.push("f "+(aRef[2]+indV)+"/"+(vta+indVt)+"/"+(na+indVn)+" "+(aRef[1]+indV)+"/"+(vtb+indVt)+"/"+(nb+indVn)+" "+(aRef[0]+indV)+"/"+(vtc+indVt)+"/"+(nc+indVn)+"\n");			}						indV += aV.length;			indVn += aVn.length;			indVt += aVt.length;			indF += aF.length;						objString += "# Number of vertices: "+aV.length+"\n";			for( i in 0...aV.length ){				objString += aV[i];			}						objString += "\n# Number of Normals: "+aVn.length+"\n";			for( i in 0...aVn.length ){				objString += aVn[i];			}						objString += "\n# Number of Texture Vertices: "+aVt.length+"\n";			for( i in 0...aVt.length ){				objString += aVt[i];			}			objString += "\n# Number of Polygons: "+aF.length+"\n";			for( i in 0...aF.length ){				objString += aF[i];			}					}				function checkDoubles(arr:Array<Dynamic>, string:String):Int		{			for(i in 0...arr.length){				if(arr[i] == string) return i+1;			}			arr.push(string);			return arr.length;		}				function parse(object3d:Object3D):Void		{			if(Std.is( object3d, ObjectContainer3D)){							var obj:ObjectContainer3D = (cast( object3d, ObjectContainer3D));				objString += "g g"+gcount+"\n";				gcount++;				for(i in 0...obj.children.length){					if(Std.is( obj.children[i], ObjectContainer3D)){						parse(obj.children[i]);					} else{						write( obj.children[i]);					}				}						} else {				write( object3d);			}		}		/**		* Generates a string in the WaveFront obj format representing the object3D(s). Paste to a texteditor and save as filename.obj.		*		* @param	object3d				Object3D. The Object3D to be exported to WaveFront obj format.		* @param	righthanded			[optional] Boolean. If the model output need to be flipped to righthanded system. Default = true.		* @param	scaling					[optional] Number. if the model output needs to be resized. Default = 0.001.		*/		function ObjExporter(object3d:Object3D, righthanded:Boolean = true, scaling:Number = 0.001){			objString = "# Obj file generated by Away3D: http://www.away3d.com\n# exporter version 1.0 \n";			_righthanded = righthanded;			_scaling = scaling;			parse(object3d);			objString += "\n#\n# Total number of vertices: "+indV;			objString += "\n# Total number of Normals: "+indVn;			objString += "\n# Total number of Texture Vertices: "+indVt;			objString += "\n# Total number of Polygons: "+indF+"\n";			objString += "\n# End of File";			System.setClipboard(objString);			trace("ObjExporter done: open an external texteditor and paste!!");		}		 	