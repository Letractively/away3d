package away3d.loaders;    import away3d.containers.*;    import away3d.arcane;    import away3d.core.base.*;    import away3d.core.draw.*;    import away3d.core.render.*;    import away3d.core.utils.*;    import away3d.events.*;    import away3d.loaders.data.*;    import away3d.loaders.utils.*;        import flash.display.*;    import flash.events.*;    import flash.net.*;    import flash.utils.getTimer;    			    use namespace arcane;    	 /**	 * Dispatched when the 3d object loader completes a file load successfully.	 * 	 * @eventType away3d.events.LoaderEvent	 */	/*[Event(name="loadSuccess",type="away3d.events.LoaderEvent")]*/    				 /**	 * Dispatched when the 3d object loader fails to load a file.	 * 	 * @eventType away3d.events.LoaderEvent	 */	/*[Event(name="loadError",type="away3d.events.LoaderEvent")]*/		/**	 * Abstract loader class used as a placeholder for loading 3d content	 */    class Object3DLoader extends ObjectContainer3D {		public var handle(getHandle, null) : Object3D        ;		/** @private */        		/** @private */        arcane static function loadGeometry(url:String, Parser:Class, binary:Bool, init:Dynamic):Object3DLoader        {            var ini:Init = Init.parse(init);            var loaderClass:Class = cast( ini.getObject("loader"), Class) || CubeLoader;            var loader:Object3DLoader = new loaderClass(ini);                        loader.startLoadingGeometry(url, Parser, binary);                        return loader;        }		/** @private */        arcane static function parseGeometry(data:Dynamic, Parser:Class, init:Dynamic):Object3DLoader        {            var ini:Init = Init.parse(init);            var loaderClass:Class = cast( ini.getObject("loader"), Class) || CubeLoader;            var loader:Object3DLoader = new loaderClass(ini);                        loader.startParsingGeometry(data, Parser);                        return loader;        }                var _broadcaster:Sprite ;        var Parser:Class;        public var parser:AbstractParser;        var _parseStart:Int;                var _parseTime:Int;        var result:Object3D;        var urlloader:URLLoader;        var _child:Object3D;        var _materialData:MaterialData;        var _loadQueue:TextureLoadQueue;        var _loadsuccess:LoaderEvent;        var _loaderror:LoaderEvent;		var _zipsourcesloaded:LoaderEvent;		        function registerURL(object:Object3D):Void        {        	if (Std.is( object, ObjectContainer3D)) {        		for each (_child in (cast( object, ObjectContainer3D)).children)        			registerURL(_child);        	} else if (Std.is( object, Mesh)) {        		(cast( object, Mesh)).url = url;        	}        }                function startLoadingGeometry(url:String, Parser:Class, binary:Bool):Void        {        	mode = LOADING_GEOMETRY;        	            this.Parser = Parser;            this.url = url;            urlloader = new URLLoader();            urlloader.dataFormat = binary ? URLLoaderDataFormat.BINARY : URLLoaderDataFormat.TEXT;            urlloader.addEventListener(IOErrorEvent.IO_ERROR, onGeometryError);            urlloader.addEventListener(ProgressEvent.PROGRESS, onGeometryProgress);            urlloader.addEventListener(Event.COMPLETE, onGeometryComplete);            urlloader.load(new URLRequest(url));        	        }                function startParsingGeometry(data:Dynamic, Parser:Class):Void        {        	_broadcaster.addEventListener(Event.ENTER_FRAME, update);        	mode = PARSING_GEOMETRY;        	        	_parseStart = getTimer();        	this.Parser = Parser;        	this.parser = new Parser(data, ini);        	parser.addEventListener(ParserEvent.PARSE_SUCCESS, onParserComplete, false, 0, true);        	parser.addEventListener(ParserEvent.PARSE_ERROR, onParserError, false, 0, true);        	parser.addEventListener(ParserEvent.PARSE_PROGRESS, onParserProgress, false, 0, true);        	parser.parseNext();        }                function startLoadingTextures():Void        {        	mode = LOADING_TEXTURES;        	        	_loadQueue = new TextureLoadQueue();			for (_materialData in materialLibrary)			{				if (_materialData.materialType == MaterialData.TEXTURE_MATERIAL && !_materialData.material)				{					var req:URLRequest = new URLRequest(materialLibrary.texturePath + _materialData.textureFileName);					var loader:TextureLoader = new TextureLoader();										_loadQueue.addItem(loader, req);				}			}			_loadQueue.addEventListener(IOErrorEvent.IO_ERROR, onTextureError);			_loadQueue.addEventListener(ProgressEvent.PROGRESS, onTextureProgress);			_loadQueue.addEventListener(Event.COMPLETE, onTextureComplete);			_loadQueue.start();        }                function update(event:Event):Void        {        	parser.parseNext();        }                function notifySuccess(event:Event):Void        {        	mode = COMPLETE;        	            ini.addForCheck();			            result.transform.multiply(result.transform, transform);			result.name = name;            result.ownCanvas = ownCanvas;            result.filters = filters;            result.visible = visible;            result.mouseEnabled = mouseEnabled;            result.useHandCursor = useHandCursor;            result.alpha = alpha;            result.pushback = pushback;            result.pushfront = pushfront;            result.pivotPoint.clone(pivotPoint);            result.extra = (Std.is( extra, IClonable)) ? (cast( extra, IClonable)).clone() : extra;			            if (parent != null) {                result.parent = parent;                parent = null;            }						//register url with hierarchy			registerURL(result);						//dispatch event			if (!_loadsuccess)				_loadsuccess = new LoaderEvent(LoaderEvent.LOAD_SUCCESS, this);							dispatchEvent(_loadsuccess);        }                function notifyError(event:Event):Void        {        	mode = ERROR;        				//dispatch event			if (!_loaderror)				_loaderror = new LoaderEvent(LoaderEvent.LOAD_ERROR, this);						dispatchEvent(_loaderror);        }                function notifyProgress(event:Event):Void        {        }                /**        * Automatically fired on an geometry error event.        *         * @see away3d.loaders.utils.TextureLoadQueue        */        function onGeometryError(event:IOErrorEvent):Void         {        	notifyError(event);        }                /**        * Automatically fired on a geometry progress event        */        function onGeometryProgress(event:ProgressEvent):Void         {        	notifyProgress(event);        	dispatchEvent(event);        }                /**        * Automatically fired on a geometry complete event        */        function onGeometryComplete(event:Event):Void         {        	startParsingGeometry(urlloader.data, Parser);        }                /**        * Automatically fired on an parser error event.        *         * @see away3d.loaders.utils.TextureLoadQueue        */        function onParserError(event:ParserEvent):Void         {        	_broadcaster.removeEventListener(Event.ENTER_FRAME, update);        	notifyError(event);        }                /**        * Automatically fired on a parser progress event        */        function onParserProgress(event:ParserEvent):Void         {        	notifyProgress(event);        	        	_parseTime = getTimer() - _parseStart;        	        	if (_parseTime < parseTimeout) {        		parser.parseNext();        	}else {        		dispatchEvent(event);        		_parseStart = getTimer();        	}        }                /**        * Automatically fired on a parser complete event        */        function onParserComplete(event:ParserEvent):Void         {        	_broadcaster.removeEventListener(Event.ENTER_FRAME, update);        	result = event.result;        	materialLibrary = result.materialLibrary;        	if (materialLibrary && materialLibrary.autoLoadTextures && materialLibrary.loadRequired) {	        	texturePath = materialLibrary.texturePath;	        	startLoadingTextures();	        } else {	        	notifySuccess(event);	        }        }                /**        * Automatically fired on an texture error event.        *         * @see away3d.loaders.utils.TextureLoadQueue        */        function onTextureError(event:IOErrorEvent):Void         {        	notifyError(event);        }                /**        * Automatically fired on a texture progress event        */        function onTextureProgress(event:ProgressEvent):Void         {        	notifyProgress(event);        	dispatchEvent(event);        }                /**        * Automatically fired on a texture complete event        */        function onTextureComplete(event:Event):Void         {        	materialLibrary.texturesLoaded(_loadQueue);			            notifySuccess(event);        }                /**        * Constant value string representing the geometry loading mode of the 3d object loader.        */		public var LOADING_GEOMETRY:String ;                /**        * Constant value string representing the geometry parsing mode of the 3d object loader.        */		public var PARSING_GEOMETRY:String ;		        /**        * Constant value string representing the texture loading mode of the 3d object loader.        */		public var LOADING_TEXTURES:String ;		        /**        * Constant value string representing a completed loader mode.        */		public var COMPLETE:String ;		        /**        * Constant value string representing a problem loader mode.        */		public var ERROR:String ;		        /**        * Returns the current loading mode of the 3d object loader.        */		public var mode:String;                /**        * Returns the the data container being used by the loaded file.        */        public var containerData:ContainerData;                /**        * Returns the filepath to the directory where any required texture files are located.        */        public var texturePath:String;                /**        * Returns the url string of the file being loaded.        */        public var url:String;				/**		 * Defines a timeout period for file parsing (in milliseconds).		 */		public var parseTimeout:Int;				/**		 * Returns a 3d object relating to the currently visible model.		 * While a file is being loaded, this takes the form of the 3d object loader placeholder.		 * The default placeholder is <code>CubeLoader</code>		 * 		 * Once the file has been loaded and is ready to view, the <code>handle</code> returns the 		 * parsed 3d object file and the placeholder object is swapped in the scenegraph tree.		 * 		 * @see	away3d.loaders.CubeLoader		 */        public function getHandle():Object3D        {            return result || this;        }        		/**		 * Creates a new <code>Object3DLoader</code> object.		 * Not intended for direct use, use the static <code>parse</code> or <code>load</code> methods found on the file loader classes.		 * 		 * @param	init	[optional]	An initialisation object for specifying default instance properties.		 */        public function new(?init:Dynamic = null)         {        	
        	_broadcaster = new Sprite();
        	LOADING_GEOMETRY = "loading_geometry";
        	PARSING_GEOMETRY = "parsing_geometry";
        	LOADING_TEXTURES = "loading_textures";
        	COMPLETE = "complete";
        	ERROR = "error";
        	super(init);        	            parseTimeout = ini.getNumber("parseTimeout", 40000);            ini.removeFromCheck();        }				/**		 * Default method for adding a loadsuccess event listener		 * 		 * @param	listener		The listener function		 */        public function addOnSuccess(listener:Dynamic):Void        {            addEventListener(LoaderEvent.LOAD_SUCCESS, listener, false, 0, true);        }				/**		 * Default method for removing a loadsuccess event listener		 * 		 * @param	listener		The listener function		 */        public function removeOnSuccess(listener:Dynamic):Void        {            removeEventListener(LoaderEvent.LOAD_SUCCESS, listener, false);        }				/**		 * Default method for adding a loaderror event listener		 * 		 * @param	listener		The listener function		 */        public function addOnError(listener:Dynamic):Void        {            addEventListener(LoaderEvent.LOAD_ERROR, listener, false, 0, true);        }				/**		 * Default method for removing a loaderror event listener		 * 		 * @param	listener		The listener function		 */        public function removeOnError(listener:Dynamic):Void        {            removeEventListener(LoaderEvent.LOAD_ERROR, listener, false);        }    }