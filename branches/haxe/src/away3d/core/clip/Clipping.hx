package away3d.core.clip;

import away3d.core.utils.CameraVarsStore;
import away3d.haxeutils.HashableEventDispatcher;
import away3d.containers.View3D;
import flash.events.Event;
import flash.display.StageAlign;
import flash.display.Stage;
import away3d.events.ClippingEvent;
import flash.geom.Point;
import away3d.core.base.Object3D;
import away3d.core.utils.Init;
import away3d.core.utils.FaceVO;
import flash.display.Sprite;
import flash.display.StageScaleMode;
import away3d.core.draw.DrawPrimitive;


/**
 * Dispatched when the clipping properties of a clipping object update.
 * 
 * @eventType away3d.events.ClipEvent
 * 
 * @see #maxX
 * @see #minX
 * @see #maxY
 * @see #minY
 * @see #maxZ
 * @see #minZ
 */
// [Event(name="clipUpdated", type="away3d.events.ClipEvent")]

// use namespace arcane;

/**
 * Base clipping class for no clipping.
 */
class Clipping extends HashableEventDispatcher  {
	public var objectCulling(getObjectCulling, setObjectCulling) : Bool;
	public var view(getView, setView) : View3D;
	public var minX(getMinX, setMinX) : Float;
	public var minY(getMinY, setMinY) : Float;
	public var minZ(getMinZ, setMinZ) : Float;
	public var maxX(getMaxX, setMaxX) : Float;
	public var maxY(getMaxY, setMaxY) : Float;
	public var maxZ(getMaxZ, setMaxZ) : Float;
	
	/** @private */
	public var _cameraVarsStore:CameraVarsStore;
	/** @private */
	public var _objectCulling:Bool;
	private var _clippingClone:Clipping;
	private var _stage:Stage;
	private var _stageWidth:Float;
	private var _stageHeight:Float;
	private var _zeroPoint:Point;
	private var _globalPoint:Point;
	private var _view:View3D;
	private var _minX:Float;
	private var _minY:Float;
	private var _minZ:Float;
	private var _maxX:Float;
	private var _maxY:Float;
	private var _maxZ:Float;
	private var _miX:Float;
	private var _miY:Float;
	private var _maX:Float;
	private var _maY:Float;
	private var _clippingupdated:ClippingEvent;
	private var ini:Init;
	

	private function onScreenUpdate(event:ClippingEvent):Void {
		
		dispatchEvent(event);
	}

	private function notifyClippingUpdate():Void {
		
		if (!hasEventListener(ClippingEvent.CLIPPING_UPDATED)) {
			return;
		}
		if (_clippingupdated == null) {
			_clippingupdated = new ClippingEvent(ClippingEvent.CLIPPING_UPDATED, this);
		}
		dispatchEvent(_clippingupdated);
	}

	public function getObjectCulling():Bool {
		
		return _objectCulling;
	}

	public function setObjectCulling(val:Bool):Bool {
		
		_objectCulling = val;
		return val;
	}

	public function getView():View3D {
		
		return _view;
	}

	public function setView(value:View3D):View3D {
		
		_view = value;
		_cameraVarsStore = view.cameraVarsStore;
		return value;
	}

	/**
	 * Minimum allowed x value for primitives
	 */
	public function getMinX():Float {
		
		return _minX;
	}

	public function setMinX(value:Float):Float {
		
		if (_minX == value) {
			return value;
		}
		_minX = value;
		notifyClippingUpdate();
		return value;
	}

	/**
	 * Minimum allowed y value for primitives
	 */
	public function getMinY():Float {
		
		return _minY;
	}

	public function setMinY(value:Float):Float {
		
		if (_minY == value) {
			return value;
		}
		_minY = value;
		notifyClippingUpdate();
		return value;
	}

	/**
	 * Minimum allowed z value for primitives
	 */
	public function getMinZ():Float {
		
		return _minZ;
	}

	public function setMinZ(value:Float):Float {
		
		if (_minZ == value) {
			return value;
		}
		_minZ = value;
		notifyClippingUpdate();
		return value;
	}

	/**
	 * Maximum allowed x value for primitives
	 */
	public function getMaxX():Float {
		
		return _maxX;
	}

	public function setMaxX(value:Float):Float {
		
		if (_maxX == value) {
			return value;
		}
		_maxX = value;
		notifyClippingUpdate();
		return value;
	}

	/**
	 * Maximum allowed y value for primitives
	 */
	public function getMaxY():Float {
		
		return _maxY;
	}

	public function setMaxY(value:Float):Float {
		
		if (_maxY == value) {
			return value;
		}
		_maxY = value;
		notifyClippingUpdate();
		return value;
	}

	/**
	 * Maximum allowed z value for primitives
	 */
	public function getMaxZ():Float {
		
		return _maxZ;
	}

	public function setMaxZ(value:Float):Float {
		
		if (_maxZ == value) {
			return value;
		}
		_maxZ = value;
		notifyClippingUpdate();
		return value;
	}

	/**
	 * Creates a new <code>Clipping</code> object.
	 * 
	 * @param	init	[optional]	An initialisation object for specifying default instance properties.
	 */
	public function new(?init:Dynamic=null) {
		// autogenerated
		super();
		this._zeroPoint = new Point(0, 0);
		
		
		ini = cast(Init.parse(init), Init);
		minX = ini.getNumber("minX", -Math.POSITIVE_INFINITY);
		minY = ini.getNumber("minY", -Math.POSITIVE_INFINITY);
		minZ = ini.getNumber("minZ", -Math.POSITIVE_INFINITY);
		maxX = ini.getNumber("maxX", Math.POSITIVE_INFINITY);
		maxY = ini.getNumber("maxY", Math.POSITIVE_INFINITY);
		maxZ = ini.getNumber("maxZ", Math.POSITIVE_INFINITY);
	}

	/**
	 * Checks a drawing primitive for clipping.
	 * 
	 * @param	pri	The drawing primitive being checked.
	 * @return		The clipping result - false for clipped, true for non-clipped.
	 */
	public function checkPrimitive(pri:DrawPrimitive):Bool {
		
		return true;
	}

	public function checkFace(faceVO:FaceVO, source:Object3D, clippedFaceVOs:Array<FaceVO>):Void {
		
		clippedFaceVOs.push(faceVO);
	}

	/**
	 * Checks a bounding rectangle for clipping.
	 * 
	 * @param	minX	The x value for the left side of the rectangle.
	 * @param	minY	The y value for the top side of the rectangle.
	 * @param	maxX	The x value for the right side of the rectangle.
	 * @param	maxY	The y value for the bottom side of the rectangle.
	 * @return		The clipping result - false for clipped, true for non-clipped.
	 */
	public function rect(minX:Float, minY:Float, maxX:Float, maxY:Float):Bool {
		
		if (this.maxX < minX) {
			return false;
		}
		if (this.minX > maxX) {
			return false;
		}
		if (this.maxY < minY) {
			return false;
		}
		if (this.minY > maxY) {
			return false;
		}
		return true;
	}

	/**
	 * Returns a clipping object initilised with the edges of the flash movie as the clipping bounds.
	 */
	public function screen(container:Sprite, _loaderWidth:Float, _loaderHeight:Float):Clipping {
		
		if (_clippingClone == null) {
			_clippingClone = clone();
			_clippingClone.addOnClippingUpdate(onScreenUpdate);
		}
		_stage = container.stage;
		if (_stage.scaleMode == StageScaleMode.NO_SCALE) {
			_stageWidth = _stage.stageWidth;
			_stageHeight = _stage.stageHeight;
		} else if (_stage.scaleMode == StageScaleMode.EXACT_FIT) {
			_stageWidth = _loaderWidth;
			_stageHeight = _loaderHeight;
		} else if (_stage.scaleMode == StageScaleMode.SHOW_ALL) {
			if (_stage.stageWidth / _loaderWidth < _stage.stageHeight / _loaderHeight) {
				_stageWidth = _loaderWidth;
				_stageHeight = _stage.stageHeight * _stageWidth / _stage.stageWidth;
			} else {
				_stageHeight = _loaderHeight;
				_stageWidth = _stage.stageWidth * _stageHeight / _stage.stageHeight;
			}
		} else if (_stage.scaleMode == StageScaleMode.NO_BORDER) {
			if (_stage.stageWidth / _loaderWidth > _stage.stageHeight / _loaderHeight) {
				_stageWidth = _loaderWidth;
				_stageHeight = _stage.stageHeight * _stageWidth / _stage.stageWidth;
			} else {
				_stageHeight = _loaderHeight;
				_stageWidth = _stage.stageWidth * _stageHeight / _stage.stageHeight;
			}
		}
		switch (_stage.align) {
			case StageAlign.TOP_LEFT :
				_zeroPoint.x = 0;
				_zeroPoint.y = 0;
				_globalPoint = container.globalToLocal(_zeroPoint);
				_maX = (_miX = _globalPoint.x) + _stageWidth;
				_maY = (_miY = _globalPoint.y) + _stageHeight;
			case StageAlign.TOP_RIGHT :
				_zeroPoint.x = _loaderWidth;
				_zeroPoint.y = 0;
				_globalPoint = container.globalToLocal(_zeroPoint);
				_miX = (_maX = _globalPoint.x) - _stageWidth;
				_maY = (_miY = _globalPoint.y) + _stageHeight;
			case StageAlign.BOTTOM_LEFT :
				_zeroPoint.x = 0;
				_zeroPoint.y = _loaderHeight;
				_globalPoint = container.globalToLocal(_zeroPoint);
				_maX = (_miX = _globalPoint.x) + _stageWidth;
				_miY = (_maY = _globalPoint.y) - _stageHeight;
			case StageAlign.BOTTOM_RIGHT :
				_zeroPoint.x = _loaderWidth;
				_zeroPoint.y = _loaderHeight;
				_globalPoint = container.globalToLocal(_zeroPoint);
				_miX = (_maX = _globalPoint.x) - _stageWidth;
				_miY = (_maY = _globalPoint.y) - _stageHeight;
			case StageAlign.TOP :
				_zeroPoint.x = _loaderWidth / 2;
				_zeroPoint.y = 0;
				_globalPoint = container.globalToLocal(_zeroPoint);
				_miX = _globalPoint.x - _stageWidth / 2;
				_maX = _globalPoint.x + _stageWidth / 2;
				_maY = (_miY = _globalPoint.y) + _stageHeight;
			case StageAlign.BOTTOM :
				_zeroPoint.x = _loaderWidth / 2;
				_zeroPoint.y = _loaderHeight;
				_globalPoint = container.globalToLocal(_zeroPoint);
				_miX = _globalPoint.x - _stageWidth / 2;
				_maX = _globalPoint.x + _stageWidth / 2;
				_miY = (_maY = _globalPoint.y) - _stageHeight;
			case StageAlign.LEFT :
				_zeroPoint.x = 0;
				_zeroPoint.y = _loaderHeight / 2;
				_globalPoint = container.globalToLocal(_zeroPoint);
				_maX = (_miX = _globalPoint.x) + _stageWidth;
				_miY = _globalPoint.y - _stageHeight / 2;
				_maY = _globalPoint.y + _stageHeight / 2;
			case StageAlign.RIGHT :
				_zeroPoint.x = _loaderWidth;
				_zeroPoint.y = _loaderHeight / 2;
				_globalPoint = container.globalToLocal(_zeroPoint);
				_miX = (_maX = _globalPoint.x) - _stageWidth;
				_miY = _globalPoint.y - _stageHeight / 2;
				_maY = _globalPoint.y + _stageHeight / 2;
			default :
				_zeroPoint.x = _loaderWidth / 2;
				_zeroPoint.y = _loaderHeight / 2;
				_globalPoint = container.globalToLocal(_zeroPoint);
				_miX = _globalPoint.x - _stageWidth / 2;
				_maX = _globalPoint.x + _stageWidth / 2;
				_miY = _globalPoint.y - _stageHeight / 2;
				_maY = _globalPoint.y + _stageHeight / 2;
			

		}
		if (minX == -Math.POSITIVE_INFINITY) {
			_clippingClone.minX = _miX;
		} else {
			_clippingClone.minX = _minX;
		}
		if (maxX == Math.POSITIVE_INFINITY) {
			_clippingClone.maxX = _maX;
		} else {
			_clippingClone.maxX = _maxX;
		}
		if (minY == -Math.POSITIVE_INFINITY) {
			_clippingClone.minY = _miY;
		} else {
			_clippingClone.minY = _minY;
		}
		if (maxY == Math.POSITIVE_INFINITY) {
			_clippingClone.maxY = _maY;
		} else {
			_clippingClone.maxY = _maxY;
		}
		_clippingClone.minZ = _minZ;
		_clippingClone.maxZ = _maxZ;
		_clippingClone.objectCulling = _objectCulling;
		return _clippingClone;
	}

	public function clone(?object:Clipping=null):Clipping {
		
		var clipping:Clipping = object;
		if (clipping == null)  {
			clipping = new Clipping();
		};
		clipping.minX = minX;
		clipping.minY = minY;
		clipping.minZ = minZ;
		clipping.maxX = maxX;
		clipping.maxY = maxY;
		clipping.maxZ = maxZ;
		clipping.objectCulling = objectCulling;
		clipping._cameraVarsStore = _cameraVarsStore;
		return clipping;
	}

	/**
	 * Used to trace the values of a rectangle clipping object.
	 * 
	 * @return A string representation of the rectangle clipping object.
	 */
	public override function toString():String {
		
		return "{minX:" + minX + " maxX:" + maxX + " minY:" + minY + " maxY:" + maxY + " minZ:" + minZ + " maxZ:" + maxZ + "}";
	}

	/**
	 * Default method for adding a clippingUpdated event listener
	 * 
	 * @param	listener		The listener function
	 */
	public function addOnClippingUpdate(listener:Dynamic):Void {
		
		addEventListener(ClippingEvent.CLIPPING_UPDATED, listener, false, 0, false);
	}

	/**
	 * Default method for removing a clippingUpdated event listener
	 * 
	 * @param	listener		The listener function
	 */
	public function removeOnClippingUpdate(listener:Dynamic):Void {
		
		removeEventListener(ClippingEvent.CLIPPING_UPDATED, listener, false);
	}

}

