package away3d.core.base;

import away3d.core.base.AnimationTransition;
import flash.events.EventDispatcher;
import flash.events.Event;
import away3d.events.AnimationEvent;


/**
 * Dispatched when all frame sequences are complete
 * 
 * @eventType away3d.events.AnimationEvent
 */
// [Event(name="cycle", type="away3d.events.AnimationEvent")]

/**
 * Dispatched when the current frame sequence is complete
 * 
 * @eventType away3d.events.AnimationEvent
 */
// [Event(name="sequenceupdate", type="away3d.events.AnimationEvent")]

/**
 * Holds information about the current state of a mesh animation.
 */
class Animation extends EventDispatcher, implements IAnimation {
	public var latest(getLatest, null) : Int;
	public var isRunning(getIsRunning, null) : Bool;
	public var transitionValue(getTransitionValue, setTransitionValue) : Float;
	
	private var _time:Int;
	private var _cycle:AnimationEvent;
	private var _sequenceupdate:AnimationEvent;
	private var _isRunning:Bool;
	private var _latest:Int;
	private var _transition:AnimationTransition;
	/**
	 * The current frame of the animation.
	 */
	public var frame:Float;
	/**
	 * The frames per second at which the animation will run.
	 */
	public var fps:Float;
	/**
	 * Determines whether the animation will loop.
	 */
	public var loop:Bool;
	/**
	 * Determines whether the animation will smooth motion (interpolate) between frames.
	 */
	public var smooth:Bool;
	/**
	 * Determines whether the animation will fire cycle events.
	 * 
	 * @see away3d.events.AnimationEvent
	 */
	public var cycleEvent:Bool;
	/**
	 * Determines whether the animation will fire sequence events.
	 * 
	 * @see away3d.events.AnimationEvent
	 */
	public var sequenceEvent:Bool;
	/**
	 * Determines the delay time between animation cycles if loop is set to true.
	 * 
	 * @see loop
	 */
	public var delay:Float;
	/**
	 * Holds an array of animation frames.
	 * 
	 * @see away3d.core.base.AnimationFrame
	 */
	public var sequence:Array<Dynamic>;
	/**
	 * The mesh on which the animation is occurring.
	 */
	public var mesh:Mesh;
	/**
	 * The geometry on which the animation is occurring.
	 */
	public var geometry:Geometry;
	

	/**
	 * Creates a new AnimationTransition object.
	 */
	public function createTransition():Void {
		
		if (_transition == null) {
			_transition = new AnimationTransition(geometry);
		}
	}

	/**
	 * Returns the number of the latest frame displayed.
	 */
	public function getLatest():Int {
		
		return _latest;
	}

	/**
	 * Indicates whether the animation is currently running.
	 */
	public function getIsRunning():Bool {
		
		return _isRunning;
	}

	/**
	 * Creates a new <code>Animation</code> object.
	 * 
	 * @param	obj		The geometry object that the animation acts on.
	 */
	public function new(geo:Geometry) {
		// autogenerated
		super();
		this._isRunning = false;
		this._latest = 0;
		this.frame = 0;
		this.fps = 24;
		this.loop = false;
		this.smooth = false;
		this.cycleEvent = false;
		this.sequenceEvent = false;
		this.delay = 0;
		this.sequence = [];
		
		
		geometry = geo;
		_cycle = new AnimationEvent(AnimationEvent.CYCLE, this);
		_sequenceupdate = new AnimationEvent(AnimationEvent.SEQUENCE_UPDATE, this);
	}

	/**
	 * Jumps to the beginning of the animation and start playing
	 */
	public function start():Void {
		
		_time = flash.Lib.getTimer();
		_isRunning = true;
		_latest = 0;
		frame = 0;
	}

	/**
	 * Smooth interpolations between new AnimationSequence objects
	 */
	public function interpolate():Void {
		
		var isNew:Bool = (_transition == null);
		if (isNew) {
			createTransition();
		} else {
			_transition.reset();
		}
	}

	/*
	 * Determines howmany frames a transition between the actual and the next animationSequence should interpolate together.
	 * must be higher or equal to 1. Default = 10;
	 */
	public function setTransitionValue(val:Float):Float {
		
		createTransition();
		_transition.transitionValue = val;
		return val;
	}

	public function getTransitionValue():Float {
		
		return (_transition == null) ? 10 : _transition.transitionValue;
	}

	/**
	 * @inheritDoc
	 */
	public function update():Void {
		
		if (!_isRunning && !sequenceEvent) {
			return;
		}
		var now:Int = flash.Lib.getTimer();
		frame += (now - _time) * fps / 1000;
		_time = now;
		if (sequence.length == 1) {
			if (cycleEvent) {
				dispatchEvent(_cycle);
			}
			if (sequenceEvent) {
				dispatchEvent(_sequenceupdate);
			}
			if (!loop) {
				_isRunning = false;
			}
			_latest = 0;
			frame = 0;
		} else if (loop && !sequenceEvent) {
			while (frame > sequence.length - 1 + delay) {
				frame -= sequence.length - 1 + delay;
			}

		} else {
			if (frame > sequence.length - 1 + delay) {
				frame = sequence.length - 1 + delay;
				if (cycleEvent) {
					dispatchEvent(_cycle);
				}
				if (sequenceEvent) {
					dispatchEvent(_sequenceupdate);
				}
				if (!loop) {
					_isRunning = false;
				}
			}
		}
		var rf:Float = frame;
		if (!smooth) {
			rf = Math.round(rf);
		}
		if (rf < 0) {
			rf = 0;
		}
		if (rf > sequence.length - 1) {
			rf = sequence.length - 1;
		}
		if (rf == Math.round(rf)) {
			geometry.frames[untyped sequence[Std.int(rf)].frame].adjust(1);
		} else {
			var lf:Float = Math.floor(rf);
			var hf:Float = Math.ceil(rf);
			geometry.frames[untyped sequence[Std.int(lf)].frame].adjust(1);
			geometry.frames[untyped sequence[Std.int(hf)].frame].adjust(rf - lf);
			if (loop || sequenceEvent) {
				if (_latest == 0 || _latest + 1 == sequence[Std.int(lf)].frame || _latest == sequence[Std.int(lf)].frame) {
					_latest = sequence[Std.int(lf)].frame;
				} else {
					_latest = 0;
					if (cycleEvent) {
						dispatchEvent(_cycle);
					}
					if (sequenceEvent) {
						dispatchEvent(_sequenceupdate);
					}
				}
			} else if (cycleEvent || sequenceEvent || sequence.length == 2) {
				if (cycleEvent) {
					dispatchEvent(_cycle);
				}
				if (sequenceEvent) {
					dispatchEvent(_sequenceupdate);
				}
			}
		}
		if (_transition.interpolate < 1) {
			_transition.update();
		}
	}

	/**
	 * Stops the animation at it's current position.
	 */
	public function stop():Void {
		
		_isRunning = false;
		_latest = 0;
	}

}

