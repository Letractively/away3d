package away3d.core.traverse;

import away3d.core.geom.Frustum;
import away3d.core.utils.CameraVarsStore;
import flash.events.EventDispatcher;
import away3d.containers.View3D;
import away3d.haxeutils.HashMap;
import away3d.materials.WireframeMaterial;
import away3d.core.draw.IPrimitiveConsumer;
import away3d.core.clip.Clipping;
import away3d.core.base.Object3D;
import away3d.core.light.ILightProvider;
import away3d.core.draw.IPrimitiveProvider;
import away3d.core.project.ProjectorType;
import away3d.core.render.AbstractRenderSession;
import flash.display.Sprite;
import away3d.containers.ILODObject;
import away3d.core.math.Matrix3D;


// use namespace arcane;

/**
 * Traverser that gathers drawing primitives to render the scene.
 */
class PrimitiveTraverser extends Traverser  {
	public var view(getView, setView) : View3D;
	
	private var _view:View3D;
	private var _clipping:Clipping;
	private var _viewTransform:Matrix3D;
	private var _cameraVarsStore:CameraVarsStore;
	private var _nodeClassification:Int;
	private var _consumer:IPrimitiveConsumer;
	private var _mouseEnabled:Bool;
	private var _mouseEnableds:Array<Dynamic>;
	private var _projectorDictionary:Hash<IPrimitiveProvider>;
	private var _light:ILightProvider;
	

	/**
	 * Defines the view being used.
	 */
	public function getView():View3D {
		
		return _view;
	}

	public function setView(val:View3D):View3D {
		
		_view = val;
		_mouseEnabled = true;
		_mouseEnableds = [];
		_cameraVarsStore = _view.cameraVarsStore;
		//setup the projector dictionary
		_projectorDictionary.set(ProjectorType.CONVEX_BLOCK, _view._convexBlockProjector);
		_projectorDictionary.set(ProjectorType.DIR_SPRITE, _view._dirSpriteProjector);
		_projectorDictionary.set(ProjectorType.DOF_SPRITE, _view._dofSpriteProjector);
		_projectorDictionary.set(ProjectorType.MESH, _view._meshProjector);
		_projectorDictionary.set(ProjectorType.MOVIE_CLIP_SPRITE, _view._movieClipSpriteProjector);
		_projectorDictionary.set(ProjectorType.OBJECT_CONTAINER, _view._objectContainerProjector);
		_projectorDictionary.set(ProjectorType.SPRITE, _view._spriteProjector);
		return val;
	}

	/**
	 * Creates a new <code>PrimitiveTraverser</code> object.
	 */
	public function new() {
		// autogenerated
		super();
		this._projectorDictionary = new Hash<IPrimitiveProvider>();
		
		
	}

	/**
	 * @inheritDoc
	 */
	public override function match(node:Object3D):Bool {
		
		_clipping = _view.clipping;
		if (!node.visible || (_clipping.objectCulling && !_cameraVarsStore.nodeClassificationDictionary.contains(node))) {
			return false;
		}
		if (Std.is(node, ILODObject)) {
			return (cast(node, ILODObject)).matchLOD(_view.camera);
		}
		return true;
	}

	/**
	 * @inheritDoc
	 */
	public override function enter(node:Object3D):Void {
		
		_mouseEnableds.push(_mouseEnabled);
	}

	/**
	 * @inheritDoc
	 */
	public override function apply(node:Object3D):Void {
		
		if (node.session.updated) {
			_viewTransform = _cameraVarsStore.viewTransformDictionary.get(node);
			_consumer = node.session.getConsumer(_view);
			if (node.projectorType != null) {
				_projectorDictionary.get(node.projectorType).primitives(node, _viewTransform, _consumer);
			}
			if (node.debugbb && node.debugBoundingBox.visible) {
				node.debugBoundingBox._session = node.session;
				if (_clipping.objectCulling) {
					_cameraVarsStore.frustumDictionary.put(node.debugBoundingBox, _cameraVarsStore.frustumDictionary.get(node));
					_nodeClassification = _cameraVarsStore.nodeClassificationDictionary.get(node);
					if (_nodeClassification == Frustum.INTERSECT) {
						(cast(node.debugBoundingBox.material, WireframeMaterial)).color = 0xFF0000;
					} else {
						(cast(node.debugBoundingBox.material, WireframeMaterial)).color = 0x333333;
					}
				}
				_view._meshProjector.primitives(node.debugBoundingBox, _viewTransform, _consumer);
			}
			if (node.debugbs && node.debugBoundingSphere.visible) {
				node.debugBoundingSphere._session = node.session;
				if (_clipping.objectCulling) {
					_cameraVarsStore.frustumDictionary.put(node.debugBoundingSphere, _cameraVarsStore.frustumDictionary.get(node));
					_nodeClassification = _cameraVarsStore.nodeClassificationDictionary.get(node);
					if (_nodeClassification == Frustum.INTERSECT) {
						(cast(node.debugBoundingSphere.material, WireframeMaterial)).color = 0xFF0000;
					} else {
						(cast(node.debugBoundingSphere.material, WireframeMaterial)).color = 0x00FFFF;
					}
				}
				_view._meshProjector.primitives(node.debugBoundingSphere, _viewTransform, _consumer);
			}
			if (Std.is(node, ILightProvider)) {
				_light = cast(node, ILightProvider);
				if (_light.debug) {
					_light.debugPrimitive._session = node.session;
					if (_clipping.objectCulling) {
						_cameraVarsStore.frustumDictionary.put(_light.debugPrimitive, _cameraVarsStore.frustumDictionary.get(node));
					}
					_view._meshProjector.primitives(_light.debugPrimitive, _viewTransform, _consumer);
				}
			}
		}
		_mouseEnabled = node._mouseEnabled = (_mouseEnabled && node.mouseEnabled);
	}

	/**
	 * @inheritDoc
	 */
	public override function leave(node:Object3D):Void {
		
		_mouseEnabled = _mouseEnableds.pop();
	}

}

