package away3d.core.traverse;

import away3d.core.geom.Frustum;
import away3d.core.utils.CameraVarsStore;
import flash.events.EventDispatcher;
import away3d.containers.View3D;
import flash.utils.Dictionary;
import away3d.materials.WireframeMaterial;
import away3d.core.draw.IPrimitiveConsumer;
import away3d.core.clip.Clipping;
import away3d.core.base.Object3D;
import away3d.core.light.ILightProvider;
import away3d.core.draw.IPrimitiveProvider;
import away3d.core.project.ProjectorType;
import away3d.core.render.AbstractRenderSession;
import flash.display.Sprite;
import away3d.containers.ILODObject;
import away3d.core.math.Matrix3D;


// use namespace arcane;

/**
 * Traverser that gathers drawing primitives to render the scene.
 */
class PrimitiveTraverser extends Traverser  {
	public var view(getView, setView) : View3D;
	
	private var _view:View3D;
	private var _clipping:Clipping;
	private var _viewTransform:Matrix3D;
	private var _cameraVarsStore:CameraVarsStore;
	private var _nodeClassification:Int;
	private var _consumer:IPrimitiveConsumer;
	private var _mouseEnabled:Bool;
	private var _mouseEnableds:Array<Dynamic>;
	private var _projectorDictionary:Dictionary;
	private var _light:ILightProvider;
	

	/**
	 * Defines the view being used.
	 */
	public function getView():View3D {
		
		return _view;
	}

	public function setView(val:View3D):View3D {
		
		_view = val;
		_mouseEnabled = true;
		_mouseEnableds = [];
		_cameraVarsStore = _view.cameraVarsStore;
		//setup the projector dictionary
		_projectorDictionary[untyped ProjectorType.CONVEX_BLOCK] = _view._convexBlockProjector;
		_projectorDictionary[untyped ProjectorType.DIR_SPRITE] = _view._dirSpriteProjector;
		_projectorDictionary[untyped ProjectorType.DOF_SPRITE] = _view._dofSpriteProjector;
		_projectorDictionary[untyped ProjectorType.MESH] = _view._meshProjector;
		_projectorDictionary[untyped ProjectorType.MOVIE_CLIP_SPRITE] = _view._movieClipSpriteProjector;
		_projectorDictionary[untyped ProjectorType.OBJECT_CONTAINER] = _view._objectContainerProjector;
		_projectorDictionary[untyped ProjectorType.SPRITE] = _view._spriteProjector;
		return val;
	}

	/**
	 * Creates a new <code>PrimitiveTraverser</code> object.
	 */
	public function new() {
		// autogenerated
		super();
		this._projectorDictionary = new Dictionary(true);
		
		
	}

	/**
	 * @inheritDoc
	 */
	public override function match(node:Object3D):Bool {
		
		_clipping = _view.clipping;
		if (!node.visible || (_clipping.objectCulling && _cameraVarsStore.nodeClassificationDictionary[untyped node] == null)) {
			return false;
		}
		if (Std.is(node, ILODObject)) {
			return (cast(node, ILODObject)).matchLOD(_view.camera);
		}
		return true;
	}

	/**
	 * @inheritDoc
	 */
	public override function enter(node:Object3D):Void {
		
		_mouseEnableds.push(_mouseEnabled);
	}

	/**
	 * @inheritDoc
	 */
	public override function apply(node:Object3D):Void {
		
		if (node.session.updated) {
			_viewTransform = _cameraVarsStore.viewTransformDictionary[untyped node];
			_consumer = node.session.getConsumer(_view);
			if (node.projectorType) {
				(cast(_projectorDictionary[untyped node.projectorType], IPrimitiveProvider)).primitives(node, _viewTransform, _consumer);
			}
			if (node.debugbb && node.debugBoundingBox.visible) {
				node.debugBoundingBox._session = node.session;
				if (_clipping.objectCulling) {
					_cameraVarsStore.frustumDictionary[untyped node.debugBoundingBox] = _cameraVarsStore.frustumDictionary[untyped node];
					_nodeClassification = _cameraVarsStore.nodeClassificationDictionary[untyped node];
					if (_nodeClassification == Frustum.INTERSECT) {
						(cast(node.debugBoundingBox.material, WireframeMaterial)).color = 0xFF0000;
					} else {
						(cast(node.debugBoundingBox.material, WireframeMaterial)).color = 0x333333;
					}
				}
				_view._meshProjector.primitives(node.debugBoundingBox, _viewTransform, _consumer);
			}
			if (node.debugbs && node.debugBoundingSphere.visible) {
				node.debugBoundingSphere._session = node.session;
				if (_clipping.objectCulling) {
					_cameraVarsStore.frustumDictionary[untyped node.debugBoundingSphere] = _cameraVarsStore.frustumDictionary[untyped node];
					_nodeClassification = _cameraVarsStore.nodeClassificationDictionary[untyped node];
					if (_nodeClassification == Frustum.INTERSECT) {
						(cast(node.debugBoundingSphere.material, WireframeMaterial)).color = 0xFF0000;
					} else {
						(cast(node.debugBoundingSphere.material, WireframeMaterial)).color = 0x00FFFF;
					}
				}
				_view._meshProjector.primitives(node.debugBoundingSphere, _viewTransform, _consumer);
			}
			if (Std.is(node, ILightProvider)) {
				_light = cast(node, ILightProvider);
				if (_light.debug) {
					_light.debugPrimitive._session = node.session;
					if (_clipping.objectCulling) {
						_cameraVarsStore.frustumDictionary[untyped _light.debugPrimitive] = _cameraVarsStore.frustumDictionary[untyped _light];
					}
					_view._meshProjector.primitives(_light.debugPrimitive, _viewTransform, _consumer);
				}
			}
		}
		_mouseEnabled = node._mouseEnabled = (_mouseEnabled && node.mouseEnabled);
	}

	/**
	 * @inheritDoc
	 */
	public override function leave(node:Object3D):Void {
		
		_mouseEnabled = _mouseEnableds.pop();
	}

}

