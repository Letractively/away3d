package away3d.core.traverse;

import away3d.containers.Scene3D;
import away3d.core.utils.CameraVarsStore;
import flash.events.EventDispatcher;
import away3d.containers.View3D;
import flash.utils.Dictionary;
import away3d.cameras.Camera3D;
import away3d.core.clip.Clipping;
import away3d.core.base.Object3D;
import away3d.cameras.lenses.ILens;
import away3d.core.base.Mesh;
import away3d.core.project.ProjectorType;
import flash.display.Sprite;
import away3d.containers.ILODObject;
import away3d.core.math.Matrix3D;
import away3d.core.geom.Frustum;


// use namespace arcane;

/**
 * Traverser that resolves the transform tree in a scene, ready for rendering.
 */
class ProjectionTraverser extends Traverser  {
	public var view(getView, setView) : View3D;
	
	private var _view:View3D;
	private var _frustum:Frustum;
	private var _cameraVarsStore:CameraVarsStore;
	private var _camera:Camera3D;
	private var _lens:ILens;
	private var _clipping:Clipping;
	private var _cameraViewMatrix:Matrix3D;
	private var _viewTransform:Matrix3D;
	private var _nodeClassification:Int;
	

	/**
	 * Defines the view being used.
	 */
	public function getView():View3D {
		
		return _view;
	}

	public function setView(val:View3D):View3D {
		
		_view = val;
		_cameraVarsStore = val.cameraVarsStore;
		_clipping = val.clipping;
		_camera = val.camera;
		_lens = _camera.lens;
		_cameraViewMatrix = _camera.viewMatrix;
		if (val.statsOpen) {
			val.statsPanel.clearObjects();
		}
		return val;
	}

	/**
	 * Creates a new <code>ProjectionTraverser</code> object.
	 */
	public function new() {
		// autogenerated
		super();
		
		
	}

	/**
	 * @inheritDoc
	 */
	public override function match(node:Object3D):Bool {
		//check if node is visible
		
		if (!node.visible) {
			return false;
		}
		//compute viewTransform matrix
		_viewTransform = _cameraVarsStore.createViewTransform(node);
		_viewTransform.multiply(_cameraViewMatrix, node.sceneTransform);
		if (_clipping.objectCulling) {
			_frustum = _lens.getFrustum(node, _viewTransform);
			if ((Std.is(node, Scene3D) || _cameraVarsStore.nodeClassificationDictionary[cast node.parent] == Frustum.INTERSECT)) {
				if (node.pivotZero) {
					_nodeClassification = _cameraVarsStore.nodeClassificationDictionary[cast node] = _frustum.classifyRadius(node.boundingRadius);
				} else {
					_nodeClassification = _cameraVarsStore.nodeClassificationDictionary[cast node] = _frustum.classifySphere(node.pivotPoint, node.boundingRadius);
				}
			} else {
				_nodeClassification = _cameraVarsStore.nodeClassificationDictionary[cast node] = _cameraVarsStore.nodeClassificationDictionary[cast node.parent];
			}
			if (_nodeClassification == Frustum.OUT) {
				node.updateObject();
				return false;
			}
		}
		//check which LODObject is visible
		if (Std.is(node, ILODObject)) {
			return (cast(node, ILODObject)).matchLOD(_camera);
		}
		return true;
	}

	/**
	 * @inheritDoc
	 */
	public override function enter(node:Object3D):Void {
		
		if (_view.statsOpen && Std.is(node, Mesh)) {
			_view.statsPanel.addObject(cast(node, Mesh));
		}
	}

	public override function apply(node:Object3D):Void {
		
		if (node.projectorType == ProjectorType.CONVEX_BLOCK) {
			_view.blockers[cast node] = node;
		}
		//add to scene meshes dictionary
		if (Std.is(node, Mesh)) {
			_view.scene.meshes[cast node] = node;
		}
	}

	public override function leave(node:Object3D):Void {
		//update object
		
		node.updateObject();
	}

}

