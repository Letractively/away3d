package away3d.core.project;

import away3d.core.utils.ValueObject;
import flash.events.EventDispatcher;
import away3d.materials.ISegmentMaterial;
import away3d.containers.View3D;
import flash.utils.Dictionary;
import away3d.core.block.IBlockerProvider;
import away3d.cameras.Camera3D;
import away3d.core.utils.DrawPrimitiveStore;
import away3d.core.draw.IPrimitiveConsumer;
import away3d.core.draw.ScreenVertex;
import away3d.core.block.IBlockerConsumer;
import away3d.core.base.Object3D;
import away3d.cameras.lenses.ILens;
import away3d.core.draw.IPrimitiveProvider;
import flash.display.DisplayObject;
import flash.display.Sprite;
import away3d.blockers.ConvexBlock;
import away3d.core.math.Matrix3D;
import away3d.core.base.Vertex;


class ConvexBlockProjector implements IBlockerProvider, implements IPrimitiveProvider {
	public var view(getView, setView) : View3D;
	
	private var _view:View3D;
	private var _vertexDictionary:Dictionary;
	private var _drawPrimitiveStore:DrawPrimitiveStore;
	private var _convexBlock:ConvexBlock;
	private var _camera:Camera3D;
	private var _lens:ILens;
	private var _vertices:Array<Dynamic>;
	private var _displayObject:DisplayObject;
	private var _segmentMaterial:ISegmentMaterial;
	private var _vertex:Vertex;
	private var _screenVertex:ScreenVertex;
	private var _points:Array<Dynamic>;
	private var _base:ScreenVertex;
	private var _s:String;
	private var _p:String;
	

	private function cross(a:ScreenVertex, b:ScreenVertex, c:ScreenVertex):Float {
		
		return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
	}

	public function getView():View3D {
		
		return _view;
	}

	public function setView(val:View3D):View3D {
		
		_view = val;
		_drawPrimitiveStore = _view.drawPrimitiveStore;
		return val;
	}

	/**
	 * @inheritDoc
	 * 
	 * @see	away3d.core.traverse.BlockerTraverser
	 * @see	away3d.core.block.Blocker
	 */
	public function blockers(source:Object3D, viewTransform:Matrix3D, consumer:IBlockerConsumer):Void {
		
		_vertexDictionary = _drawPrimitiveStore.createVertexDictionary(source);
		_convexBlock = cast(source, ConvexBlock);
		_camera = _view.camera;
		_lens = _camera.lens;
		_vertices = _convexBlock.vertices;
		if (_vertices.length < 3) {
			return;
		}
		_points = [];
		_base = null;
		_s = "";
		_p = "";
		for (__i in 0..._vertices.length) {
			_vertex = _vertices[__i];

			_s += _vertex.toString() + "\n";
			_screenVertex = _lens.project(viewTransform, _vertex);
			if (_base == null) {
				_base = _screenVertex;
			} else if (_base.y > _screenVertex.y) {
				_base = _screenVertex;
			} else if (_base.y == _screenVertex.y) {
				if (_base.x > _screenVertex.x) {
					_base = _screenVertex;
				}
			}
			_points.push(_screenVertex);
			_p += _screenVertex.toString() + "\n";
		}

		//            throw new Error(s + p);
		for (__i in 0..._points.length) {
			_screenVertex = _points[__i];

			_screenVertex.num = (_screenVertex.x - _base.x) / (_screenVertex.y - _base.y);
		}

		_base.num = -Math.POSITIVE_INFINITY;
		_points.sortOn("num", Array.NUMERIC);
		var result:Array<Dynamic> = [_points[0], _points[1]];
		var o:Float;
		var i:Int = 2;
		while (i < _points.length) {
			o = cross(result[result.length - 2], result[result.length - 1], _points[i]);
			while (o > 0) {
				result.pop();
				if (result.length == 2) {
					break;
				}
				o = cross(result[result.length - 2], result[result.length - 1], _points[i]);
			}

			result.push(_points[i]);
			
			// update loop variables
			i++;
		}

		o = cross(result[result.length - 2], result[result.length - 1], result[0]);
		if (o > 0) {
			result.pop();
		}
		consumer.blocker(_drawPrimitiveStore.createConvexBlocker(source, result));
	}

	public function primitives(source:Object3D, viewTransform:Matrix3D, consumer:IPrimitiveConsumer):Void {
		
		_convexBlock = cast(source, ConvexBlock);
		if (_convexBlock.debug) {
			consumer.primitive(_drawPrimitiveStore.blockerDictionary[cast source]);
		}
	}

	// autogenerated
	public function new () {
		
	}

	

}

