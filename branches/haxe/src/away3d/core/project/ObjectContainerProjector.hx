package away3d.core.project;

import away3d.cameras.Camera3D;
import away3d.core.render.SpriteRenderSession;
import away3d.containers.ObjectContainer3D;
import flash.events.EventDispatcher;
import away3d.containers.View3D;
import flash.utils.Dictionary;
import away3d.core.utils.DrawPrimitiveStore;
import away3d.core.draw.IPrimitiveConsumer;
import away3d.core.draw.ScreenVertex;
import away3d.core.base.Object3D;
import away3d.core.draw.IPrimitiveProvider;
import flash.display.Sprite;
import away3d.core.math.Number3D;
import away3d.core.math.Matrix3D;


class ObjectContainerProjector implements IPrimitiveProvider {
	public var view(getView, setView) : View3D;
	
	private var _view:View3D;
	private var _vertexDictionary:Dictionary;
	private var _drawPrimitiveStore:DrawPrimitiveStore;
	private var _cameraViewMatrix:Matrix3D;
	private var _viewTransformDictionary:Dictionary;
	private var _container:ObjectContainer3D;
	private var _camera:Camera3D;
	private var _child:Object3D;
	private var _screenVertex:ScreenVertex;
	private var _depthPoint:Number3D;
	

	public function getView():View3D {
		
		return _view;
	}

	public function setView(val:View3D):View3D {
		
		_view = val;
		_drawPrimitiveStore = view.drawPrimitiveStore;
		return val;
	}

	public function primitives(source:Object3D, viewTransform:Matrix3D, consumer:IPrimitiveConsumer):Void {
		
		_vertexDictionary = _drawPrimitiveStore.createVertexDictionary(source);
		_container = cast(source, ObjectContainer3D);
		_cameraViewMatrix = _view.camera.viewMatrix;
		_viewTransformDictionary = _view.cameraVarsStore.viewTransformDictionary;
		for (__i in 0..._container.children.length) {
			_child = _container.children[__i];

			if (_child != null) {
				if (_child.ownCanvas && _child.visible) {
					if (Std.is(_child.ownSession, SpriteRenderSession)) {
						(cast(_child.ownSession, SpriteRenderSession)).cacheAsBitmap = true;
					}
					_screenVertex = _drawPrimitiveStore.createScreenVertex(_child.center);
					_screenVertex.x = 0;
					_screenVertex.y = 0;
					if (_child.scenePivotPoint.modulo > 0) {
						_depthPoint.clone(_child.scenePivotPoint);
						_depthPoint.rotate(_depthPoint, _cameraViewMatrix);
						_depthPoint.add(_viewTransformDictionary[untyped _child].position, _depthPoint);
						_screenVertex.z = _depthPoint.modulo;
					} else {
						_screenVertex.z = _viewTransformDictionary[untyped _child].position.modulo;
					}
					if (_child.pushback) {
						_screenVertex.z += _child.boundingRadius;
					}
					if (_child.pushfront) {
						_screenVertex.z -= _child.boundingRadius;
					}
					consumer.primitive(_drawPrimitiveStore.createDrawDisplayObject(_child, _screenVertex, _container.session, _child.session.getContainer(view)));
				}
			}
		}

	}

	// autogenerated
	public function new () {
		this._depthPoint = new Number3D();
		
	}

	

}

