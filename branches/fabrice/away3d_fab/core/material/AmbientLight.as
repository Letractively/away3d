package away3d.core.material{//import away3d.core.math.Number3D;import flash.display.BitmapData;import flash.geom.Point;import flash.events.Event;import flash.events.EventDispatcher;import away3d.register.AWClass;//	public class AmbientLight extends AWClass	{		private static var oLight:Object;		private static var lightMag:Number;		 		function AmbientLight(color:Number = 0xFFFFFF, x:Number =-300, y:Number = 300, z:Number = 300, brightness:Number = 100, ambient:Number = .5) 		{			this.register("AMBIENTLIGHT");			oLight = new Object();			oLight.x = x;			oLight.y = y;			oLight.z = z;			oLight.brightness = Math.max(Math.min(brightness, 100),0);			oLight.ambient =  Math.max(Math.min(ambient, 1),0);			oLight.ambientvalue = (255/100)*(oLight.ambient*100); 			oLight.color = color;			//phong offset			oLight.offsetX =0;			oLight.oofsetY = 0;			setLightMagnitude();		}				public function set offsetx(val:Number):void 		{			oLight.offsetX = val;		}		public function set offsety(val:Number):void 		{			oLight.offsetY = val;		}		public static function get offsets():Object 		{			return {x:oLight.offsetX, y:oLight.offsetY};		}						public static function get lightcolor():Number 		{			return oLight.color;		}		public function get color():Number 		{			return oLight.color;		}		public function set color(col:Number):void 		{			oLight.color = col;			dispatchEvent(new Event("UPDATE_COLOR"));			//trace("dispatch color");		}		public static function get ambientvalue():Number 		{			return oLight.ambientvalue;		}		public function get ambient():Number 		{			return oLight.ambient;		}		public function set ambient(val:Number):void 		{			oLight.ambient = Math.max(Math.min(val, 1),0);			oLight.ambientvalue = (255/100)*(oLight.ambient*100); 		}		public function set lightcolor(col:Number):void 		{			oLight.color = col;		}		public function get light():Object 		{			return oLight;		}		public function set brightness(val:Number):void 		{			oLight.brightness = Math.max(Math.min(val, 100),0);		}		public override function set x(val:Number):void 		{			oLight.x = val;			setLightMagnitude();		}		public override function set y(val:Number):void 		{			oLight.y = val;			setLightMagnitude();		}		public function set z(val:Number):void 		{			oLight.z = val;			setLightMagnitude();		}				public function get position():Number3D 		{			return new Number3D(oLight.x, oLight.y, oLight.z);					}						public function set light(newLight:Object):void 		{			oLight = newLight;			setLightMagnitude();		}		public static function averageNormal(aVectors:Array, basecolor:Number = 0x00):Object 		{						try{				var xn:Number=(aVectors[2].y-aVectors[0].y)*(aVectors[1].z-aVectors[0].z)-(aVectors[2].z-aVectors[0].z)*(aVectors[1].y-aVectors[0].y);				var yn:Number=(aVectors[2].z-aVectors[0].z)*(aVectors[1].x-aVectors[0].x)-(aVectors[2].x-aVectors[0].x)*(aVectors[1].z-aVectors[0].z);				var zn:Number=(aVectors[2].x-aVectors[0].x)*(aVectors[1].y-aVectors[0].y)-(aVectors[2].y-aVectors[0].y)*(aVectors[1].x-aVectors[0].x);										var averageNormal:Number = 1.0/Math.sqrt(xn*xn+yn*yn+zn*zn);				xn *= averageNormal;				yn *= averageNormal;				zn *= averageNormal;								return {xn:xn,yn:yn,zn:zn};							} catch(e:Error){							}			return {xn:1,yn:1,zn:1};		}		public static function getPolygonColor(aVectors:Array, basecolor:Number, norm:Object = null):Number 		{			try{				var lightFactor:Number = getLightFactor(aVectors[0], aVectors[1], aVectors[2], norm);				var a:Number = basecolor >> 24;				var r:Number = basecolor >> 16;				var g:Number = basecolor >> 8 & 0xff;				var b:Number = basecolor & 0xff;				a *= lightFactor;				r *= lightFactor;				g *= lightFactor;				b *= lightFactor;				return a << 24 | r << 16 | g << 8 | b;			} catch(e:Error){			}			return basecolor;		}				public static function getNormal(aVectors:Array):Object		{			var ab:Object = {x:aVectors[0].x - aVectors[1].x,y:aVectors[0].y - aVectors[1].y,z:aVectors[0].z - aVectors[1].z};			var bc:Object = {x:aVectors[1].x - aVectors[2].x,y:aVectors[1].y - aVectors[2].y,z:aVectors[1].z - aVectors[2].z};			return {x:(ab.y * bc.z) - (ab.z * bc.y),y:(ab.x * bc.z) - (ab.z * bc.x), z:(ab.x * bc.y) - (ab.y * bc.x)};		}				public static function getLightFactor(tri0:Object, tri1:Object, tri2:Object, norm:Object = null):Number 		{			if(norm == null){				norm = getNormal([tri0, tri1, tri2]);			}			var dotProd:Number = norm.x * oLight.x + norm.y * oLight.y + norm.z * oLight.z;			var normMag:Number = Math.sqrt(norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);						return (Math.acos(dotProd / (normMag * getLightMagnitude())) / Math.PI) * oLight.brightness / 100;		}				public static function getLightInfuence(tri0, tri1, tri2):Number 		{			/*			var normlight:Number = Math.sqrt(oLight.x * oLight.x + oLight.y * oLight.y + oLight.z * oLight.z);			var dotProd:Number = norm.x * normlight.x + norm.y * normlight.y + norm.z * normlight.z;			var normMag:Number = Math.sqrt(norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);			var angle = Math.acos(dotProd);						var angle = Number3D.getAngle(norm, new Number3D(oLight.x,oLight.y,oLight.z))			 return {x:angle*180/Math.PI,y:angle*180/Math.PI};*/			var norm = getNormal([tri0, tri1, tri2]);		 	return (Number3D.getAngle(new Number3D(norm.x, norm.y, norm.z), new Number3D(oLight.x,oLight.y,oLight.z)))*180/Math.PI;		}				private static function getLightMagnitude():Number{			return lightMag;		}		private function setLightMagnitude():void{			lightMag = Math.sqrt(oLight.x * oLight.x + oLight.y * oLight.y + oLight.z * oLight.z);		}	}}