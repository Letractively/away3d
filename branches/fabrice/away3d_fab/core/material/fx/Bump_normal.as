package away3d.core.material.fx{	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.geom.Matrix;	import flash.filters.ConvolutionFilter;	import flash.filters.DisplacementMapFilter;	import flash.filters.ColorMatrixFilter;	import flash.geom.ColorTransform;	import flash.geom.Transform;	import flash.display.BitmapData;	import flash.display.Sprite;	import flash.events.*;		import away3d.register.MCClassManager;	//	public class Bump extends EventDispatcher	{		public var source_bmd:BitmapData;		public var bump_bmd:BitmapData;		public var dest_bmd:BitmapData;		public var light_bmd:BitmapData;		public var mask_bmd:BitmapData;		public var overlay_bmd:BitmapData;		public var overlayscratch_bmd:BitmapData;		public var overlayalpha_bmd:BitmapData;		private var zeropoint:Point = new Point(0,0);		public var CF:ConvolutionFilter;		public var DP:DisplacementMapFilter;		private var dummy:BitmapData;		private var tempmap:BitmapData;		private var tempalphachanel:BitmapData;		private var _mode:String = "";		//tryout on area perf		private var _usedrect:Rectangle;		private var _usedpoint:Point = new Point(0,0);		private var bReUse:Boolean;		private var bOverlaymask:Boolean;		private var bTotalmask:Boolean = false;		private var bAnimate:Boolean = false;		private var container:Sprite;		private var precalX:int;		private var precalY:int;		//		function Bump(bump_bmd:BitmapData, light_bmd:BitmapData = null, bAnimate:Boolean = false, strmode:String = "", mask_bmd:BitmapData = null, bTotalmask:Boolean = false, bOverlaymask:Boolean = false)		{			this.bump_bmd = bump_bmd.clone();			this.light_bmd = light_bmd;			this.bAnimate = bAnimate;			if(mask_bmd != null){				this.mask_bmd = mask_bmd;				this.bTotalmask = bTotalmask;				this.generateMask(mask_bmd);				this.bOverlaymask = bOverlaymask;			}			this._mode = strmode;		}				public function apply(index:int, source_bmd:BitmapData, dest_bmd:BitmapData, destrect:Rectangle,  normal:Object = null, CT:ColorTransform = null, container:Sprite = null, x0:Number=0, y0:Number=0, x1:Number=0, y1:Number=0, x2:Number=0, y2:Number=0 ):void		{				this.applyBump(index, source_bmd, dest_bmd, destrect, normal, CT, container, x0, y0, x1, y1, x2, y2);		}				private function checkMode(strmode:String):String{			//normal is not considered to save a draw handeling, the value is set to "" witch equals "normal"			var aModelist = ["add", "overlay", "screen", "substract", "multiply", "layer", "invert", "hardlight", "erase", "darken", "alpha", "difference"];			for(var i = 0;i<aModelist.length;i++){				if(strmode == aModelist[i]){					return aModelist[i];				}			}			return "";		}				public function set mode(strmode:String):void		{			this._mode = this.checkMode(strmode.toLowerCase());		}				private function generateMask(mask_source:BitmapData):void		{			var tempsourceBMD:BitmapData = new BitmapData(mask_source.width, mask_source.height, true, 0x00000000);			tempsourceBMD.copyPixels(mask_source, mask_source.rect, this.zeropoint);			var tempBMD:BitmapData = tempsourceBMD.clone();			tempBMD.copyChannel(tempsourceBMD, mask_source.rect, this.zeropoint, 1, 8);			this.mask_bmd.copyPixels(tempBMD, tempsourceBMD.rect, this.zeropoint);			tempBMD.dispose();			tempsourceBMD.dispose(); 		}				private function inverseMask(dest_bmd:BitmapData):void		{			if(!dest_bmd.transparent){				var tmp:BitmapData = new BitmapData(dest_bmd.width, dest_bmd.height, true, 0xFFFFFFFF);				tmp.copyPixels(dest_bmd, dest_bmd.rect, this.zeropoint);				dest_bmd = tmp.clone();				tmp.dispose();			}			var tempsourceBMD:BitmapData = new BitmapData(dest_bmd.width, dest_bmd.height, true, 0xFFFFFFFF);			tempsourceBMD.copyChannel(this.mask_bmd, this.mask_bmd.rect, this.zeropoint, 8, 1);			tempsourceBMD.applyFilter(tempsourceBMD, tempsourceBMD.rect,  new Point(0,0), new ColorMatrixFilter([-1, 0, 0,0,255, 0,-1, 0,0,255, 0, 0,-1,0,255,  0, 0, 0,1,0]));			dest_bmd.copyChannel(tempsourceBMD, tempsourceBMD.rect, this.zeropoint, 1, 8);			tempsourceBMD.dispose(); 		}				private function applyMask(dest:BitmapData):void		{			dest.copyChannel(this.mask_bmd, this.mask_bmd.rect, this.zeropoint, 8, 8);		}				private function buildbump():void		{			// it seams the normal is not needed here... since the whole bump is calculated			////1.0/Math.sqrt(normal.x*normal.x+normal.y*normal.y+normal.z*normal.z);			// in once, instead of earlyer code, running even slower...			this.CF.divisor = 1;			this.dummy.copyPixels(this.source_bmd , this.source_bmd.rect, this.zeropoint);			this.tempmap.copyPixels(this.source_bmd , this.source_bmd.rect, this.zeropoint);			 			this.CF.matrix = new Array(0,0,0,-1,0,1,0,0,0);			this.dummy.applyFilter(this.bump_bmd, this.bump_bmd.rect, this.zeropoint, this.CF);			this.CF.matrix = new Array(0,-1,0,0,0,0,0,1,0);						this.tempmap.applyFilter(this.bump_bmd, this.bump_bmd.rect, this.zeropoint, this.CF);			this.dummy.copyChannel(this.tempmap, this.tempmap.rect, this.zeropoint, 1, 2);						if(this.mask_bmd != null){				this.applyMask(this.dummy);			}						this.DP.mapBitmap = this.dummy;			this.DP.mapPoint = this.zeropoint;			 		}				private function checkSizes():void 		{			var scaleMatrix:Matrix;			var scaledtmpbmd:BitmapData;			var sw:Number;			var sh:Number;							if(this.source_bmd.width != this.dest_bmd.width || this.source_bmd.height != this.dest_bmd.height){				sw = this.source_bmd.width/this.dest_bmd.width;				sh = this.source_bmd.height/this.dest_bmd.height;				scaleMatrix = new Matrix();				scaleMatrix.scale(sw, sw);				scaledtmpbmd = new BitmapData(this.dest_bmd.width * sw, this.dest_bmd.height * sh, true, 0x00FFFFFF);				scaledtmpbmd.draw(this.source_bmd, scaleMatrix, null, null, scaledtmpbmd.rect, true);				this.source_bmd = scaledtmpbmd.clone();				scaledtmpbmd.dispose();			}			if(this.bump_bmd.width != this.dest_bmd.width || this.bump_bmd.height != this.dest_bmd.height){				sw = this.bump_bmd.width/this.dest_bmd.width;				sh = this.bump_bmd.height/this.dest_bmd.height;				scaleMatrix = new Matrix();				scaleMatrix.scale(sw, sw);				scaledtmpbmd = new BitmapData(this.dest_bmd.width * sw, this.dest_bmd.height * sh, true, 0x00FFFFFF);				scaledtmpbmd.draw(this.bump_bmd, scaleMatrix, null, null, scaledtmpbmd.rect, true);				this.bump_bmd = scaledtmpbmd.clone();				scaledtmpbmd.dispose();			}			if(this.source_bmd.width != this.bump_bmd.width || this.source_bmd.height != this.bump_bmd.height){				sw = this.source_bmd.width/this.bump_bmd.width;				sh = this.source_bmd.height/this.bump_bmd.height;				scaleMatrix = new Matrix();				scaleMatrix.scale(sw, sw);				scaledtmpbmd = new BitmapData(this.source_bmd.width * sw, this.source_bmd.height * sh, true, 0x00FFFFFF);				scaledtmpbmd.draw(this.bump_bmd, scaleMatrix, null, null, scaledtmpbmd.rect, true);				this.bump_bmd = scaledtmpbmd.clone();				scaledtmpbmd.dispose();			}		}				private function applyBump(index:int, source_bmd:BitmapData, dest_bmd:BitmapData, destrect:Rectangle, normal:Object, CT:ColorTransform, container:Sprite, x0:Number, y0:Number, x1:Number, y1:Number, x2:Number, y2:Number ):void		{				/* technotes				applyed formula on each channels				dst (x, y) = ((src (x-1, y-1) * a0 + src(x, y-1) * a1				src(x, y+1) * a7 + src (x+1,y+1) * a8) / divisor) + bias								The filter must be a 3x3 filter.				All the filter terms must be integers between -127 and +127.				The sum of all the filter terms must not have an absolute value greater than 127.				If any filter term is negative, the divisor must be between 2.00001 and 256.				If all filter terms are positive, the divisor must be between 1.1 and 256.				The bias must be an integer.				*/						 if (!this.CF) {								if(index > 0){ 					this.bReUse = true;					this.source_bmd = dest_bmd;					this.dest_bmd = source_bmd;				} else{					this.source_bmd = source_bmd;					this.dest_bmd = dest_bmd;				}								//here we check that all bmds are scaled the right way to avoid blanks				this.checkSizes();				/*				// will be update with threshold instead, to avoid destructive masking				// if the source has an alpha, lets save it				this.tempalphachanel = new BitmapData(this.source_bmd.width, this.source_bmd.height, true, 0x00FFFFFF);				this.tempalphachanel.copyChannel(source_bmd, source_bmd.rect, this.zeropoint, 8,8);				*/				// matrix and filter preparation				this.zeropoint = new Point(0,0);				this.CF = new ConvolutionFilter();				this.CF.matrixX = 3;				this.CF.matrixY = 3;				this.CF.bias = 127;				this.DP = new DisplacementMapFilter();				this.DP.componentX = 1;				this.DP.componentY = 2;				this.DP.scaleX =  -127;				this.DP.scaleY =  -127;				this.DP.mode = "clamp";//color								if(this.mask_bmd != null && this.bOverlaymask){					this.overlay_bmd = this.source_bmd.clone();					this.inverseMask(this.overlay_bmd);					this.overlayscratch_bmd = new BitmapData(this.overlay_bmd.width, this.overlay_bmd.height, false);					this.overlayalpha_bmd = this.source_bmd.clone();				}				 				if(this.mask_bmd != null && !this.bTotalmask){					 this.applyMask(this.bump_bmd);				}								this.tempmap = this.bump_bmd.clone();				this.dummy = this.bump_bmd.clone();				 								// we generate the bump information				// and apply the transformmapping to the filter				this.buildbump();				 				 if(this.bAnimate){					  MCClassManager.getMCClass("BasicRenderer").addEventListener("RENDER", this.updateBump); 				 } else{ 					  MCClassManager.getMCClass("BasicRenderer").addEventListener("RENDER", this.updateBumpOnce);					 				 }				 								 				//precalculations for the reflections				// this.precalX =  (this.light_bmd.width / 2) + ((this.light_bmd.width / 2) - 1);				// this.precalY = (this.light_bmd.height / 2) + ((this.light_bmd.height / 2) - 1);				 			}						 			//NOTE THAT THIS CODE WILL BE REUSED FOR THE BITMAPDATA TRACERS			// not implemented yet, support for anim true/false			//			// in case false, the code would not be runned			try{				 			   if(this.light_bmd != null){				   // if a lightmap is available				   					//normal coordinates										  /*					///var val =  Math.sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);																				//var mod:Number = modulo*val;										if (mod != 0 && mod != 1)					{					x /= mod;					y /= mod;					z /= mod;					}							*/							//var U:int = (this.precalX/ Math.abs(1/ normal.x))/this.precalX;										//var V:int = (this.precalY/ Math.abs(1/normal.y))/this.precalY;					//trace("norm1: "+U+" x"+V);					// var U:int = this.precalX / ((1/normal.x)*this.light_bmd.width + this.light_bmd.width-1);					// var V:int = this.precalY / ((1/normal.y)*this.light_bmd.height + this.light_bmd.height-1);					//trace("norm2: "+U+" x"+V+"\n");										//var U:int = this.precalX / (( normal.x)*this.light_bmd.width + this.light_bmd.width-1);					//var V:int = this.precalY / (( normal.y)*this.light_bmd.height + this.light_bmd.height-1);										//first version					//var U:int = Math.abs((Math.min(x0,x1,x2)*this.light_bmd.width) / (this.light_bmd.width-(1/normal.x) ));					//var V:int = Math.abs((Math.min(y0,y1,y2)*this.light_bmd.height) / (this.light_bmd.height-(1/normal.y) ));															//second version					//var U:int = Math.abs((Math.min(x0,x1,x2)*this.light_bmd.width) / (this.light_bmd.width-(1) ));					//var V:int = Math.abs((Math.min(y0,y1,y2)*this.light_bmd.height) / (this.light_bmd.height-(1) ));										//third version					var w = this.light_bmd.width ;					var h = this.light_bmd.height ;					var U:int = Math.abs(   ( w / (normal.x)) + ((w)-1)   );					var V:int = Math.abs(   ( h / (normal.y)) + ((h)-1)   );																									 																				var oldx = destrect.x;					var oldy = destrect.y;					destrect.x = U;					destrect.y = V;					//this.dest_bmd.copyPixels(this.light_bmd, destrect, new Point(oldx,oldy));										/* 					var theta = Math.atan(normal.y/normal.x);					var rho = Math.cos (normal.z/this.light_bmd.width);					 var oldx = destrect.x;					 var oldy = destrect.y;					 destrect.x = theta;					 destrect.y = rho;					this.dest_bmd.copyPixels(this.light_bmd, destrect, new Point(oldx,oldy));					*/																									//area improvement					if(!this._usedrect){						this._usedrect = destrect;					}else{						this._usedrect = this._usedrect.union(destrect);					}									}				//else{					// no, lets apply the bump to the source itself					//this.dest_bmd.applyFilter(this.source_bmd, destrect, this.zeropoint,DP);  				//}				// 32 bits masking... give sometimes black dots/area artifacts.				//this.dest_bmd.copyChannel(this.tempalphachanel, destrect, this.zeropoint, 8,8);			} catch(er:Error){				trace("Bump error, rect is probably null --> see material caller"+er.message);			}									 			 		}		private function updateBumpOnce(e:Event):void{			this.reDraw();			this._usedrect = source_bmd.rect;			this.dest_bmd = source_bmd;			this.reDraw();			MCClassManager.getMCClass("BasicRenderer").removeEventListener("RENDER", this.updateBumpOnce);		}		private function updateBump(e:Event):void{			this.reDraw();		}		public function reDraw():void		{			 			try{				this._usedpoint.x = this._usedrect.x;				this._usedpoint.y = this._usedrect.y;				this._usedrect.width +=this._usedrect.x;				this._usedrect.height +=this._usedrect.y;				this._usedrect.x = 0;				this._usedrect.y = 0;								if(this.light_bmd != null){  				 	 					 this.dest_bmd.applyFilter(this.light_bmd, this._usedrect, this.zeropoint, this.DP);					 					 				} else{					this.dest_bmd.applyFilter(this.source_bmd, this._usedrect, this.zeropoint, this.CF);				}								this._usedrect.x = this._usedpoint.x;				this._usedrect.y = this._usedpoint.y;												if(this._mode != ""){					//add, overlay, screen, substract, multiply, layer, invert, hardlight, erase, darken, alpha, difference					this.dest_bmd.draw(this.source_bmd,null,null,this._mode,this._usedrect, false);				}				 				if(this.bTotalmask){					this.applyMask(this.dest_bmd);				}								if(this.bOverlaymask){					this.overlayalpha_bmd.copyChannel(this.dest_bmd, this._usedrect, this._usedpoint, 8, 1);					this.overlayscratch_bmd.copyPixels(this.dest_bmd,this._usedrect,this._usedpoint, this.dest_bmd,this._usedpoint,false);					this.overlayscratch_bmd.copyPixels(this.overlay_bmd,this._usedrect,this._usedpoint, this.overlay_bmd,this._usedpoint,false);					this.dest_bmd.copyPixels(overlayscratch_bmd,this._usedrect,this._usedpoint, overlayscratch_bmd,this._usedpoint,false);					this.dest_bmd.copyChannel(this.overlayalpha_bmd, this._usedrect, this._usedpoint, 1, 8);				}				//reset used rect				this._usedrect = null;																				//this.container = container;				//container.filters = [this.DP];				// this.container.x = 250;				// trace(1);				//  trace("hello"+this.container.parent.x);				 			} catch(er:Error){				//trace("Bump error:"+er.message);			} 			 		}				public function displacement():DisplacementMapFilter		{		return this.DP;		}		 	}}