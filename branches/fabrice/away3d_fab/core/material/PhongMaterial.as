package away3d.core.material{	import away3d.core.*;    import away3d.core.math.*;    import away3d.core.scene.*;    import away3d.core.draw.*;    import away3d.core.render.*;    import away3d.core.utils.*;    import flash.display.*;    import flash.geom.*;	import flash.events.Event;	import away3d.core.material.*;	import away3d.core.mesh.Vertex;	import away3d.register.AWClassManager;		import away3d.core.material.filters.AWDisplacementMapFilter;	import away3d.core.material.filters.AWConvolutionFilter;    public class PhongMaterial implements ITriangleMaterial, IUVMaterial, IAverage, IPhongLight    {        public var bitmap:BitmapData;		public var bumpmap:BitmapData;				public var rect:Rectangle;        public var smooth:Boolean;        public var debug:Boolean;        public var repeat:Boolean;				private var eTri0x:Number;		private var eTri0y:Number;		private var eTri1x:Number;		private var eTri1y:Number;		private var eTri2x:Number;		private var eTri2y:Number;				internal var mapping:Matrix;		internal var normalmapping:Matrix = new Matrix();						private var halfW:Number;		private var halfH:Number;				public function get average():Boolean        {            return true;        }				public function get phonglight():Boolean        {            return true;        }		        public function get width():Number        {            return (bitmap == null)? 256 : bitmap.width;        }        public function get height():Number        {            return (bitmap == null)? 256 : bitmap.height;        }		        public function PhongMaterial(init:Object = null, bitmap:BitmapData = null, bumpmap:BitmapData = null)        {            this.bitmap = bitmap;			this.bumpmap = bumpmap;			            init = Init.parse(init);            smooth = init.getBoolean("smooth", false);            debug = init.getBoolean("debug", false);            repeat = init.getBoolean("repeat", false);						if(AWClassManager.getClass("GLOBALLIGHT") == null){				new GlobalLight();			}						if(this.bumpmap != null){				this.bumpmap = bumpmap.clone(); 				if(this.bitmap == null){					this.bitmap = this.bumpmap.clone();				}				this.convomap(this.bumpmap);			}						halfW = (width * .5);			halfH = (height * .5);        }				private function convomap(source:BitmapData):void		{			var zeropoint:Point = new Point(0,0);			var CF = AWConvolutionFilter.instance.createFilter(3, 3, [0,0,0,-1,0,1,0,0,0], 1, 127, true, true, 0, 0);			var tmpsource:BitmapData = source.clone();			tmpsource = source.clone();			tmpsource.applyFilter(source, tmpsource.rect, zeropoint, CF);			//bumpmap = source.clone();			bumpmap.copyPixels(tmpsource, tmpsource.rect, zeropoint);			CF.matrix = new Array(0, -1, 0, 0, 0, 0, 0, 1, 0);			tmpsource = source.clone();			tmpsource.applyFilter(source, tmpsource.rect, zeropoint, CF);			bumpmap.copyChannel(tmpsource, tmpsource.rect, zeropoint, 1, 2);			tmpsource.dispose();			 		}		        public function renderTriangle(tri:DrawTriangle, session:RenderSession):void        {			var mapping:Matrix = tri.texturemapping || tri.transformUV(this);						if(bumpmap != null && tri.face.source.bumpmap == null ){				//give to mesh now...				tri.face.source.bumpmap = this.bumpmap;				tri.face.source.sourcemap = (this.bitmap == null)? bumpmap.clone() : this.bitmap.clone();				tri.face.source.dp = AWDisplacementMapFilter.instance.createFilter(bumpmap, new Point(0,0), 1, 2, -127, -127, "wrap", 0, 0);			}			if(this.bitmap != null){				session.renderTriangleBitmap(this.bitmap, mapping, tri.v0, tri.v1, tri.v2, false, false, session.graphics);				session.sprite.blendMode = BlendMode.NORMAL;			} else{				session.graphics;			}						var normal:Object = null;			 			var onorm:Object = new Object;			var norm:Number3D;						var facenorm:Number3D;			var average:Array;			var xnorm:Number;			var ynorm:Number;			var znorm:Number;						// see if the projection is front			//var face_orientation:Boolean = this.isFront(tri.v0, tri.v1, tri.v2);			 			// lets rock and roll!			for(var j:int = 1;j<4;j++){				try{					xnorm = 0;					ynorm = 0;					znorm = 0;					average = tri.face["average0"+j];					for(var i:int = 0;i< average.length;i++){												facenorm = average[i].normal;												xnorm += facenorm.x;						ynorm += facenorm.y;						znorm += facenorm.z;											}										onorm["norm"+j] = new Number3D(xnorm/average.length, ynorm/average.length, znorm/average.length);									} catch(e:Error){					onorm["norm"+j] = new Number3D(0.333, 0.333, 0.333);				}						}									//if(this.bumpmap != null){				//directional offsets				var offsetX = width;				var offsetY = height;								//translate normals to uv 2D projection				/*				eTri0x =  width * ((onorm.norm1.x*.5) + .5);				eTri0y =  height * (1 - ((-(onorm.norm1.y)*.5) + .5));				eTri1x =  width * ((onorm.norm2.x*.5) + .5);				eTri1y =  height * (1 - ((-(onorm.norm2.y)*.5) + .5));				eTri2x =  width * ((onorm.norm3.x*.5) + .5);				eTri2y =  height * (1 - ((-(onorm.norm3.y)*.5) + .5));				*/				eTri0x =  (halfW * onorm.norm1.x) + halfW;				eTri0y =  (halfH * onorm.norm1.y) + halfH;				eTri1x =  (halfW *  onorm.norm2.x) + halfW;				eTri1y =  (halfH * onorm.norm2.y) + halfH;				eTri2x =  (halfW *  onorm.norm3.x) + halfW;				eTri2y =  (halfH * onorm.norm3.y) + halfH;								var oOffsets:Number2D  = tri.face.source._offset;								offsetX = oOffsets.x-halfW;				offsetY = oOffsets.y-halfH;								eTri0x += offsetX;				eTri0y += offsetY;				eTri1x += offsetX;				eTri1y += offsetY;				eTri2x += offsetX;				eTri2y += offsetY;								normalmapping.a=eTri1x - eTri0x;				normalmapping.b=eTri1y - eTri0y;				normalmapping.c=eTri2x - eTri0x;				normalmapping.d=eTri2y - eTri0y;				normalmapping.tx=eTri0x;				normalmapping.ty=eTri0y;				normalmapping.invert();				session.renderTriangleBitmap(AWClassManager.getClass("GLOBALLIGHT").source, normalmapping, tri.v0, tri.v1, tri.v2, false, false, session.graphics2);				session.sprite2.blendMode = BlendMode.OVERLAY;			//}						//session.renderTriangleBitmap(this.lightmap, normalmapping, tri.v0, tri.v1, tri.v2, false, false, session.graphics2);			//session.sprite.blendMode = BlendMode.NORMAL;			//session.sprite2.blendMode = BlendMode.OVERLAY;						if (debug){               session.renderTriangleLine(2, 0x8800FF, 1, tri.v0, tri.v1, tri.v2);			}        }				private function isFront(v0:ScreenVertex, v1:ScreenVertex, v2:ScreenVertex):Boolean		{			return (v2.x - v0.x)*(v2.y - v0.y) < (v1.x-v2.x)* (v1.y-v2.y)		}				private function isBack(v0:ScreenVertex, v1:ScreenVertex, v2:ScreenVertex):Boolean		{			return (v2.x - v0.x)*(v2.y - v0.y) > (v1.x-v2.x)* (v1.y-v2.y)		}         public function get visible():Boolean        {            return true;        }     }}