package away3d.core.ik{    import flash.geom.Matrix;	import away3d.core.scene.Scene3D;	import away3d.core.mesh.Mesh;	import away3d.core.mesh.UV;	import away3d.core.mesh.Vertex;	import away3d.core.mesh.Face;	import away3d.core.scene.MouseEvent3D;	import away3d.core.material.ColorMaterial;	import away3d.core.material.IMaterial;	import away3d.core.math.Number3D;	import away3d.core.math.Quaternion;	import away3d.core.ik.IKEvent;	import away3d.core.ik.Chain;	import away3d.core.ik.ChainUpdater;	//debug	//import away3d.register.MCClassManager;	 	import away3d.core.math.Matrix3D;	    public class Bone extends Mesh    {				public var _start:Number3D;		public var _end:Number3D;		public var _rotations:Number3D;		public var _lengthVector:Number3D;		private var chain:Chain;		public var _length:Number;		public var _vertices:Array;		public var mesh:Mesh;		public var _chainid:int;		public var _parentid:int;		public var _id:int;		public var _boneid:String;		public var _extremity:Boolean;		public var _visible:Boolean;		private static var toDEGREES:Number = 180 / Math.PI;		private static var toRADIANS:Number = Math.PI / 180;		 				public var _matrix:Matrix;	   		function Bone(start:Number3D, end:Number3D ,length:Number, extremity:Boolean, chain:Chain, chainid:int, parentid:int, verticelist:Array, visible:Boolean = false, mat:IMaterial = null, boneid:String = "")		{			this._start = new Number3D(start.x, start.y, start.z);			this._end = new Number3D(start.x, start.y+length, start.z);			this._length = length;			this._vertices = new Array();			this._vertices = this._vertices.concat(verticelist);			this._matrix = new Matrix();			this._chainid = chainid;			this._parentid = parentid-1;			this._id = parentid;			this._boneid = (boneid == "")? "bone"+this._id : boneid;			this.chain = chain;			this._extremity = extremity;			this._visible = visible;			this._rotations = new Number3D(1,1,1);			this._lengthVector = new Number3D(0,length,0);			if(visible){				super({material:mat, x:this._start.x, y:this._start.y, z:this._start.z});				this.generateBoneMesh(this._length);			}		}				public function get boneid():String		{			return this._boneid;		}		//		//MouseEvents		public function setMouseEvents():void{			this.addOnMouseDown(this.onPressMouse);			this.addOnMouseMove(this.onMoveMouse);			this.addOnMouseOut(this.onOutMouse);			this.addOnMouseOver(this.onOverMouse);			this.addOnMouseUp(this.onUpMouse);		}		public function onPressMouse(event:MouseEvent3D){			 			//trace("Bone"+this._id+" says parentID: "+(this._parentid)+", extrimity: "+this._extremity+", chainid: "+this._chainid);						this._rotations.x += 0;			this._rotations.y += 45;			this._rotations.z += 0;			this.rotateUpdate(this._start, true);			 		}		public function onMoveMouse(event:MouseEvent3D){			//trace("move bone");		}		public function onOutMouse(event:MouseEvent3D){			//trace("out bone");		}		public function onOverMouse(event:MouseEvent3D){			//trace("over bone");		}		public function onUpMouse(event:MouseEvent3D){			//trace("up bone");		}						//geomtrie if visible		private function generateBoneMesh(length:Number):void		{				trace("generate bone...");						var yfloor:Number = (length/100)*10;			var width:Number = (yfloor*1.5)*.5;			 			var vertices = new Array();			vertices[0] = new Vertex(0, 0, 0);			vertices[1] = new Vertex(-width, yfloor, width);			vertices[2] = new Vertex(width, yfloor, width);			vertices[3] = new Vertex(width, yfloor, -width);			vertices[4] = new Vertex(-width, yfloor, -width);			vertices[5] = new Vertex(0, length, 0);						// fake uvs since we will only use trace line and fills			var uv1 = new UV(0,0);			var uv2 = new UV(1,0.5);			var uv3 = new UV(0.5,1);			//zero pyramide			addFace(new Face(vertices[0], vertices[1], vertices[2], null, uv1, uv2, uv3));			addFace(new Face(vertices[0], vertices[2], vertices[3], null, uv1, uv2, uv3));			addFace(new Face(vertices[0], vertices[3], vertices[4], null, uv1, uv2, uv3));			addFace(new Face(vertices[0], vertices[4], vertices[1], null, uv1, uv2, uv3));			//top pyramide			addFace(new Face(vertices[1], vertices[5], vertices[2], null, uv1, uv2, uv3));			addFace(new Face(vertices[2], vertices[5], vertices[3], null, uv1, uv2, uv3));			addFace(new Face(vertices[3], vertices[5], vertices[4], null, uv1, uv2, uv3));			addFace(new Face(vertices[4], vertices[5], vertices[1], null, uv1, uv2, uv3));					}				public function get extremity():Boolean		{			return this._extremity;		}		public function set extremity(extremity:Boolean):void		{			this._extremity = extremity;		}				public function get verticelist():Array		{			return this._vertices;		}				public function set verticelist(avertices:Array):void		{				this._vertices = new Array();			this._vertices = vertices.concat();		}				public function get length():Number		{			return this._length;		}				public function set length(val:Number):void		{			this._length = val;		}				public function get matrix():Matrix		{			return this._matrix;		}				public function set matrix(mat:Matrix):void		{			this._matrix = mat;		}		/* ALEX				rootbone = new Scene();		bone1 = new ObjectContainer3D({parent:rootbone, x:100});		bone2 = new ObjectContainer3D({parent:rootbone, x:-100});		bone11 = new ObjectContainer3D({parent:bone1, x:50});		bone111 = new ObjectContainer3D({parent:bone11, x:50});				If that is NOT what you want - replace each container with TWO containers.				First with {x:100, y:0, z:0} coordinate - you DON'T rotate that.		Second (the child of first) with {0,0,0} coordinates - you rotate that.				This CAN'T be not working		9:09 PM 		Once you got THAT working, you can start coding again - but you will have a REFERENCE and you could trace down to the plus or multiply sign that goes WRONG.		FaBriCe 9:09 PM		how to get matrixes then?		Alexander Zadorozhny 9:10 PM		Don't get the matrixes. Just get scenePosition		FaBriCe 9:13 PM		but how to affect geometry then if i have only scneposition?				*/ 		// here we get new base start from previous bone and destination rotation		public function rotateUpdate(newstart:Number3D, isOwner:Boolean):void		{						//if(isOwner){						if (this._rotations.x > 360 || this._rotations.x <-360) {				this._rotations.x = this._rotations.x % 360;			}			if (this._rotations.y > 360 || this._rotations.y <-360) {				this._rotations.y = this._rotations.y % 360;			}			if (this._rotations.z > 360 || this._rotations.z <-360) {				this._rotations.z = this._rotations.z % 360;			}						this._lengthVector = new Number3D(0,this._length, 0);			ChainUpdater.rotateXYZ([this._lengthVector],  this._rotations.x * toRADIANS , this._rotations.y * toRADIANS , this._rotations.z * toRADIANS );			trace(this._lengthVector);						var myRotate:Matrix3D = new Matrix3D();			//myRotate.translate(-this._start.x,-this._start.y,-this._start.z);			myRotate.szx = -this._start.x;			myRotate.szy = -this._start.y;			myRotate.szz = -this._start.z;			/*			myRotate.rotate(this._rotations.x * toRADIANS , this._rotations.y * toRADIANS , this._rotations.z * toRADIANS);			//myRotate.translate(-this._start.x,-this._start.y,-this._start.z);			myRotate.szx = -this._start.x;			myRotate.szy = -this._start.y;			myRotate.szz = -this._start.z;			*/			var multiple:Matrix3D = Matrix3D.multiply(this.transform, myRotate);			this.transform = multiple;						/*			this._end = Number3D.add(this._start,this._lengthVector);			 			if(isOwner && this._visible){								this.rotationX =  this.rotationX;				this.rotationY =  this.rotationY;				this.rotationZ =  this.rotationZ;			} else{							this._start.x = newstart.x;				this._start.y = newstart.y;				this._start.z = newstart.z;			}						if(this._visible){								this.x = this._start.x;				this.y = this._start.y;				this.z = this._start.z;								this.rotationX =  this._rotations.x;				this.rotationY =  this._rotations.y;				this.rotationZ =  this._rotations.z;			}						if(!this._extremity){				trace("rotate bone:"+this._id+" and update next: "+(this._id+1));				//trace("this._start: "+this._start);				//trace("this._end: "+this._end+"\n");				this.chain.bones[this._id+1].rotateUpdate(this._end, false) ;			} 			*/		} 		//start point		public function get start():Number3D		{			return this._start;		}				public function set start(nstart:Number3D):void		{			trace("old start:"+this._start);			this._start.x = nstart.x;			this._start.y = nstart.y;			this._start.z = nstart.z;			trace("new start:"+this._start);			if(this._visible){								trace("update model"+this._id+" x:"+this.x+" y:"+this.y+" z:"+this.z);				this.x = this._start.x;				this.y = this._start.y;				this.z = this._start.z;			}			// --> here comes update calculation end vertice		}		public function updateStart(noffset:Number3D):void		{						this._start.x += noffset.x;			this._start.y += noffset.y;			this._start.z += noffset.z;			this.updateEnd(noffset);			if(this._visible){				this.x = this._start.x;				this.y = this._start.y;				this.z = this._start.z;			}		}		//end point		public function get end():Number3D		{			return this._end;		}				public function set end(nend:Number3D):void		{				this._end.x = nend.x;			this._end.y = nend.y;			this._end.z = nend.z;		}		public function updateEnd(nend:Number3D):void		{			this._end.x += nend.x;			this._end.y += nend.y;			this._end.z += nend.z;		}    }}