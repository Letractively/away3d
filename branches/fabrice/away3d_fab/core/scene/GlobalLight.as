//Fabrice Closier, www.closier.nl, 2007//package away3d.core.scene{	import away3d.core.math.Number3D;	import away3d.core.math.Number2D;	import flash.display.*;	import flash.geom.Matrix;	import away3d.register.AWClass;		public class GlobalLight extends AWClass	{		private var phongmap:BitmapData;		private var aLights:Array;		private var lightradius:int = 1000;				function GlobalLight(lights:Array = null)		{			this.register("GLOBALLIGHT");			this.aLights = new Array();			if(lights != null && lights.length >0){				this.aLights = this.aLights.concat(lights);			} else{				this.aLights.push( {id:"default", color:0x663399, position:new Number3D(.5,.5,.5) });			}			// now we do only one source light, next version we support multiple light sources			this.generateSource();		}				private function generateSource():void		{			// 768 is hardcoded. we need to rescale according to mesh boundingbox ???			// it offer in many cases enough resolution, and since uts rendered only once it should be enough.			// only one light for this first code...			// for loop in this.aLights[0].color required when more			this.phongmap = new BitmapData(768, 768, false, 0xFFFFFF);			var tmpsprite = new Sprite();			var mat:Matrix = new Matrix();			mat.createGradientBox(768, 768, 0, 0, 0);			var color:uint = this.aLights[0].color;			tmpsprite.graphics.beginGradientFill(GradientType.RADIAL, [color, color, 0x131313], [80, 0, 10], [0, 120, 255], mat, "pad");			tmpsprite.graphics.drawRect(0,0,768, 768);			this.phongmap.draw(tmpsprite,null,null,null,this.phongmap.rect,true);		}		public function getOffsets(position:Number3D):Number2D		{			//here offset mesh with light are calculated			// var dist = Math.sqrt((position.x - aLights[0].position.x) * (position.x - aLights[0].position.x) + (position.y - aLights[0].position.y) * (position.y - aLights[0].position.y) + (position.z - aLights[0].position.z) * (position.z - aLights[0].position.z));						//if(dist<this.lightradius){				 var x1:Number = position.x - aLights[0].position.x;				 var y1:Number = position.y - aLights[0].position.y;				 var z1:Number = position.z - aLights[0].position.z;								//dist = this.phongmap.width/(this.lightradius/dist);								var X:Number = Math.atan2(x1, y1)/Math.PI;				var Y:Number = Math.atan2(y1, z1)/Math.PI;								//trace("--> X: "+X+", Y: "+Y);								return  new Number2D(this.phongmap.width * ((X*.5) + .5), this.phongmap.height * (1 - ((-Y*.5) + .5))  );			//} else {				//off range, full shadow				//return  new Number2D(1, 1);			//}									}		/*		public function getOffsets(position:Number3D):Number2D		{			//here offset mesh with light are calculated			var dist = Math.sqrt((position.x - aLights[0].position.x) * (position.x - aLights[0].position.x) + (position.y - aLights[0].position.y) * (position.y - aLights[0].position.y) + (position.z - aLights[0].position.z) * (position.z - aLights[0].position.z));						if(dist<this.lightradius){				var x1:Number = position.x - aLights[0].position.x;				var y1:Number = position.y - aLights[0].position.y;				var z1:Number = position.z - aLights[0].position.z;								dist = dist/this.lightradius;								var X:Number = (Math.atan2(y1, x1)/Math.PI+(this.phongmap.width/dist))*.5;				var Y:Number =  (Math.atan2(z1, x1)/Math.PI+(this.phongmap.height/dist ))*.5;								trace("--> X: "+X+", Y: "+Y);								return  new Number2D(this.phongmap.width * ((X*.5) + .5), this.phongmap.height * (1 - ((-(Y)*.5) + .5))  );			} else {				//off range, full shadow				return  new Number2D(1, 1);			}		}				public function getOffsets(position:Number3D):Number2D		{			//position = mesh position			//trace(position);			//here offset mesh with light are calculated						var x1:Number = position.x - aLights[0].position.x;			var y1:Number = position.y - aLights[0].position.y;			var z1:Number = position.z - aLights[0].position.z;						var dist = Math.sqrt((position.x - aLights[0].position.x) * (position.x - aLights[0].position.x) + (position.y - aLights[0].position.y) * (position.y - aLights[0].position.y) + (position.z - aLights[0].position.z) * (position.z - aLights[0].position.z));						var X:Number = (Math.atan2(y1, x1)/Math.PI+(dist/768))*.5;			var Y:Number =  (Math.atan2(z1, x1)/Math.PI+(dist/768))*.5;									return  new Number2D(this.phongmap.width * ((X*.5) + .5), this.phongmap.height * (1 - ((-(Y)*.5) + .5))  );		}				public function getOffsets_version_1(position:Number3D):Number2D		{						var x1:Number = Math.abs(position.x) - aLights[0].position.x;			var y1:Number = Math.abs(position.y) - aLights[0].position.y;			var z1:Number = Math.abs(position.z) - aLights[0].position.z;									var X:Number = Math.atan2(y1, x1)/Math.PI;			var Y:Number = Math.atan2(z1, x1)Math.PI; 			return  new Number2D(this.phongmap.width * ((X*.5) + .5), this.phongmap.height * (1 - ((-(Y)*.5) + .5))             );			//return  new Number2D(this.phongmap.width * ((aLights[0].position.x*.5) + .5), this.phongmap.height * (1 - ((-(aLights[0].position.y)*.5) + .5))             );		}		*/		public function get source():BitmapData		{			return this.phongmap;		}				public override function set x(val:Number):void		{			this.aLights[0].position.x = val;		}		public override function set y(val:Number):void		{			this.aLights[0].position.y = val;		}		public function set z(val:Number):void		{			this.aLights[0].position.z = val;		}					}}