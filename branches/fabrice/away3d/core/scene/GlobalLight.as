//Fabrice Closier, www.closier.nl, 2007//package away3d.core.scene{	import away3d.core.math.Number3D;	import away3d.core.math.Number2D;	import flash.display.*;	import flash.geom.Matrix;	import away3d.register.AWClass;			//debug	import nl.fabrice.draw.BresenhamTracer;	import flash.geom.*;	import away3d.register.AWClassManager;	//debug		public class GlobalLight extends AWClass	{		private var phongmap:BitmapData;		private var aLights:Array;		//if lightradius<bitmapsize =  bitmapsize		private var lightradius:int = 1000;				function GlobalLight(lights:Array = null)		{			this.register("GLOBALLIGHT");			this.aLights = new Array();			if(lights != null && lights.length >0){				this.aLights = this.aLights.concat(lights);			} else{				this.aLights.push( {id:"default", color:0x663399, position:new Number3D(500,500,0) });			}			// now we do only one source light, next version we support multiple light sources			this.generateSource();		}				private function generateSource():void		{			// 768 is hardcoded. we need to rescale according to mesh boundingbox ???			// it offer in many cases enough resolution, and since uts rendered only once it should be enough.			// only one light for this first code...			// for loop in this.aLights[0].color required when more			this.phongmap = new BitmapData(768, 768, false, 0xFFFFFF);			var tmpsprite = new Sprite();			var mat:Matrix = new Matrix();			mat.createGradientBox(768, 768, 0, 0, 0);			var color:uint = this.aLights[0].color;			tmpsprite.graphics.beginGradientFill(GradientType.RADIAL, [color, color, 0x131313], [80, 0, 10], [0, 120, 255], mat, "pad");			tmpsprite.graphics.drawRect(0,0,768, 768);			this.phongmap.draw(tmpsprite,null,null,null,this.phongmap.rect,true);		}				public function getOffsets(position:Number3D):Number2D		{			//here offset mesh with light are calculated			var dist = Math.sqrt((position.x - aLights[0].position.x) * (position.x - aLights[0].position.x) + (position.y - aLights[0].position.y) * (position.y - aLights[0].position.y) + (position.z - aLights[0].position.z) * (position.z - aLights[0].position.z));						if(dist<this.lightradius){				/*				var x1:Number = position.x - aLights[0].position.x;				var y1:Number = position.y - aLights[0].position.y;				var z1:Number = position.z - aLights[0].position.z;								var distV = this.phongmap.height/dist;				var distH = this.phongmap.width/dist;								var X:Number = (Math.atan2(y1, x1)/Math.PI);//*.5;+(this.phongmap.width/dist)				var Y:Number =  (Math.atan2(z1, x1)/Math.PI);//*.5;+(this.phongmap.height/dist )				*/				var scale =  (768 /this.lightradius) ;				//debug traces				var scope = AWClassManager.getClass("MAIN");				//light				var offsetscale = (this.lightradius*.5)*scale;				//trace(offsetscale);				var posLX = (aLights[0].position.x*scale)+offsetscale;				var posLY = (aLights[0].position.y*scale)+offsetscale;				var posLZ = (aLights[0].position.z*scale)+offsetscale;								var posX = (position.x*scale)+offsetscale;				var posY = (position.y*scale)+offsetscale;				var posZ = (position.z*scale)+offsetscale;																var x1:Number = (posX - posLX)+offsetscale;				var y1:Number = (posY - posLY)+offsetscale;				var z1:Number = (posZ - posLZ)+offsetscale;												var X:Number = (Math.atan2(y1, x1)/Math.PI);//*.5;+(this.phongmap.width/dist)				var Y:Number =  (Math.atan2(z1, x1)/Math.PI);//*.5;+(this.phongmap.height/dist )												scope.debugtracebmd.copyPixels(this.phongmap, this.phongmap.rect, new Point(0,0));								//BresenhamTracer.getInstance().bresCircle(scope.debugtracebmd, posLX-5 , posLY-5, 10, 0xFFFFFF, 1);				scope.debugtracebmd.fillRect(new Rectangle(x1-5 , y1-5 , 10 , 10), 0xFF00FF)				scope.debugtracebmd.fillRect(new Rectangle(y1-5 , z1-5 , 10 , 10), 0x00FF00)				//BresenhamTracer.getInstance().bresCircle(scope.debugtracebmd, posX-5 , posY-5, 10, 0x00FF00, 1);				//				BresenhamTracer.getInstance().traceLine(scope.debugtracebmd, posLX-5, posLY-5, posX-5, posY-5, 0xFFFFFF, 1);				//::::::::::::::::::::::::::								//trace((this.phongmap.height/dist))				//trace("--> X: "+X+", Y: "+Y);								return  new Number2D(((this.phongmap.width)+.5) * ((X*.5) + .5), ((this.phongmap.height)+.5) * (1 - ((-(Y)*.5) + .5))  );			} else {				//off range, full shadow				return  new Number2D(1, 1);			}		}		/*		/V1 working with 2 values -1,1		public function getOffsets(position:Number3D):Number2D		{			//position = mesh position			//trace(position);			//here moet offset berekend worden t.o.v mesh			return  new Number2D(this.phongmap.width * ((aLights[0].position.x*.5) + .5), this.phongmap.height * (1 - ((-(aLights[0].position.y)*.5) + .5))             );		}				public function getOffsets(position:Number3D):Number2D		{			//position = mesh position			//trace(position);			//here offset mesh with light are calculated						var x1:Number = position.x - aLights[0].position.x;			var y1:Number = position.y - aLights[0].position.y;			var z1:Number = position.z - aLights[0].position.z;						var dist = Math.sqrt((position.x - aLights[0].position.x) * (position.x - aLights[0].position.x) + (position.y - aLights[0].position.y) * (position.y - aLights[0].position.y) + (position.z - aLights[0].position.z) * (position.z - aLights[0].position.z));						var X:Number = (Math.atan2(y1, x1)/Math.PI+(dist/768))*.5;			var Y:Number =  (Math.atan2(z1, x1)/Math.PI+(dist/768))*.5;									return  new Number2D(this.phongmap.width * ((X*.5) + .5), this.phongmap.height * (1 - ((-(Y)*.5) + .5))  );		}				public function getOffsets_version_1(position:Number3D):Number2D		{						var x1:Number = Math.abs(position.x) - aLights[0].position.x;			var y1:Number = Math.abs(position.y) - aLights[0].position.y;			var z1:Number = Math.abs(position.z) - aLights[0].position.z;									var X:Number = Math.atan2(y1, x1);			var Y:Number = Math.atan2(z1, x1);			X /= Math.PI;			Y /= Math.PI;						return  new Number2D(this.phongmap.width * ((X*.5) + .5), this.phongmap.height * (1 - ((-(Y)*.5) + .5))             );			//return  new Number2D(this.phongmap.width * ((aLights[0].position.x*.5) + .5), this.phongmap.height * (1 - ((-(aLights[0].position.y)*.5) + .5))             );		}		*/		public function get source():BitmapData		{			return this.phongmap;		}				public override function set x(val:Number):void		{			this.aLights[0].position.x = val;		}		public override function set y(val:Number):void		{			this.aLights[0].position.y = val;		}		public function set z(val:Number):void		{			this.aLights[0].position.z = val;		}					}}