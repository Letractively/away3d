package away3d.core.ik{    import flash.geom.Matrix;	import away3d.core.scene.Scene3D;	import away3d.core.mesh.Mesh;	import away3d.core.mesh.UV;	import away3d.core.mesh.Face;	    public class Bone extends Mesh    {				public var _x:Number;		public var _y:Number;		public var _z:Number;		public var _length:Number;		public var _vertices:Array;		public var mesh:Mesh;		public var _chainid:int;		public var _parentid:int;		//public var scene:*;						public var _matrix:Matrix;	   		function Bone(x:Number,y:Number,z:Number,length:Number, scene:*, chainid:int = null, parentid:int = null):void		{			this._x = x;			this._y = y;			this._z = z;			this._length = length;			this.scene = scene;			this._vertices = new Array();			this._matrix = new Matrix();			this.generateBoneMesh(this._length);		}				private function generateBoneMesh(length:Number):void		{				this.mesh = new Mesh(init);						var yFloor:Number = (length/100)*20;			var width:Number = (yfloor*1.5)*.5;			 			var vertices = new Array();			vertices[0] = {x:0, y:0, z:0};			vertices[1] = {x:-width, y:yfloor, z:width};			vertices[2] = {x:width, y:yfloor, z:width};			vertices[3] = {x:width, y:yfloor, z:-width};			vertices[4] = {x:-width, y:yfloor, z:-width};			vertices[5] = {x:0, y:length, z:0};						// fake uvs since we will only use trace line and fills			var uv1 = new UV(0,0);			var uv2 = new UV(1,0.5);			var uv3 = new UV(0.5,1);			//zero pyramide			this.mesh.addFace(new Face(vertices[0], vertices[1], vertices[2], null, uv1, uv2, uv3));			this.mesh.addFace(new Face(vertices[0], vertices[2], vertices[3], null, uv1, uv2, uv3));			this.mesh.addFace(new Face(vertices[0], vertices[3], vertices[4], null, uv1, uv2, uv3));			this.mesh.addFace(new Face(vertices[0], vertices[4], vertices[1], null, uv1, uv2, uv3));			//top pyramide			this.mesh.addFace(new Face(vertices[1], vertices[5], vertices[2], null, uv1, uv2, uv3));			this.mesh.addFace(new Face(vertices[2], vertices[5], vertices[3], null, uv1, uv2, uv3));			this.mesh.addFace(new Face(vertices[3], vertices[5], vertices[4], null, uv1, uv2, uv3));			this.mesh.addFace(new Face(vertices[4], vertices[5], vertices[1], null, uv1, uv2, uv3));											}				public function get verticesgroup():Array		{			return this._vertices;		}				public function set verticesgroup(vertices:Array):void		{				this._vertices = new Array();			this._vertices = vertices.concat();		}				/*		public function get matrix():Number		{			return this._matrix;		}				public function set matrix(mat:Matrix):void		{			this._matrix = mat;		}				public function get x():Number		{			return this._x;		}				public function set x(value:Number):void		{			if (value == this._x)			return;			this._x = value;		}				public function get y():Number		{			return this._y;		}				public function set y(value:Number):void		{			if (value == this._y)			return;			this._y = value;		}		public function get z():Number		{			return this._z;		}				public function set z(value:Number):void		{			if (value == this._z)			return;			this._z = value;		}		*/    }}