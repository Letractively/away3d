package away3d.core.material{    import away3d.core.*;    import away3d.core.math.*;    import away3d.core.proto.*;    import away3d.core.draw.*;    import away3d.core.render.*;    import flash.display.*;    import flash.geom.*;		import away3d.core.material.BitmapCleaner;     public class FillBitmapMaterial implements ITriangleMaterial, IUVMaterial    {		public var dest_bmd:BitmapData;		private var cleaner:Object;		public var oLineColor:Object;		public var oFillColor:Object;		public var oShader:Object;                public function get width():Number        {            return this.dest_bmd.width;        }        public function get height():Number        {            return this.dest_bmd.height;        }		public function clear():void        {            this.cleaner.clear();        }                public function FillBitmapMaterial(dest_bmd:BitmapData, fillcolor:Number, init:Object = null)        {			this.dest_bmd = dest_bmd;			this.oShader = new Object();			this.oShader.light = (!init.light)? "" : init.light;			this.oShader.offsetX = (!init.offsetX)? 0 : init.offsetX;			this.oShader.offsetY = (!init.offsetY)? 0 : init.offsetY;			this.oShader.debug = init.debug;			this.cleaner = new BitmapCleaner(this.dest_bmd, 0x00);						this.oFillColor = new Object();			this.oFillColor.fillcolor = fillcolor;			this.oFillColor.a = fillcolor >> 24 & 0xFF;			this.oFillColor.r = fillcolor >> 16 & 0xFF;			this.oFillColor.g = fillcolor >> 8 & 0xFF;			this.oFillColor.b = fillcolor & 0xFF;						this.oLineColor = new Object();			this.oLineColor.linecolor = (!init.linecolor)? -1 : init.linecolor;			if(this.oLineColor.linecolor != -1){				this.oLineColor.a = init.linecolor >> 24 & 0xFF;				this.oLineColor.r = init.linecolor >> 16 & 0xFF;				this.oLineColor.g = init.linecolor >> 8 & 0xFF;				this.oLineColor.b = init.linecolor & 0xFF;			}        }        public function renderTriangle(tri:DrawTriangle, session:RenderSession):void        {			             var mapping:Matrix = tri.texturemapping || tri.transformUV(this);			 			var a2:Number = (tri.v1.x+this.oShader.offsetX) - (tri.v0.x+this.oShader.offsetX);            var b2:Number = (tri.v1.y+this.oShader.offsetY) - (tri.v0.y+this.oShader.offsetY);            var c2:Number = (tri.v2.x+this.oShader.offsetX) - (tri.v0.x+this.oShader.offsetX);            var d2:Number = (tri.v2.y+this.oShader.offsetY) - (tri.v0.y+this.oShader.offsetY);           	var matrix:Matrix = new Matrix(mapping.a*a2 + mapping.b*c2,                                            mapping.a*b2 + mapping.b*d2,                                            mapping.c*a2 + mapping.d*c2,                                            mapping.c*b2 + mapping.d*d2,                                           mapping.tx*a2 + mapping.ty*c2 + (tri.v0.x+this.oShader.offsetX) ,                                           mapping.tx*b2 + mapping.ty*d2 + (tri.v0.y+this.oShader.offsetY) );			var x0 = tri.v0.x+this.oShader.offsetX;			var y0 = tri.v0.y+this.oShader.offsetY;			var x1 = tri.v1.x+this.oShader.offsetX;			var y1 = tri.v1.y+this.oShader.offsetY;			var x2 = tri.v2.x+this.oShader.offsetX;			var y2 = tri.v2.y+this.oShader.offsetY;						this.cleaner.update(x0, y0, x1, y1, x2, y2)									var fillcolor:Number = this.oFillColor.fillcolor; 						if(tri.normal == null){			 	tri.normal = AmbientLight.getNormal([tri.v0, tri.v1, tri.v2]);			}						if(this.oShader.light != ""){				if(this.oShader.light == "flat"){					this.oShader.fillcolor = AmbientLight.getPolygonColor([tri.v0, tri.v1, tri.v2], AmbientLight.lightcolor, tri.normal);										var a:Number =  oShader.fillcolor >> 24 & 0xFF;					var r:Number =  oShader.fillcolor >> 16 & 0xFF;					var g:Number =  oShader.fillcolor >> 8 & 0xFF;					var b:Number =  oShader.fillcolor & 0xFF;					fillcolor = (this.oFillColor.a+a)/2 << 24 | (this.oFillColor.r+r)/2 << 16 | (this.oFillColor.g+g)/2 << 8 | (this.oFillColor.b+b)/2;				}			} else {				try{					fillcolor = AmbientLight.getPolygonColor([tri.v0, tri.v1, tri.v2], this.oFillColor.fillcolor,  tri.normal);				} catch(e:Error){					fillcolor = this.oFillColor.fillcolor;				}			}						var linecolor:Number = this.oLineColor.linecolor; 			if (this.oLineColor.linecolor != -1){				if(this.oShader.light != ""){					if(this.oShader.light == "flat"){							this.oShader.linecolor = AmbientLight.getPolygonColor([tri.v0, tri.v1, tri.v2], AmbientLight.lightcolor,  tri.normal);														a =  oShader.linecolor >> 24 & 0xFF;							r =  oShader.linecolor >> 16 & 0xFF;							g =  oShader.linecolor >> 8 & 0xFF;							b =  oShader.linecolor & 0xFF;							linecolor = (this.oLineColor.a+a)/2 << 24 | (this.oLineColor.r+r)/2 << 16 | (this.oLineColor.g+g)/2 << 8 | (this.oLineColor.b+b)/2;					}				} else {					try{						linecolor = AmbientLight.getPolygonColor([tri.v0, tri.v1, tri.v2], this.oLineColor.linecolor,  tri.normal);					} catch(e:Error){						linecolor = this.oLineColor.linecolor;					}				}				 			}						BitmapGraphics.renderFilledTriangle(this.dest_bmd, x0, y0, x1, y1, x2, y2, fillcolor,linecolor,this.cleaner.update(x0, y0, x1, y1, x2, y2));			        }        public function get visible():Boolean        {            return true;        }     }}