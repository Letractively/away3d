package away3d.core.material{//import flash.display.BitmapData;import flash.geom.Point;//	public class AmbientLight {		private static var oLight:Object;		public static var lightMag:Number;		 		function AmbientLight(color:Number = 0xFFFFFF, x:Number =-300, y:Number = 300, z:Number = 300, brightness:Number = 100, ambient:Number = .5) {			oLight = new Object();			oLight.x = x;			oLight.y = y;			oLight.z = z;			oLight.brightness = Math.max(Math.min(brightness, 100),0);			oLight.ambient =  Math.max(Math.min(ambient, 1),0);			oLight.ambientvalue = (255/100)*(oLight.ambient*100); 			oLight.color = color;			setLightMagnitude();		}		public static function get lightcolor():Number {			return oLight.color;		}		public function get color():Number {			return oLight.color;		}		public function set color(col:Number):void {			oLight.color = col;		}		public static function get ambientvalue():Number {			return oLight.ambientvalue;		}		public function get ambient():Number {			return oLight.ambient;		}		public function set ambient(val:Number):void {			oLight.ambient = Math.max(Math.min(val, 1),0);			oLight.ambientvalue = (255/100)*(oLight.ambient*100); 		}		public function set lightcolor(col:Number):void {			oLight.color = col;		}		public function get light():Object {			return oLight;		}		public function set brightness(val:Number):void {			oLight.brightness = Math.max(Math.min(val, 100),0);		}		public function set x(val:Number):void {			oLight.x = val;			setLightMagnitude();		}		public function set y(val:Number):void {			oLight.y = val;			setLightMagnitude();		}		public function set z(val:Number):void {			oLight.z = val;			setLightMagnitude();		}		public function set light(newLight:Object):void {			oLight = newLight;			setLightMagnitude();		}		public static function averageNormal(aVectors:Array, basecolor:Number = 0x00, norm:Object = null):Object {						try{				var xn:Number=(aVectors[2].y-aVectors[0].y)*(aVectors[1].z-aVectors[0].z)-(aVectors[2].z-aVectors[0].z)*(aVectors[1].y-aVectors[0].y);				var yn:Number=(aVectors[2].z-aVectors[0].z)*(aVectors[1].x-aVectors[0].x)-(aVectors[2].x-aVectors[0].x)*(aVectors[1].z-aVectors[0].z);				var zn:Number=(aVectors[2].x-aVectors[0].x)*(aVectors[1].y-aVectors[0].y)-(aVectors[2].y-aVectors[0].y)*(aVectors[1].x-aVectors[0].x);										var averageNormal:Number = 1.0/Math.sqrt(xn*xn+yn*yn+zn*zn);				xn *= averageNormal;				yn *= averageNormal;				zn *= averageNormal;												return {xn:xn,yn:yn,zn:zn};							} catch(e:Error){							}			return {xn:1,yn:1,zn:1};		}		public static function getPolygonColor(aVectors:Array, basecolor:Number, norm:Object = null):Number {			try{				var lightFactor:Number = getLightFactor(aVectors[0], aVectors[1], aVectors[2], norm);				var r:Number = basecolor >> 16;				var g:Number = basecolor >> 8 & 0xff;				var b:Number = basecolor & 0xff;				r *= lightFactor;				g *= lightFactor;				b *= lightFactor;				return r << 16 | g << 8 | b;			} catch(e:Error){			}			return basecolor;		}		public static function getLightFactor(tri0:Object, tri1:Object, tri2:Object, norm:Object = null):Number {			//			if(norm == null){				var ab:Object = new Object();				ab.x = tri0.x - tri1.x;				ab.y = tri0.y - tri1.y;				ab.z = tri0.z - tri1.z;				var bc:Object = new Object();				bc.x = tri1.x - tri2.x;				bc.y = tri1.y - tri2.y;				bc.z = tri1.z - tri2.z;				var norm:Object = new Object();				norm.x = (ab.y * bc.z) - (ab.z * bc.y);				//norm.y = -((ab.x * bc.z) - (ab.z * bc.x));				norm.y = (ab.x * bc.z) - (ab.z * bc.x);				norm.z = (ab.x * bc.y) - (ab.y * bc.x);			}			var dotProd:Number = norm.x * oLight.x + norm.y * oLight.y + norm.z * oLight.z;			var normMag:Number = Math.sqrt(norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);						return (Math.acos(dotProd / (normMag * getLightMagnitude())) / Math.PI) * oLight.brightness / 100;		}		private static function getLightMagnitude():Number{			return lightMag;		}		private function setLightMagnitude():void{			lightMag = Math.sqrt(oLight.x * oLight.x + oLight.y * oLight.y + oLight.z * oLight.z);		}	}}