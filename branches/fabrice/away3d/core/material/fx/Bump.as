package away3d.core.material.fx{	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.geom.Matrix;	import flash.filters.ConvolutionFilter;	import flash.filters.DisplacementMapFilter;	import nl.fabrice.bitmapdata.BMDScrollerRegister;	import flash.geom.ColorTransform;	import flash.geom.Transform;	import flash.display.BitmapData;	//	public class Bump	{		public var source_bmd:BitmapData;		public var bump_bmd:BitmapData;		public var dest_bmd:BitmapData;		public var light_bmd:BitmapData;		private var zeropoint:Point = new Point(0,0);		private var CF:ConvolutionFilter;		private var DP:DisplacementMapFilter;		private var dummy:BitmapData;		private var tempmap:BitmapData;		private var resultbmd:BitmapData;		private var tempalphachanel:BitmapData;		private var destPT:Point = new Point(0,0);		//		function Bump(bump_bmd:BitmapData, light_bmd:BitmapData = null)		{			this.bump_bmd = bump_bmd;			this.light_bmd = light_bmd;		}		public function apply(source_bmd:BitmapData, dest_bmd:BitmapData, destrect:Rectangle,  normal:Object = null, CT:ColorTransform = null):void		{				this.applyBump(source_bmd, dest_bmd, destrect, normal, CT);		}		private function buildbump(normal:Object):void		{			this.CF.divisor = 1;//1.0/Math.sqrt(normal.x*normal.x+normal.y*normal.y+normal.z*normal.z);			this.dummy.copyPixels(this.source_bmd , this.source_bmd.rect, this.zeropoint);			this.tempmap.copyPixels(this.source_bmd , this.source_bmd.rect, this.zeropoint);			 			this.CF.matrix = new Array(0,0,0,-1,0,1,0,0,0);			this.dummy.applyFilter(this.bump_bmd, this.bump_bmd.rect, this.zeropoint, this.CF);			this.CF.matrix = new Array(0,-1,0,0,0,0,0,1,0);						this.tempmap.applyFilter(this.bump_bmd, this.bump_bmd.rect, this.zeropoint, this.CF);			this.dummy.copyChannel(this.tempmap, this.tempmap.rect, this.zeropoint, 1, 2);						this.DP.mapBitmap = this.dummy;			this.DP.mapPoint = this.zeropoint;			 		}		/* technotes			applyed formula on each channels			dst (x, y) = ((src (x-1, y-1) * a0 + src(x, y-1) * a1			src(x, y+1) * a7 + src (x+1,y+1) * a8) / divisor) + bias									The filter must be a 3x3 filter.			All the filter terms must be integers between -127 and +127.			The sum of all the filter terms must not have an absolute value greater than 127.			If any filter term is negative, the divisor must be between 2.00001 and 256.			If all filter terms are positive, the divisor must be between 1.1 and 256.			The bias must be an integer.		*/						// rescale bmd in width/height		private function checkSizes():void 		{			var scaleMatrix:Matrix;			var scaledtmpbmd:BitmapData;									if(this.source_bmd.width != this.dest_bmd.width || this.source_bmd.height != this.dest_bmd.height){				var sw:Number = this.source_bmd.width/this.dest_bmd.width;				var sh:Number = this.source_bmd.height/this.dest_bmd.height;				scaleMatrix = new Matrix();				scaleMatrix.scale(sw, sw);				scaledtmpbmd = new BitmapData(this.dest_bmd.width * sw, this.dest_bmd.height * sh, true, 0x00FFFFFF);				scaledtmpbmd.draw(this.source_bmd, scaleMatrix, null, null, scaledtmpbmd.rect, true);				this.source_bmd = scaledtmpbmd.clone();				scaledtmpbmd.dispose();							}			if(this.source_bmd.width != this.bump_bmd.width || this.source_bmd.height != this.bump_bmd.height){				var sw:Number = this.source_bmd.width/this.bump_bmd.width;				var sh:Number = this.source_bmd.height/this.bump_bmd.height;				scaleMatrix = new Matrix();				scaleMatrix.scale(sw, sw);				scaledtmpbmd = new BitmapData(this.source_bmd.width * sw, this.source_bmd.height * sh, true, 0x00FFFFFF);				scaledtmpbmd.draw(this.bump_bmd, scaleMatrix, null, null, scaledtmpbmd.rect, true);				this.bump_bmd = scaledtmpbmd.clone();				scaledtmpbmd.dispose();							}		}				private function applyBump(source_bmd:BitmapData, dest_bmd:BitmapData, destrect:Rectangle, normal:Object, CT:ColorTransform):void		{						 if (!this.CF) {				this.source_bmd = source_bmd;				this.dest_bmd = dest_bmd;				//here we check that all bmds are scaled the right way				this.checkSizes();				// if the source has an alpha				this.tempalphachanel = new BitmapData(this.source_bmd.width, this.source_bmd.height, true, 0x00FFFFFF);				this.tempalphachanel.copyChannel(source_bmd, source_bmd.rect, this.zeropoint, 8,8);				//								this.zeropoint = new Point(0,0);				this.CF = new ConvolutionFilter();				this.CF.matrixX = 3;				this.CF.matrixY = 3;				this.CF.bias = 127;				this.DP = new DisplacementMapFilter();				this.DP.componentX = 1;				this.DP.componentY = 2;				this.DP.scaleX =  -127;				this.DP.scaleY =  -127;				this.DP.mode = "color";				 				this.tempmap = this.bump_bmd.clone();				this.dummy = this.bump_bmd.clone();				this.resultbmd = this.bump_bmd.clone();				this.buildbump(normal);				//lets rendered as a dead texture...				if(this.light_bmd != null){					this.dest_bmd.applyFilter(this.light_bmd, this.light_bmd.rect, this.zeropoint,DP);				}else{					this.dest_bmd.applyFilter(this.source_bmd, this.source_bmd.rect, this.zeropoint,DP);				}			}			 			try{			   if(this.light_bmd != null){					this.destPT.x = Math.round(destrect.x);					this.destPT.y =  Math.round(destrect.y);					destrect.width = Math.round(destrect.width);					destrect.height = Math.round(destrect.height);					//trace(destrect.width+" x "+destrect.height)					this.dest_bmd.applyFilter(this.light_bmd, destrect, this.destPT,DP);				} else{					this.dest_bmd.applyFilter(this.source_bmd, destrect, this.destPT,DP);  				}				// 32 bits masking... give so some artifacts				//this.dest_bmd.copyChannel(this.tempalphachanel, destrect, this.destPT, 8,8);			} catch(er:Error){				//rect is fucked up and probably null..			}						 			 		}	}}