package away3d.core.material.fx{	import flash.display.BitmapData;	import away3d.register.MCClassManager;	import flash.events.*;	import flash.filters.DisplacementMapFilter;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.geom.ColorTransform;	//	public class PerlinNoise extends EventDispatcher	{		private var baseX:Number;		private var baseY:Number;		private var numOctaves:uint;		private var randomSeed:int;		private var stitch:Boolean;		private var fractalNoise:Boolean;		private var channelOptions:uint;		private var grayScale:Boolean;		private var offsets:Array;		private var zeropoint:Point = new Point(0,0);		private var DP:DisplacementMapFilter;		public var perlin_bmd:BitmapData;		public var dest_bmd:BitmapData;		public var source_bmd:BitmapData;		private var index:int;		//		function PerlinNoise(perlin_bmd:BitmapData, baseX:Number, baseY:Number, numOctaves:uint, randomSeed:int, stitch:Boolean, fractalNoise:Boolean, channelOptions:uint = 7, grayScale:Boolean = false, offsets:Array = null)		{						this.baseX = baseX;			this.baseY = baseY;			this.numOctaves = numOctaves;			this.randomSeed = randomSeed;			this.stitch = stitch;			this.fractalNoise = fractalNoise;			this.channelOptions = channelOptions;			this.grayScale = grayScale;			this.offsets = offsets;			 		}		public function apply(index:int, source_bmd:BitmapData, dest_bmd:BitmapData, destrect:Rectangle,  normal:Object = null, CT:ColorTransform = null):void		{				this.applyPerlin(index, source_bmd, dest_bmd, destrect, normal, CT);		}				private function applyPerlin(index:int, source_bmd:BitmapData, dest_bmd:BitmapData, destrect:Rectangle, normal:Object, CT:ColorTransform):void		{			if(!this.DP){				this.dest_bmd = dest_bmd;				this.source_bmd = source_bmd;				this.DP = new DisplacementMapFilter();				this.DP.componentX = 1;				this.DP.componentY = 2;				this.DP.scaleX =  -127;				this.DP.scaleY =  -127;				this.DP.mode = "clamp";//clamp,color,wrap				this.perlin_bmd = dest_bmd;				this.perlin_bmd.perlinNoise(baseX, baseY, numOctaves, randomSeed, stitch, fractalNoise, channelOptions, grayScale, offsets);				this.DP.mapBitmap = this.perlin_bmd;				this.DP.mapPoint = this.zeropoint;				MCClassManager.getMCClass("BasicRenderer").addEventListener("RENDER", this.updatePerlin);				 			}		}		public function updatePerlin(e:Event):void{			try{ 				this.dest_bmd.applyFilter(this.source_bmd, source_bmd.rect, this.zeropoint, this.DP);			} catch(er:Error){				trace("PerlinNoise error! "+er.message);			} 		}		public function set displacementfilter(dp:DisplacementMapFilter):void		{				this.DP.componentX = dp.componentX;			this.DP.componentY = dp.componentY;			this.DP.scaleX =  dp.scaleX;			this.DP.scaleY =  dp.scaleY;			this.DP.mode = dp.mode;		}		//{baseX:Number, baseY:Number, numOctaves:uint, randomSeed:int, stitch:Boolean, fractalNoise:Boolean, channelOptions:uint = 7, grayScale:Boolean = false, offsets:Array = null}		public function set noise(oNoise:Object):void		{			 	this.baseX = oNoise.baseX;			this.baseY = oNoise.baseY;			this.numOctaves = oNoise.numOctaves;			this.randomSeed = oNoise.randomSeed;			this.stitch = oNoise.stitch;			this.fractalNoise = oNoise.fractalNoise;			this.channelOptions = oNoise.channelOptions;			this.grayScale = oNoise.grayScale;			this.offsets = oNoise.offsets;			 			this.perlin_bmd.perlinNoise(oNoise.baseX, oNoise.baseY, oNoise.numOctaves, oNoise.randomSeed, oNoise.stitch, oNoise.fractalNoise, oNoise.channelOptions, oNoise.grayScale, oNoise.offsets);			 		}			}}