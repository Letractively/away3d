package away3d.core.material{    import away3d.core.*;    import away3d.core.math.*;    import away3d.core.proto.*;    import away3d.core.draw.*;    import away3d.core.render.*;    import flash.display.*;    import flash.geom.*;		import away3d.core.material.*;	    public class PointBitmapMaterial implements ITriangleMaterial, IUVMaterial    {         		public var dest_bmd:BitmapData;		public var rect:Rectangle;		private var cleaner:Object;		private var oShader:Object;                public function get width():Number        {            return this.dest_bmd.width;        }        public function get height():Number        {             return this.dest_bmd.height;        }				public function clear():void        {            this.cleaner.clear();        }				public function set size(val:int):void        {            this.oShader.size = (val<1)? 1 : val;        }				public function get size():int        {            return this.oShader.size;        }                public function PointBitmapMaterial(dest_bmd:BitmapData, color:Number, init:Object = null)        {			this.dest_bmd = dest_bmd;			this.oShader = new Object();			this.oShader.light = (!init.light)? "" : init.light;			this.oShader.offsetX = (!init.offsetX)? 0 : init.offsetX;			this.oShader.offsetY = (!init.offsetY)? 0 : init.offsetY;			this.oShader.debug = init.debug;			this.oShader.color = color;			this.oShader.colorpoint = 0xFFFFFFFF;			this.oShader.a = color >> 24 & 0xFF;			this.oShader.r = color >> 16 & 0xFF;			this.oShader.g = color >> 8 & 0xFF;			this.oShader.b = color & 0xFF;			this.oShader.size = (!init.pointsize || init.pointsize <1) ? 1 : init.pointsize;			this.rect = new Rectangle(this.oShader.offsetX-size/2, this.oShader.offsetY-size/2, size/2, size/2);			this.cleaner = new BitmapCleaner(this.dest_bmd, 0x00);        }        public function renderTriangle(tri:DrawTriangle, session:RenderSession):void        {            var mapping:Matrix = tri.texturemapping || tri.transformUV(this);			var a2:Number = tri.v1.x - tri.v0.x;            var b2:Number = tri.v1.y - tri.v0.y;            var c2:Number = tri.v2.x - tri.v0.x;            var d2:Number = tri.v2.y - tri.v0.y;			           	var matrix:Matrix = new Matrix(mapping.a*a2 + mapping.b*c2,                                            mapping.a*b2 + mapping.b*d2,                                            mapping.c*a2 + mapping.d*c2,                                            mapping.c*b2 + mapping.d*d2,                                           mapping.tx*a2 + mapping.ty*c2 + tri.v0.x,                                            mapping.tx*b2 + mapping.ty*d2 + tri.v0.y);			var colorpoint:Number = this.oShader.color; 			if(this.oShader.light != ""){				if(this.oShader.light == "flat"){					/*					// until we do not have a change event we calculate each time the normal of the face					if(tri.normal == null){						tri.normal = AmbientLight.getNormal([tri.v0, tri.v1, tri.v2]);					}					*/					this.oShader.colorpoint = AmbientLight.getPolygonColor([tri.v0, tri.v1, tri.v2], AmbientLight.lightcolor, tri.normal);										var a:Number =  this.oShader.colorpoint >> 24 & 0xFF;					var r:Number =  this.oShader.colorpoint >> 16 & 0xFF;					var g:Number =  this.oShader.colorpoint >> 8 & 0xFF;					var b:Number =  this.oShader.colorpoint & 0xFF;							colorpoint = (this.oShader.a+a)/2 << 24 | (this.oShader.r+r)/2 << 16 | (this.oShader.g+g)/2 << 8 | (this.oShader.b+b)/2;				}							} else {				try{					/*					// until we do not have a change event we calculate each time the normal of the face					if(tri.normal == null){						tri.normal = AmbientLight.getNormal([tri.v0, tri.v1, tri.v2]);					}					*/					colorpoint = AmbientLight.getPolygonColor([tri.v0, tri.v1, tri.v2], colorpoint, tri.normal);				} catch(e:Error){				}			}						if(this.oShader.size == 1){				this.dest_bmd.setPixel32(tri.v0.x+this.oShader.offsetX, tri.v0.y+this.oShader.offsetY, colorpoint);				this.dest_bmd.setPixel32(tri.v1.x+this.oShader.offsetX, tri.v1.y+this.oShader.offsetY, colorpoint);				this.dest_bmd.setPixel32(tri.v2.x+this.oShader.offsetX, tri.v2.y+this.oShader.offsetY, colorpoint);				this.cleaner.update(tri.v0.x+this.oShader.offsetX, tri.v0.y+this.oShader.offsetY, tri.v1.x+this.oShader.offsetX, tri.v1.y+this.oShader.offsetY, tri.v2.x+this.oShader.offsetX, tri.v2.y+this.oShader.offsetY);			}else{				var half:int = this.oShader.size/2;				var left = this.oShader.offsetX-(half);				var right = this.oShader.offsetY-(half);				this.dest_bmd.fillRect(new Rectangle(left+tri.v0.x, right+tri.v0.y, half, half), colorpoint);				this.dest_bmd.fillRect(new Rectangle(left+tri.v1.x, right+tri.v1.y, half, half), colorpoint);				this.dest_bmd.fillRect(new Rectangle(left+tri.v2.x, right+tri.v2.y, half, half), colorpoint);				this.cleaner.update(left+tri.v0.x+(half), right+tri.v0.y+(half),left+tri.v1.x+(half), right+tri.v1.y+(half),left+tri.v2.x+(half), right+tri.v2.y+(half))			}			        }        public function get visible():Boolean        {            return true;        }     }}