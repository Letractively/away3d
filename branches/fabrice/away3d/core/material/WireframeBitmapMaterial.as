package away3d.core.material{    import away3d.core.*;    import away3d.core.math.*;    import away3d.core.proto.*;    import away3d.core.draw.*;    import away3d.core.render.*;    import flash.display.*;    import flash.geom.*;	    public class WireframeBitmapMaterial implements ITriangleMaterial, IUVMaterial    {         		public var dest_bmd:BitmapData;		public var offsetX:Number;		public var offsetY:Number; 		private var cleaner:Object;		private var oShader:Object;		private var oColor:Object;                public function get width():Number        {            return this.dest_bmd.width;        }        public function get height():Number        {            return this.dest_bmd.height;        }                public function WireframeBitmapMaterial(dest_bmd:BitmapData, color:Number, offsetX:Number, offsetY:Number, oShader:Object = null, init:Object = null)        {			this.dest_bmd = dest_bmd;			this.offsetX=offsetX;			this.offsetY=offsetY;           // init = Init.parse(init);           // debug = init.getBoolean("debug", false);						this.oShader = oShader;			this.cleaner = new BitmapCleaner(this.dest_bmd, 0x00);			 			this.oColor = new Object();			this.oColor.color = color;			this.oColor.a = color >> 24 & 0xFF;			this.oColor.r = color >> 16 & 0xFF;			this.oColor.g = color >> 8 & 0xFF;			this.oColor.b = color & 0xFF;        }        public function renderTriangle(tri:DrawTriangle, session:RenderSession):void        {            var mapping:Matrix = tri.texturemapping || tri.transformUV(this);			var a2:Number = tri.v1.x - tri.v0.x;            var b2:Number = tri.v1.y - tri.v0.y;            var c2:Number = tri.v2.x - tri.v0.x;            var d2:Number = tri.v2.y - tri.v0.y;			           	var matrix:Matrix = new Matrix(mapping.a*a2 + mapping.b*c2,                                            mapping.a*b2 + mapping.b*d2,                                            mapping.c*a2 + mapping.d*c2,                                            mapping.c*b2 + mapping.d*d2,                                           mapping.tx*a2 + mapping.ty*c2 + tri.v0.x,                                            mapping.tx*b2 + mapping.ty*d2 + tri.v0.y);						this.cleaner.update(tri.v0.x, tri.v0.y, tri.v1.x, tri.v1.y, tri.v2.x, tri.v2.y);						var linecolor:Number = this.oColor.color; 						if(this.oShader != null){							if(oShader.method == "flat"){					 					this.oShader.colorpoint = AmbientLight.getPolygonColor([tri.v0, tri.v1, tri.v2], AmbientLight.lightcolor);					var a:Number =  oShader.colorpoint >> 24 & 0xFF;					var r:Number =  oShader.colorpoint >> 16 & 0xFF;					var g:Number =  oShader.colorpoint >> 8 & 0xFF;					var b:Number =  oShader.colorpoint & 0xFF;							linecolor = (this.oColor.a+a)/2 << 24 | (this.oColor.r+r)/2 << 16 | (this.oColor.g+g)/2 << 8 | (this.oColor.b+b)/2;									}			} else {				try{					linecolor = AmbientLight.getPolygonColor([tri.v0, tri.v1, tri.v2], linecolor);				} catch(e:Error){					linecolor = this.oColor.color;				}			}						BitmapGraphics.drawLine(this.dest_bmd,tri.v0.x+this.offsetX, tri.v0.y+this.offsetY, tri.v1.x+this.offsetX, tri.v1.y+this.offsetY, linecolor);			BitmapGraphics.drawLine(this.dest_bmd,tri.v1.x+this.offsetX, tri.v1.y+this.offsetY, tri.v2.x+this.offsetX, tri.v2.y+this.offsetY, linecolor);			BitmapGraphics.drawLine(this.dest_bmd,tri.v2.x+this.offsetX, tri.v2.y+this.offsetY, tri.v0.x+this.offsetX, tri.v0.y+this.offsetY, linecolor);        }        public function get visible():Boolean        {            return true;        }     }}