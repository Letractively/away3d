package away3d.core.material{		import away3d.core.*;    import away3d.core.math.*;    import away3d.core.scene.*;    import away3d.core.draw.*;    import away3d.core.render.*;    import away3d.core.utils.*;    import flash.display.*;    import flash.geom.*;	import away3d.core.material.*;		import away3d.core.mesh.Vertex;    public class EnviroMaterial implements ITriangleMaterial, IUVMaterial    {        public var bitmap:BitmapData;		public var enviromap:BitmapData;		public var fxbitmap:BitmapData;		public var rect:Rectangle;        public var smooth:Boolean;        public var debug:Boolean;        public var repeat:Boolean;		public var light:String;		public var aFX:Array;		public var mySprite:Sprite;				private var eTri0x:Number;		private var eTri0y:Number;		private var eTri1x:Number;		private var eTri1y:Number;		private var eTri2x:Number;		private var eTri2y:Number;				internal var mapping:Matrix;		                public function get width():Number        {            return bitmap.width;        }        public function get height():Number        {            return bitmap.height;        }				public function get ewidth():Number        {            return enviromap.width;        }        public function get eheight():Number        {            return enviromap.height;        }                public function EnviroMaterial( enviromap:BitmapData, bitmap:BitmapData = null, init:Object = null, afx:Array = null)        {            this.bitmap = bitmap;			this.enviromap = enviromap.clone();			// argb multipliers, could be set as color lightning			this.enviromap.draw(enviromap);//, null, new ColorTransform(1, 1, 1, 1)			            init = Init.parse(init);            smooth = init.getBoolean("smooth", false);            debug = init.getBoolean("debug", false);            repeat = init.getBoolean("repeat", false);			light = init.getString("light", "");			if(afx != null){				this.fxbitmap = bitmap.clone();				this.rect = new Rectangle(0,0,1,1);				this.aFX = new Array();				this.aFX = afx.concat();			}			         }        public function renderTriangle(tri:DrawTriangle, session:RenderSession):void        {			var mapping:Matrix = tri.texturemapping || tri.transformUV(this);			 			//var sprite:Sprite;			var normal:Object = null;						//in case we need to render as double face			if(this.bitmap != null){				var source:BitmapData = this.bitmap; 				//fx				if(this.aFX != null){					source = this.fxbitmap;					if(normal == null){						normal = AmbientLight.getNormal([tri.v0, tri.v1, tri.v2]);					}										var CT:ColorTransform;					if(tri.uvrect == null){						tri.transformUV(this);					}					for(var i:int = 0;i<this.aFX.length;i++){ 							this.aFX[i].apply(i,this.bitmap, source, tri.uvrect, normal, CT, mySprite); 					}				}				session.renderTriangleBitmap(source, mapping, tri.v0, tri.v1, tri.v2, false, false, session.graphics);			}						//get normals			var norm1:Number3D;			var norm2:Number3D;			var norm3:Number3D;						var facenorm:Number3D;						var norm:Number3D;						var average1:Array;			var average2:Array;			var average3:Array;						var xnorm:Number = 0;			var ynorm:Number = 0;			var znorm:Number = 0;						// see if the projection is front			var face_orientation:Boolean = this.isFront(tri.v0, tri.v1, tri.v2);						//first vertice			try{				average1 = tri.face.average01;								for(i = 0;i< average1.length;i++){					if(face_orientation){						if(average1[i].projection <= 0){							facenorm = average1[i].normal;							//facenorm = average1[i].normal.rotate(average1[i].source.sceneTransform);							xnorm += facenorm.x;							ynorm += facenorm.y;							znorm += facenorm.z;						}					} else{						if(average1[i].projection > 1){							facenorm = average1[i].normal;							//facenorm = average1[i].normal.rotate(average1[i].source.sceneTransform);							xnorm += facenorm.x;							ynorm += facenorm.y;							znorm += facenorm.z;						}					}				}								norm1 = new Number3D(xnorm/average1.length, ynorm/average1.length, znorm/average1.length);						} catch(e:Error){				norm1 = new Number3D(1,1,1);			}						//second vertice			xnorm = 0;			ynorm = 0;			znorm = 0;			try{				average2 = tri.face.average02;								for(i = 0;i< average2.length;i++){					if(face_orientation){						if(average2[i].projection <= 0){							facenorm = average2[i].normal;							//facenorm = average2[i].normal.rotate(average2[i].source.sceneTransform);							xnorm += facenorm.x;							ynorm += facenorm.y;							znorm += facenorm.z;						}					} else {						if(average2[i].projection > 1){							facenorm = average2[i].normal;							//facenorm = average2[i].normal.rotate(average2[i].source.sceneTransform);							xnorm += facenorm.x;							ynorm += facenorm.y;							znorm += facenorm.z;						}					}				}								norm2 = new Number3D(xnorm/average2.length, ynorm/average2.length, znorm/average2.length);							} catch(e:Error){				norm2 = new Number3D(1,1,1);			}									//third vertice			xnorm = 0;			ynorm = 0;			znorm = 0;			try{				average3 = tri.face.average03;				for(i = 0;i< average3.length;i++){					if(face_orientation){						if(average3[i].projection <= 0){							facenorm = average3[i].normal;							//facenorm = average3[i].normal.rotate(average3[i].source.sceneTransform);							xnorm += facenorm.x;							ynorm += facenorm.y;							znorm += facenorm.z;						}					} else {						if(average3[i].projection > 1){							facenorm = average3[i].normal;							//facenorm = average2[i].normal.rotate(average2[i].source.sceneTransform);							xnorm += facenorm.x;							ynorm += facenorm.y;							znorm += facenorm.z;						}					}				}								norm3 = new Number3D(xnorm/average3.length, ynorm/average3.length, znorm/average3.length);							} catch(e:Error){				norm3 = new Number3D(1,1,1);			}						//translate normals to uv 2D projection			eTri0x =  ewidth * ((norm1.x*.5) + .5);			eTri0y =  eheight * (1 - ((-(norm1.y)*.5) + .5));			eTri1x =  ewidth * ((norm2.x*.5) + .5);			eTri1y =  eheight * (1 - ((-(norm2.y)*.5) + .5));			eTri2x =  ewidth * ((norm3.x*.5) + .5);			eTri2y =  eheight * (1 - ((-(norm3.y)*.5) + .5));						var normalmapping:Matrix = new Matrix(eTri1x - eTri0x, eTri1y - eTri0y, eTri2x - eTri0x, eTri2y - eTri0y, eTri0x, eTri0y);            normalmapping.invert();            			session.renderTriangleBitmap(this.enviromap, normalmapping, tri.v0, tri.v1, tri.v2, false, false, session.graphics2);						// ambient light			if(light == "flat"){				var ambient:Number;				var flatlightcolor:Number;				var a:Number;				var r:Number;				var g:Number;				var b:Number;				if(mySprite == null){					mySprite = session.sprite;				}				try{					normal = AmbientLight.getNormal([tri.v0, tri.v1, tri.v2]);					flatlightcolor = AmbientLight.getPolygonColor([tri.v0, tri.v1, tri.v2], AmbientLight.lightcolor, normal);										ambient = AmbientLight.ambientvalue;					 					//a = -255 + ((flatlightcolor >> 24 & 0xFF)*2)+ambient;					r = -255 + ((flatlightcolor >> 16 & 0xFF)*2)+ambient;					g = -255 + ((flatlightcolor >> 8 & 0xFF)*2)+ambient;					b = -255 + ((flatlightcolor & 0xFF)*2)+ambient;										session.sprite.transform.colorTransform = new ColorTransform(1,1,1,1,r,g,b,1);									} catch(er:Error){					trace("bitmapMaterial Flat color error: "+er.message);				}							}						//debug = true;			if (debug){               session.renderTriangleLine(2, 0x8800FF, 1, tri.v0, tri.v1, tri.v2);			   			}        }				private function isFront(v0:ScreenVertex, v1:ScreenVertex, v2:ScreenVertex):Boolean		{			return (v2.x - v0.x)*(v2.y - v0.y) < (v1.x-v2.x)* (v1.y-v2.y)		}				private function isBack(v0:ScreenVertex, v1:ScreenVertex, v2:ScreenVertex):Boolean		{			return (v2.x - v0.x)*(v2.y - v0.y) > (v1.x-v2.x)* (v1.y-v2.y)		}         public function get visible():Boolean        {            return true;        }     }}