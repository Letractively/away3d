package away3d.core.material{		import away3d.core.*;    import away3d.core.math.*;    import away3d.core.scene.*;    import away3d.core.draw.*;    import away3d.core.render.*;    import away3d.core.utils.*;		    import flash.display.*;    import flash.geom.*;	import away3d.core.material.*;    public class EnviroMaterial implements ITriangleMaterial, IUVMaterial    {        public var bitmap:BitmapData;		public var enviromap:BitmapData;		public var fxbitmap:BitmapData;		public var rect:Rectangle;        public var smooth:Boolean;        public var debug:Boolean;        public var repeat:Boolean;		public var light:String;		public var aFX:Array;		public var mySprite:Sprite;		                public function get width():Number        {            return bitmap.width;        }        public function get height():Number        {            return bitmap.height;        }                public function EnviroMaterial(bitmap:BitmapData, enviromap:BitmapData, init:Object = null, afx:Array = null)        {            this.bitmap = bitmap;			this.enviromap = enviromap.clone();			// argb multipliers, could be set as color lightning			this.enviromap.draw(enviromap, null, new ColorTransform(1, 1, 1, 1));			            init = Init.parse(init);            smooth = init.getBoolean("smooth", false);            debug = init.getBoolean("debug", false);            repeat = init.getBoolean("repeat", false);			light = init.getString("light", "");			if(afx != null){				this.fxbitmap = bitmap.clone();				this.rect = new Rectangle(0,0,1,1);				this.aFX = new Array();				this.aFX = afx.concat();			}        }        public function renderTriangle(tri:DrawTriangle, session:RenderSession):void        {			var mapping:Matrix = tri.texturemapping || tri.transformUV(this);			var v0:ScreenVertex = tri.v0;			var v1:ScreenVertex = tri.v1;			var v2:ScreenVertex = tri.v2;						//var sprite:Sprite;			var normal:Object = null;			var source:BitmapData = this.bitmap; 			var ambient:Number;			var flatlightcolor:Number;			var a:Number;			var r:Number;			var g:Number;			var b:Number;						// ambient light			if(light == "flat"){				if(mySprite == null){					mySprite = session.sprite;				}				try{					normal = AmbientLight.getNormal([v0, v1, v2]);					flatlightcolor = AmbientLight.getPolygonColor([v0, v1, v2], AmbientLight.lightcolor, normal);					ambient = AmbientLight.ambientvalue;					a = -255 + ((flatlightcolor >> 24 & 0xFF)*2)+ambient;					r = -255 + ((flatlightcolor >> 16 & 0xFF)*2)+ambient;					g = -255 + ((flatlightcolor >> 8 & 0xFF)*2)+ambient;					b = -255 + ((flatlightcolor & 0xFF)*2)+ambient;					mySprite.transform.colorTransform = new ColorTransform(1,1,1,1,r,g,b,1);				} catch(er:Error){					trace("bitmapMaterial Flat color error: "+er.message);				}							}			//fx			if(this.aFX != null){				//sprite = session.graphics;				source = this.fxbitmap;				if(normal == null){					normal = AmbientLight.getNormal([v0, v1, v2]);				}								var CT:ColorTransform;				if(tri.uvrect == null){					tri.transformUV(this);				}				for(var i:int = 0;i<this.aFX.length;i++){						//this.aFX[i].apply(i,this.bitmap, source, tri.uvrect, normal, CT, sprite, v0.x, v0.y, v1.x, v1.y, v2.x, v2.y); 						this.aFX[i].apply(i,this.bitmap, source, tri.uvrect, normal, CT, mySprite); 				}				// sprite.x = Math.random()* 200-Math.random()* 200;			}						//renders normal texture			//trace(tri.face)						var mat = session.renderTriangleBitmap(source, mapping.a, mapping.b, mapping.c, mapping.d, mapping.tx, mapping.ty, v0.x, v0.y, v1.x, v1.y, v2.x, v2.y, smooth, repeat);			//trace(matrix);			//renders environement			var norm1:Number3D = tri.face.neighbour01.normal;			var norm2:Number3D = tri.face.neighbour12.normal;			var norm3:Number3D = tri.face.neighbour20.normal;			if(norm1 == null){				norm1 = new Number3D(1,1,1);			} else{				norm1.normalize(1);			}			if(norm2 == null){				norm2 = new Number3D(1,1,1);			} else{				norm2.normalize(1);			}			if(norm3 == null){				norm3 = new Number3D(1,1,1);			} else{				norm3.normalize(1);			}						var halfwidth = this.enviromap.width/2 ;			var halfheight = this.enviromap.height/2 ;						//here we need a camera info in order to influence the size of the lightmpap									/*			var eV1x = halfwidth * norm1.x + halfwidth;			var eV1y = halfheight * norm1.y + halfheight;			var eV2x = halfwidth * norm2.x + halfwidth;			var eV2y = halfheight * norm2.y + halfheight;			var eV3x = halfwidth * norm3.x + halfwidth;			var eV3y = halfheight * norm3.y + halfheight;			*/			 			/*			//this.drawUVTriangle(norm1.x, norm1.y, norm2.x, norm2.y, norm3.x, norm3.y, eV1x, eV1y, eV2x, eV2y, eV3x, eV3y, session.graphics2, mat);			//session.renderTriangleBitmap(this.enviromap, mapping.a, mapping.b, mapping.c, mapping.d, mapping.tx, mapping.ty, eV1x, eV1y, eV2x, eV2y, eV3x, eV3y, smooth, repeat);			//this.drawUVTriangle( mapping.a, mapping.b, mapping.c, mapping.d, mapping.tx, mapping.ty, norm1.x, norm1.y, norm2.x, norm2.y, norm3.x, norm3.y, session.graphics2, mat)									//var normal = Number3D.cross( Number3D.sub( new Number3D(v1.x,v1.y,v1.z) , new Number3D(v0.x,v0.y,v0.z) ), Number3D.sub( new Number3D(v2.x,v2.y,v2.z), new Number3D(v0.x,v0.y,v0.z) ) );			//normal.normalize();			 */			var eV1x =  halfwidth * norm1.x   + .5 ;			var eV1y =  halfheight * norm1.y + .5 ;			var eV2x =  halfwidth * norm2.x   + .5 ;			var eV2y =  halfheight * norm2.y   + .5 ;			var eV3x =  halfwidth * norm3.x   + .5 ;			var eV3y =  halfheight * norm3.y   + .5 ;						 			//http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c_Summer_03/directx/graphics/programmingguide/advancedtopics/pixelpipe/envmap/sphericalmap.asp			 this.drawUVTriangle(eV1x, eV1y, eV2x, eV2y, eV3x, eV3y, v0.x, v0.y, v1.x, v1.y, v2.x, v2.y, session.graphics2, mat); 			//session.renderTriangleBitmap(this.enviromap, eV1x, eV1y, eV2x, eV2y, eV3x, eV3y, v0.x, v0.y, v1.x, v1.y, v2.x, v2.y, smooth, repeat);						 			if (debug){                //session.renderTriangleLine(2, 0x8800FF, 1, v0.x, v0.y, v1.x, v1.y, v2.x, v2.y);				//eV1x, eV1y, eV2x, eV2y, eV3x, eV3y				var graphics:Graphics = session.graphics2;           		graphics.lineStyle(0x00FF00, 1, 1);				graphics.beginFill(0x00FF00);				graphics.moveTo(eV1x, eV1y);				graphics.lineTo(eV2x, eV2y);				graphics.lineTo(eV3x, eV3y);				graphics.lineTo(eV1x, eV1y);			}        }				function drawUVTriangle(x1:Number, y1:Number, x2:Number, y2:Number, x3:Number, y3:Number, eV1x:Number, eV1y:Number, eV2x:Number, eV2y:Number, eV3x:Number, eV3y:Number, sessiongraphic:Graphics, mat:Matrix):void		{			 			var tmp = new Matrix();			tmp.a = eV2x - eV1x;			tmp.b = eV2y - eV1y;			tmp.c = eV3x - eV1x;			tmp.d = eV3y - eV1y;			tmp.tx = eV1x;			tmp.ty = eV1y;			tmp.invert();			tmp.concat(mat);						//mat.invert();			 			sessiongraphic.beginBitmapFill(this.enviromap, mat, false, false);			//sessiongraphic.beginFill(0x00FF00);			sessiongraphic.moveTo(x1, y1);			sessiongraphic.lineTo(x2, y2);			sessiongraphic.lineTo(x3, y3);			sessiongraphic.lineTo(x1, y1);			sessiongraphic.endFill();			 					}					        public function get visible():Boolean        {            return true;        }     }}