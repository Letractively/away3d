package away3d.core.material{		import away3d.core.*;    import away3d.core.math.*;    import away3d.core.scene.*;    import away3d.core.draw.*;    import away3d.core.render.*;    import away3d.core.utils.*;    import flash.display.*;    import flash.geom.*;	import away3d.core.material.*;    public class EnviroMaterial implements ITriangleMaterial, IUVMaterial    {        public var bitmap:BitmapData;		public var enviromap:BitmapData;		public var fxbitmap:BitmapData;		public var rect:Rectangle;        public var smooth:Boolean;        public var debug:Boolean;        public var repeat:Boolean;		public var light:String;		public var aFX:Array;		public var mySprite:Sprite;				public var eTri0:ScreenVertex = new ScreenVertex();		public var eTri1:ScreenVertex = new ScreenVertex();		public var eTri2:ScreenVertex = new ScreenVertex();				internal var mapping:Matrix;		                public function get width():Number        {            return bitmap.width;        }        public function get height():Number        {            return bitmap.height;        }				public function get ewidth():Number        {            return enviromap.width;        }        public function get eheight():Number        {            return enviromap.height;        }                public function EnviroMaterial(bitmap:BitmapData, enviromap:BitmapData, init:Object = null, afx:Array = null)        {            this.bitmap = bitmap;			this.enviromap = enviromap.clone();			// argb multipliers, could be set as color lightning			this.enviromap.draw(enviromap);//, null, new ColorTransform(1, 1, 1, 1)			            init = Init.parse(init);            smooth = init.getBoolean("smooth", false);            debug = init.getBoolean("debug", false);            repeat = init.getBoolean("repeat", false);			light = init.getString("light", "");			if(afx != null){				this.fxbitmap = bitmap.clone();				this.rect = new Rectangle(0,0,1,1);				this.aFX = new Array();				this.aFX = afx.concat();			}			         }        public function renderTriangle(tri:DrawTriangle, session:RenderSession):void        {			var mapping:Matrix = tri.texturemapping || tri.transformUV(this);			 			//var sprite:Sprite;			var normal:Object = null;			var source:BitmapData = this.bitmap; 												//fx			if(this.aFX != null){				source = this.fxbitmap;				if(normal == null){					normal = AmbientLight.getNormal([tri.v0, tri.v1, tri.v2]);				}								var CT:ColorTransform;				if(tri.uvrect == null){					tri.transformUV(this);				}				for(var i:int = 0;i<this.aFX.length;i++){ 						this.aFX[i].apply(i,this.bitmap, source, tri.uvrect, normal, CT, mySprite); 				}			}						//renders normal texture			//session.renderTriangleBitmap(source, mapping, tri.v0, tri.v1, tri.v2, smooth, repeat);			//get normals			var norm1:Number3D			var norm2:Number3D			var norm3:Number3D			try{				norm1 = tri.face.neighbour01.normal;			} catch(e:Error){				//trace("neighbour 01 null");				norm1 = new Number3D(1,1,1);			}			try{				norm2 = tri.face.neighbour12.normal;			} catch(e:Error){				//trace("neighbour 12 null");				norm2 = new Number3D(1,1,1);			}			try{				norm3 = tri.face.neighbour20.normal;			} catch(e:Error){				//trace("neighbour 20 null");				norm3 = new Number3D(1,1,1);			}			//norm1.normalize(1);			//norm2.normalize(1);			//norm3.normalize(1);						// ok now we convert normal from 0 to 1, by giving 0ffset 0.5			// the idea: since we now normals, and since we know all we see equal to 1*.5 spherical representation of an image on a sphere.			// (other half is set on the non facing face)			// this gives a result from 0 to 1 similar to uv mapping system witch are also 0-1 based			// so faces are automapped 0,1 according to its onw normal.			// this function totally autonome, and the mapping is generated by geometry 			// then i do like the Drawtriangle class when converting uv (transformUV), i convert the uv 0-1 to x/y coordinates and generate a matrix			// then render normally the face...			// url on this principle			//http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c_Summer_03/directx/graphics/programmingguide/advancedtopics/pixelpipe/envmap/sphericalmap.asp						var mynormal:Number3D = getActualNormal(tri.v0, tri.v1, tri.v2);			mynormal.normalize(1);			tri.face.normal = mynormal;			//trace(mynormal)			//mynormal.normalize(1);			/*			eTri0.x =  ewidth * ((norm1.x*.5) + .5);			eTri0.y =  eheight * (1 - ((norm1.y*.5) + .5));			eTri1.x =  ewidth * ((norm2.x*.5) + .5);			eTri1.y =  eheight * (1 - ((norm2.y*.5) + .5));			eTri2.x =  ewidth * ((norm3.x*.5) + .5);			eTri2.y =  eheight * (1 - ((norm3.y*.5) + .5));						//disco ball 1			eTri0.x =  ewidth * ((((mynormal.x+norm1.x)*.5)*.5) + .5);			eTri0.y =  eheight * (1 - ((((mynormal.y+norm1.y)*.5)*.5) + .5));			eTri1.x =  ewidth * ((((mynormal.x+norm2.x)*.5)*.5) + .5);			eTri1.y =  eheight * (1 - ((((mynormal.y+norm2.y)*.5)*.5) + .5));			eTri2.x =  ewidth * ((((mynormal.x+norm3.x)*.5)*.5) + .5);			eTri2.y =  eheight * (1 - ((((mynormal.y+norm3.y)*.5)*.5) + .5));						//disco ball 1			eTri0.x =  ewidth * ((((mynormal.x+norm1.x)*.5)*.5) + .5);			eTri0.y =  eheight * ( ((((mynormal.y+norm1.y)*.5)*.5) + .5));			eTri1.x =  ewidth * ((((mynormal.x+norm2.x)*.5)*.5) + .5);			eTri1.y =  eheight * ( ((((mynormal.y+norm2.y)*.5)*.5) + .5));			eTri2.x =  ewidth * ((((mynormal.x+norm3.x)*.5)*.5) + .5);			eTri2.y =  eheight * ( ((((mynormal.y+norm3.y)*.5)*.5) + .5));			*/ 						eTri0.x =  ewidth * ((((mynormal.x+norm1.x)*.5)*.5) + .5);			eTri0.y =  eheight * ( ((((mynormal.y+norm1.y)*.5)*.5) + .5));			eTri1.x =  ewidth * ((((mynormal.x+norm2.x)*.5)*.5) + .5);			eTri1.y =  eheight * ( ((((mynormal.y+norm2.y)*.5)*.5) + .5));			eTri2.x =  ewidth * ((((mynormal.x+norm3.x)*.5)*.5) + .5);			eTri2.y =  eheight * ( ((((mynormal.y+norm3.y)*.5)*.5) + .5));						/*			eTri0.x =  ewidth * ((norm1.x*.5) + .5);			eTri0.y =  eheight * (1 - ((norm1.y*.5) + .5));			eTri1.x =  ewidth * ((norm2.x*.5) + .5);			eTri1.y =  eheight * (1 - ((norm2.y*.5) + .5));			eTri2.x =  ewidth * ((norm3.x*.5) + .5);			eTri2.y =  eheight * (1 - ((norm3.y*.5) + .5));									 			basic translation			eTri0.x =  (norm1.x*.5) + .5;			eTri0.y =  (norm1.y*.5) + .5;			eTri1.x =  (norm2.x*.5) + .5;			eTri1.y =  (norm2.y*.5) + .5;			eTri2.x =  (norm3.x*.5) + .5;			eTri2.y =  (norm3.y*.5) + .5;			*/					var normalmapping:Matrix = new Matrix(eTri1.x - eTri0.x, eTri1.y - eTri0.y, eTri2.x - eTri0.x, eTri2.y - eTri0.y, eTri0.x, eTri0.y);            normalmapping.invert();            			session.renderTriangleBitmap(this.enviromap, normalmapping, tri.v0, tri.v1, tri.v2, false, false, session.graphics2);						// ambient light			if(light == "flat"){				var ambient:Number;				var flatlightcolor:Number;				var a:Number;				var r:Number;				var g:Number;				var b:Number;				if(mySprite == null){					mySprite = session.sprite;				}				try{					normal = AmbientLight.getNormal([tri.v0, tri.v1, tri.v2]);					flatlightcolor = AmbientLight.getPolygonColor([tri.v0, tri.v1, tri.v2], AmbientLight.lightcolor, normal);										ambient = AmbientLight.ambientvalue;					 					//a = -255 + ((flatlightcolor >> 24 & 0xFF)*2)+ambient;					r = -255 + ((flatlightcolor >> 16 & 0xFF)*2)+ambient;					g = -255 + ((flatlightcolor >> 8 & 0xFF)*2)+ambient;					b = -255 + ((flatlightcolor & 0xFF)*2)+ambient;										session.sprite.transform.colorTransform = new ColorTransform(1,1,1,1,r,g,b,1);									} catch(er:Error){					trace("bitmapMaterial Flat color error: "+er.message);				}							}						//debug = true;			if (debug){               session.renderTriangleLine(2, 0x8800FF, 1, tri.v0, tri.v1, tri.v2);			   			}        }				private function getActualNormal(_v0:ScreenVertex, _v1:ScreenVertex, _v2:ScreenVertex):Number3D        {                var d1x:Number = _v1.x - _v0.x;                var d1y:Number = _v1.y - _v0.y;                var d1z:Number = _v1.z - _v0.z;                            var d2x:Number = _v2.x - _v0.x;                var d2y:Number = _v2.y - _v0.y;                var d2z:Number = _v2.z - _v0.z;                            var pa:Number = d1y*d2z - d1z*d2y;                var pb:Number = d1z*d2x - d1x*d2z;                var pc:Number = d1x*d2y - d1y*d2x;                var pdd:Number = Math.sqrt(pa*pa + pb*pb + pc*pc);                return new Number3D(pa / pdd, pb / pdd, pc / pdd);				        }				        public function get visible():Boolean        {            return true;        }     }}