package away3d.core.material{		import away3d.core.*;    import away3d.core.math.*;    import away3d.core.scene.*;    import away3d.core.draw.*;    import away3d.core.render.*;    import away3d.core.utils.*;		    import flash.display.*;    import flash.geom.*;	import away3d.core.material.*;    public class BitmapMaterial implements ITriangleMaterial, IUVMaterial    {        private var _bitmap:BitmapData;		public var fxbitmap:BitmapData;		public var rect:Rectangle;        public var smooth:Boolean;        public var debug:Boolean;        public var repeat:Boolean;		public var light:String;		public var aFX:Array;                public function get width():Number        {            return _bitmap.width;        }        public function get height():Number        {            return _bitmap.height;        }                public function get bitmap():BitmapData        {        	return _bitmap;        }                public function BitmapMaterial(bitmap:BitmapData, init:Object = null, afx:Array = null)        {            _bitmap = bitmap;            init = Init.parse(init);            smooth = init.getBoolean("smooth", false);            debug = init.getBoolean("debug", false);            repeat = init.getBoolean("repeat", false);			light = init.getString("light", "");			if(afx != null){				this.fxbitmap = _bitmap.clone();				this.rect = new Rectangle(0,0,1,1);				this.aFX = new Array();				this.aFX = afx.concat();			}        }internal var mapping:Matrix;        public function renderTriangle(tri:DrawTriangle, session:RenderSession):void        {			var mapping:Matrix = tri.texturemapping || tri.transformUV(this);			var v0:ScreenVertex = tri.v0;			var v1:ScreenVertex = tri.v1;			var v2:ScreenVertex = tri.v2;						var sprite:Sprite;			var normal:Object = null;			var source:BitmapData = _bitmap; 			var ambient:Number;			var flatlightcolor:Number;			var a:Number;			var r:Number;			var g:Number;			var b:Number;									if(sprite == null){					sprite = session.sprite;					// sprite.x = Math.random()* 200-Math.random()* 200;				  }			// ambient light			if(light == "flat"){				  				try{					normal = AmbientLight.getNormal([v0, v1, v2]);					flatlightcolor = AmbientLight.getPolygonColor([v0, v1, v2], AmbientLight.lightcolor, normal);					ambient = AmbientLight.ambientvalue;					a = -255 + ((flatlightcolor >> 24 & 0xFF)*2)+ambient;					r = -255 + ((flatlightcolor >> 16 & 0xFF)*2)+ambient;					g = -255 + ((flatlightcolor >> 8 & 0xFF)*2)+ambient;					b = -255 + ((flatlightcolor & 0xFF)*2)+ambient;					sprite.transform.colorTransform = new ColorTransform(1,1,1,1,r,g,b,1); 				} catch(er:Error){					trace("bitmapMaterial Flat color error: "+er.message);				}							}			//fx			if(this.aFX != null){				//sprite = session.graphics;				source = this.fxbitmap;				if(normal == null){					normal = AmbientLight.getNormal([v0, v1, v2]);				}								var CT:ColorTransform;				if(tri.uvrect == null){					tri.transformUV(this);				}				for(var i:int = 0;i<this.aFX.length;i++){						//this.aFX[i].apply(i,this.bitmap, source, tri.uvrect, normal, CT, sprite, v0.x, v0.y, v1.x, v1.y, v2.x, v2.y); 						this.aFX[i].apply(i,_bitmap, source, tri.uvrect, normal, CT, sprite); 				}				 			}															session.renderTriangleBitmap(source, mapping, v0, v1, v2, smooth, repeat);												if (debug){                session.renderTriangleLine(2, 0x0000FF, 1, v0, v1, v2);			}        }        public function get visible():Boolean        {            return true;        }     }}