package away3d.core.material{    import away3d.core.*;    import away3d.core.math.*;    import away3d.core.proto.*;    import away3d.core.draw.*;    import away3d.core.render.*;    import flash.display.*;    import flash.geom.*;		//added	//import flash.geom.ColorTransform;	//import flash.geom.Transform;	import away3d.core.material.*;	import flash.filters.ConvolutionFilter;	//end added    public class BitmapMaterial implements ITriangleMaterial, IUVMaterial    {        public var bitmap:BitmapData;        public var smooth:Boolean;        public var debug:Boolean;        public var repeat:Boolean;		//light		public var light:String;		//bump		public var FX:Object;                public function get width():Number        {            return bitmap.width;        }        public function get height():Number        {            return bitmap.height;        }                public function BitmapMaterial(bitmap:BitmapData, init:Object = null, oFX:Object = null)        {            this.bitmap = bitmap;                        init = Init.parse(init);            smooth = init.getBoolean("smooth", false);            debug = init.getBoolean("debug", false);            repeat = init.getBoolean("repeat", false);			light = init.getString("light", "");			FX = oFX;        }        public function renderTriangle(tri:DrawTriangle, session:RenderSession):void        {            var mapping:Matrix = tri.texturemapping || tri.transformUV(this);            var v0:Vertex2D = tri.v0;            var v1:Vertex2D = tri.v1;            var v2:Vertex2D = tri.v2;			           // var graphics:Graphics = session.graphics;		   var sprite:Sprite = session.sprite;		   var graphics:Graphics = sprite.graphics;			 			  var normal:Object = null; if(FX != null){	 /*			if(FX.type == "bump"){				normal = AmbientLight.getNormal([v0, v1, v2]);				if(!FX.CF){										//note: applyed formula on each channels					//dst (x, y) = ((src (x-1, y-1) * a0 + src(x, y-1) * a1....					//src(x, y+1) * a7 + src (x+1,y+1) * a8) / divisor) + bias															//The filter must be a 3x3 filter.					//All the filter terms must be integers between -127 and +127.					//The sum of all the filter terms must not have an absolute value greater than 127.					//If any filter term is negative, the divisor must be between 2.00001 and 256.					//If all filter terms are positive, the divisor must be between 1.1 and 256.					//The bias must be an integer.															FX.zeroPoint = new Point(0,0);					FX.CF = new ConvolutionFilter();					FX.CF.matrixX = 3;					FX.CF.matrixY = 3;					FX.CF.divisor = 1;					FX.CF.bias = 1;					FX.rect = new Rectangle(0,0,1,1);					FX.source = bitmap.clone();				}								//FX.tmprect.x = Math.min(x0,x1,x2);				//FX.tmprect.y = Math.min(y0,y1,y2);				//FX.tmprect.width = Math.max(x0,x1,x2)-this.tmprect.x;				//FX.tmprect.height = Math.max(y0,y1,y2)-this.tmprect.y;							var x:Number =  normal.x;				var y:Number =  normal.y;				FX.CF.matrix = new Array(0,-y,0,-x,0,x,0,y,0);				var dummy:BitmapData = bitmap.clone();				dummy.applyFilter(FX.bumpmap, FX.bumpmap.rect, FX.zeroPoint, FX.CF);				bitmap.copyPixels(dummy, dummy.rect, FX.zeroPoint);				 				dummy = FX.source.clone();				dummy.applyFilter(FX.source, FX.source.rect, FX.zeroPoint, FX.CF);				bitmap.copyChannel(dummy, dummy.rect, FX.zeroPoint, 1, 2);								dummy.dispose();			}			*/ }				 			if(light == "flat"){				 try{ 					var flatlightcolor:Number = AmbientLight.getPolygonColor([v0, v1, v2], AmbientLight.lightcolor, normal);					var ambient:Number = AmbientLight.ambientvalue;					 					var a:Number = -255 + ((flatlightcolor >> 24 & 0xFF)*2)+ambient;					var r:Number = -255 + ((flatlightcolor >> 16 & 0xFF)*2)+ambient;					var g:Number = -255 + ((flatlightcolor >> 8 & 0xFF)*2)+ambient;					var b:Number = -255 + ((flatlightcolor & 0xFF)*2)+ambient;					 					// sprite.transform.colorTransform = new ColorTransform(1,1,1,1,r,g,b,1); 									 } catch(er:Error){					 trace("bitmapMaterial Flat color error: "+er.message);				 }			 }			 			             RenderTriangle.renderBitmap(graphics, bitmap, mapping.a, mapping.b, mapping.c, mapping.d, mapping.tx, mapping.ty, v0.x, v0.y, v1.x, v1.y, v2.x, v2.y, smooth, repeat);						if(light == "flat"){				try{ 					sprite.transform.colorTransform = new ColorTransform(1,1,1,1,r,g,b,1); 				} catch(er:Error){					trace("bitmapMaterial Flat color error: "+er.message);				}			 }						            if (debug)            {                graphics.lineStyle(2, 0x0000FF);                graphics.moveTo(tri.v0.x, tri.v0.y);                graphics.lineTo(tri.v1.x, tri.v1.y);                graphics.lineTo(tri.v2.x, tri.v2.y);                graphics.lineTo(tri.v0.x, tri.v0.y);            }        }        public function get visible():Boolean        {            return true;        }     }}