//  XXXXXXXXXXXXXXXXXXXXXXXXXXX//  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX//  Versie 1.3 AS2, created 24 juli 2006//  Last update: update 02 april 2007// 	Class gegenrate a slider in a given scope slider//  Author: Fabrice Closier//  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXimport mx.utils.Delegate;import flash.geom.Point;//class nl.fabrice.widgets.Slider extends MovieClip {	private var slider_mc:MovieClip;	private var bar_width:Number;	private var iScale:Number;	private var caption:String;	private var iVal:Number;	private var offset:Number;	private var bField:Boolean;	private var floatingpoint:Number;	private var multiplyFactor:Number;	private var lineThickness:Number;	private var onUpdate:Function;	private var pOffsetMouse:Point;	private var updateOnscroll:Boolean;	private var axis:String;	private var linecolor:Number = 0x666666;	private var fillcolor:Number = 0xCCCCCC;	function Slider() {	}	public function setColors(oColor:Object):Void{		this.linecolor = oColor.linecolor;		this.fillcolor = oColor.fillcolor;	}	public function start(caption:String, iX:Number, iY:Number, iWidth:Number, iScale:Number, iStartVal:Number, scope:Object, callback:String, bField:Boolean, offset:Number, floatingpoint:Number, tf:TextFormat, updateOnscroll:Boolean, axis:String):Void {		this.setFloatingPoint(floatingpoint);		this.caption = (caption == undefined) ? "" : caption;		this.slider_mc = scope.createEmptyMovieClip(caption + "_mc", scope.getNextHighestDepth());		this.slider_mc._x = iX;		this.slider_mc._y = iY;		this.bar_width = iWidth;		this.iScale = iScale;		this.offset = (offset == undefined) ? 0 : offset;		this.iVal = iStartVal-this.offset;		this.bField = bField;		this.buildSlider(iStartVal-this.offset, tf);		this.onUpdate = Delegate.create(scope, scope[callback]);	}	private function buildSlider(iStartVal:Number, tf:TextFormat):Void {		var oMc:MovieClip = this.slider_mc.createEmptyMovieClip("bar_mc", 1);		this.lineThickness = 1;		oMc.lineStyle(this.lineThickness, this.linecolor);		oMc.moveTo(0, 0);		oMc.lineTo(this.bar_width, 0);		oMc = this.slider_mc.createEmptyMovieClip("button_mc", 2);		oMc.beginFill(this.fillcolor);		oMc.moveTo(0, 0);		oMc.lineTo(8, 0);		oMc.lineTo(8, 10);		oMc.lineTo(0, 10);		oMc.lineTo(0, 0);		oMc.endFill();		this.slider_mc.button_mc._x = 0;		this.slider_mc.button_mc._y = this.slider_mc.bar_mc._y - (this.slider_mc.button_mc._height / 2);		this.slider_mc.button_mc.startScroll = Delegate.create(this, this.startScroll);		this.slider_mc.button_mc.stopScroll = Delegate.create(this, this.stopScroll);		this.slider_mc.button_mc.onPress = function() {			this.startScroll();		};		this.slider_mc.button_mc.onRelease = this.slider_mc.button_mc.onReleaseOutside = function () {			this.stopScroll();		};		if (this.bField) {			this.slider_mc.createTextField("output_txt", 3, 0, 0, this.bar_width, 10);						this.slider_mc.button_mc._y += this.slider_mc.output_txt._height+10;			this.slider_mc.bar_mc._y += this.slider_mc.output_txt._height+10;						//this.slider_mc.button_mc._y + this.slider_mc.button_mc._height + 15						this.slider_mc.output_txt.autoSize = true;			if (tf == undefined) {				tf = new TextFormat();				tf.font = "Verdana";				this.slider_mc.output_txt.textColor = "0xffffff";				tf.align = "Center";			}			this.slider_mc.output_txt.selectable = false;			this.slider_mc.output_txt.setNewTextFormat(tf);		}		if (iStartVal != undefined) {			this.setSliderValue(iStartVal);		}		this.update(true);	}	private function startScroll():Void {		this.pOffsetMouse = new Point(this.slider_mc.bar_mc._xmouse-this.slider_mc.button_mc._x, this.slider_mc.bar_mc._ymouse-this.slider_mc.button_mc._y);		this["updateID"] = setInterval(this, "updateScroll", 20);	}	private function stopScroll():Void {		clearInterval(this["updateID"]);		this.update(true);	}	private function updateScroll():Void {		this.slider_mc.button_mc._x = (this.slider_mc.bar_mc._xmouse < 0) ? 0 : this.slider_mc.bar_mc._xmouse-this.pOffsetMouse.x;		this.slider_mc.button_mc._x = (this.slider_mc.button_mc._x > this.bar_width - (this.slider_mc.button_mc._width)) ? this.bar_width - (this.slider_mc.button_mc._width) : this.slider_mc.button_mc._x;		this.update(false);	}	private function update(bUpdate:Boolean):Void {		var multiplier:Number = (this.bar_width - this.slider_mc.button_mc._width) / this.iScale;		if (this.floatingpoint != undefined) {			if (floatingpoint != 0) {				this.iVal = (Math.round((this.slider_mc.button_mc._x / multiplier) * this.multiplyFactor) / this.multiplyFactor) + this.offset;			} else {				this.iVal = Math.floor(((this.slider_mc.button_mc._x) / multiplier)) + this.offset;			}		} else {			this.iVal = ((this.slider_mc.button_mc._x) / multiplier) + this.offset;		}		if (this.bField) {			this.slider_mc.output_txt.text = this.caption + " " + this.iVal;					}		if(bUpdate){			this.onUpdate(this.iVal, this.caption);		}	}	public function setFloatingPoint(floatingpoint:Number):Void {		this.floatingpoint = (floatingpoint < 0 || isNaN(floatingpoint)) ? undefined : floatingpoint;		if (this.floatingpoint != undefined && this.floatingpoint != 0) {			var strFactor:String = "1";			for (var x = 0; x < this.floatingpoint; x++) {				strFactor += "0";			}			this.multiplyFactor = Number(strFactor);		}	}	public function getFloatingPoint():Number {		return this.floatingpoint;	}	public function setOffset(val:Number):Void {		this.offset = (val != undefined && !isNaN(val)) ? val : this.offset;	}	public function getOffset():Number {		return this.offset;	}	public function getSliderValue():Number {		return this.iVal;	}	public function setSliderValue(newVal:Number, bUpdate:Boolean):Void {		var multiplier:Number = (this.bar_width - this.slider_mc.button_mc._width) / this.iScale;		this.slider_mc.button_mc._x = multiplier * newVal;		this.update(bUpdate);	}}