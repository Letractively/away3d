package away3d.animators;	import away3d.animators.data.AnimationSequence;	import away3d.core.base.*;		import flash.utils.Dictionary;	class Animator extends Mesh {		public var framelist(getFramelist, null) : Array<Dynamic>		;				var varr:Array<Dynamic> ;		var uvarr:Array<Dynamic> ;		var fnarr:Array<Dynamic> ;		 		function getVertIndex(face:Face):Array<Dynamic>		{			var a:Int = 0;			var b:Int = 0;			var c:Int = 0;						for(i in 0...varr.length){				a = (varr[i] == face.v0)? i : a;				b = (varr[i] == face.v1)? i : b;				c = (varr[i] == face.v2)? i : c;				if(a!=0 && b!= 0 && c != 0) break;			}			return [a, b, c];		}		//Array aFrames properties: vertices:Array[vertex.x,y and z positions], prefix:String		public function generate(baseObject:Mesh, aFrames:Array<Dynamic>, doloop:Bool):Void		{			var i:Int ;			var j:Int ;			var k:Int ;						// export requirement			indexes = new Array();			var aVti:Array<Dynamic>;						if(doloop){				var fr:Dynamic = new Object();				fr.vertices = aFrames[0].vertices;				fr.prefix = aFrames[0].prefix;				var pref:String = "";				for(i in 0...fr.prefix.length){					if(isNaN(fr.prefix.substring(i,i+1)) ){						pref += fr.prefix.substring(i,i+1);					} else{						break;					}				}				fr.prefix = pref+(aFrames.length+1);				aFrames.push(fr);			}						var face:Face;			varr = varr.concat(baseObject.geometry.vertices);						for(i in 0...baseObject.faces.length){				face = baseObject.faces[i];				uvarr.push(face.uv0, face.uv1, face.uv2);				addFace(face);				aVti = getVertIndex(face);				indexes.push([aVti[0],aVti[1],aVti[2],uvarr.length-3,uvarr.length-2,uvarr.length-1]);            }			 			geometry.frames = new Dictionary();			geometry.framenames = new Dictionary();			fnarr = [];			var oFrames:Dynamic = new Object();			var arr:Array<Dynamic>;						for(i in 0...aFrames.length){				oFrames[aFrames[i].prefix]=new Array();				fnarr.push(aFrames[i].prefix);				 arr = aFrames[i].vertices;				 for(j in 0...arr.length){					 oFrames[aFrames[i].prefix].push(arr[j], arr[j], arr[j]); 				 }							} 						var frame:Frame;			for(i in 0...fnarr.length){				trace("[ "+fnarr[i]+" ]");				frame = new Frame();				geometry.framenames[fnarr[i]] = i;				geometry.frames[i] = frame;				k=0;				 j = 0;				while (j < oFrames[fnarr[i]].length){					var vp:VertexPosition = new VertexPosition(varr[k]);					k++;						vp.x = oFrames[fnarr[i]][j].x;						vp.y = oFrames[fnarr[i]][j+1].y;						vp.z = oFrames[fnarr[i]][j+2].z;						frame.vertexpositions.push(vp);					j+=3;				}  								if (i == 0)					frame.adjust();			}					}				public function getFramelist():Array<Dynamic>		{			return fnarr;		}				/**		* Add new frames to the object at runtime		* 		* @paramaFrames				A multidimentional array with vertices references  [{vertices:object3d1.vertices, prefix:"frame1"}, {vertices:object3d2.vertices, prefix:"frame2"}]		* 		*/		public function addFrames(aFrames:Array<Dynamic>):Void		{			var i:Int ;			var j:Int ;			var k:Int ;			var oFrames:Dynamic = new Object();			var arr:Array<Dynamic>;						for(i in 0...aFrames.length){				oFrames[aFrames[i].prefix]=new Array();				fnarr.push(aFrames[i].prefix);				arr = aFrames[i].vertices;				for(j in 0...arr.length){					oFrames[aFrames[i].prefix].push(arr[j], arr[j], arr[j]); 				}			} 			var frame:Frame;			for(i in 0...fnarr.length){				trace("[ "+fnarr[i]+" ]");				frame = new Frame();				geometry.framenames[fnarr[i]] = i;				geometry.frames[i] = frame;				k=0;				 j = 0;				while (j < oFrames[fnarr[i]].length){					var vp:VertexPosition = new VertexPosition(varr[k]);					k++;						vp.x = oFrames[fnarr[i]][j].x;						vp.y = oFrames[fnarr[i]][j+1].y;						vp.z = oFrames[fnarr[i]][j+2].z;						frame.vertexpositions.push(vp);					j+=3;				}  								if (i == 0)					frame.adjust();			}					}				/**		 * Creates a new <code>Animator</code> object.		 * 		 * @param	baseObject			The Mesh to be used as reference		 * @paramaFrames				A multidimentional array with vertices references  [{vertices:object3d1.vertices, prefix:"frame1"}, {vertices:object3d2.vertices, prefix:"frame2"}]		 * @param	init	[optional]	An initialisation object for specifying default instance properties.		 * @param	doloop	[optional]	If the geometry needs to be shown in a loop		 * 		 */		public function new(baseObject:Mesh, aFrames:Array<Dynamic>, ?init:Dynamic = null, ?doloop:Bool = false)		{			
			varr = [];
			uvarr = [];
			fnarr = [];
			super(init);			generate(baseObject, aFrames, doloop);						type = "Animator";        	url = "Mesh";					}				/**		 * Scales the vertex positions contained within all animation frames		 * 		 * @param	scale	The scaling value		 */		public function scaleAnimation(scale:Float):Void		{			var tmpnames:Array<Dynamic> = new Array();			var i:Int = 0;			var y:Int = 0;			for (var framename:String in geometry.framenames){				tmpnames.push(framename);			}							var fr:Frame;			for (i in 0...tmpnames.length){				fr = geometry.frames[geometry.framenames[tmpnames[i]]];				for(y in 0...fr.vertexpositions.length ){					fr.vertexpositions[y].x *= scale;					fr.vertexpositions[y].y *= scale;					fr.vertexpositions[y].z *= scale;				}			}						}	}