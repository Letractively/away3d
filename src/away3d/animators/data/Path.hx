package away3d.animators.data;	import away3d.core.math.Number3D;	/**	 * Holds information about a single Path definition.	 */    class Path     {    	public var array(getArray, null) : Array<Dynamic>        ;    	public var averaged(getAveraged, null) : Bool		;    	public var length(getLength, null) : Int        ;    	public var smoothed(getSmoothed, null) : Bool		;    	/**    	 * The array that contains the path definition.    	 */            	/**    	 * The array that contains the path definition.    	 */        public var aSegments:Array<Dynamic>;				/**    	 * The worldAxis of reference    	 */		public var worldAxis:Number3D ;    			        var _smoothed:Bool;		/**    	 * returns true if the smoothPath handler is being used.    	 */		public function getSmoothed():Bool		{			return _smoothed;		}				var _averaged:Bool;		/**    	* returns true if the averagePath handler is being used.    	*/		public function getAveraged():Bool		{			return _averaged;		}		/**		 * Creates a new <code>Path</code> object.		 * 		 * @param	 aVectors		An array of a series of number3D's organized in the following fashion. [a,b,c,a,b,c etc...] a = v1, b=vc (control point), c = v2		 */        public function new(aVectors:Array<Dynamic>)        {			
			worldAxis = new Number3D(0,1,0);
			if(aVectors.length < 3)				throw new Error("Path array must contain at least 3 Number3D's");			            this.aSegments = [];			for(var i:Int = 0; i<aVectors.length; i+=3)				this.aSegments.push( new CurveSegment(aVectors[i], aVectors[i+1], aVectors[i+2]) );			         }				/**		 * adds a CurveSegment to the path		 * @see CurveSegment:		 */		public function add(cs:CurveSegment):Void        {			this.aSegments.push(cs);        }				/**		 * returns the length of the Path elements array		 * 		 * @return	an integer: the length of the Path elements array		 */		public function getLength():Int        {			return this.aSegments.length;        }				/**		 * returns the Path elements array		 * 		 * @return	an Array: the Path elements array		 */		public function getArray():Array<Dynamic>        {			return this.aSegments;        }				/**		 * removes a segment in the path according to id.		 * 		 */		public function removeSegment(index:Int):Void        {			if(index<= this.aSegments.length-2){				var nextSeg:Number3D = this.aSegments[index+1].v0;				nextSeg = this.aSegments[index].v1;			}			this.aSegments.splice(index, 1);        }				/**		 * handler will smooth the path using anchors as control vector of the CurveSegments 		 * note that this is not dynamic, the path values are overwrited		 */		public function smoothPath():Void        {			_smoothed = true;						var x:Float;			var y:Float;			var z:Float;						var seg0:Number3D;			var seg1:Number3D;						var startseg:Number3D = new Number3D(this.aSegments[0].v0.x, this.aSegments[0].v0.y, this.aSegments[0].v0.z);			var tmp:Array<Dynamic> = [];						var i:Int ;						for(i in 1...length-1)			{				seg0 = this.aSegments[i].v1;				seg1 = this.aSegments[i+1].v1;				x = (seg0.x + seg1.x) * .5;				y = (seg0.y + seg1.y) * .5;				z = (seg0.z + seg1.z) * .5;								tmp.push( startseg,  new Number3D(seg0.x, seg0.y, seg0.z), new Number3D(x, y, z));				startseg = new Number3D(x, y, z);				this.aSegments[i] = null;			}						this.aSegments[0] = null;			this.aSegments = [];						for(i = 0; i<tmp.length; i+=3)				this.aSegments.push( new CurveSegment(tmp[i], tmp[i+1], tmp[i+2]) );						tmp = null;		}				/**		 * handler will average the path using averages of the CurveSegments		 * note that this is not dynamic, the path values are overwrited		 */		public function averagePath():Void        {			_averaged = true;						var x1:Float;			var y1:Float;			var z1:Float;			var x2:Float;			var y2:Float;			var z2:Float;			for(i in 1...this.aSegments.length){								if(this.aSegments[i].v0 == null){					this.aSegments[i].v0 = new Number3D(this.aSegments[i-1].v1.x,this.aSegments[i-1].v1.y,this.aSegments[i-1].v1.z);				}								x1 = (this.aSegments[i].v0.x+this.aSegments[i].v1.x)*.5;				y1 = (this.aSegments[i].v0.y+this.aSegments[i].v1.y)*.5;				z1 = (this.aSegments[i].v0.z+this.aSegments[i].v1.z)*.5;				 				x2 = (this.aSegments[i-1].v0.x+this.aSegments[i-1].v1.x)*.5;				y2 = (this.aSegments[i-1].v0.y+this.aSegments[i-1].v1.y)*.5;				z2 = (this.aSegments[i-1].v0.z+this.aSegments[i-1].v1.z)*.5;								if(this.aSegments[i-1].v1 == null){					this.aSegments[i-1].v1 = new Number3D(x1,y1,z1);				} else{					this.aSegments[i-1].v1.x = x1;					this.aSegments[i-1].v1.y = y1;					this.aSegments[i-1].v1.z = z1;				}								if(this.aSegments[i-1].vc == null){					this.aSegments[i-1].vc = new Number3D(x2, y2, z2);				} else{					this.aSegments[i-1].vc.x = x2;					this.aSegments[i-1].vc.y = y2;					this.aSegments[i-1].vc.z = z2;				}			}			        }		    }