package away3d.extrusions;

import flash.display.BitmapData;
import flash.events.EventDispatcher;
import flash.events.Event;


class CollisionMap extends EventDispatcher  {
	public var offsetX(getOffsetX, setOffsetX) : Float;
	public var offsetY(getOffsetY, setOffsetY) : Float;
	public var factorX(getFactorX, setFactorX) : Float;
	public var factorY(getFactorY, setFactorY) : Float;
	public var source(getSource, setSource) : BitmapData;
	
	private var _detectBmd:BitmapData;
	private var _oDetect:Dynamic;
	private var _factorX:Float;
	private var _factorY:Float;
	private var _offsetX:Float;
	private var _offsetY:Float;
	

	private function fireColorEvent(eventID:String):Void {
		
		dispatchEvent(new Event(eventID));
	}

	/**
	 * Creates a new <CollisionMap>CollisionMap</code>
	 * 
	 * @param	 	sourcebmd		The bitmapdata with color regions to act as trigger.
	 * @param 	factorX			[optional]	A factor scale along the X axis
	 * @param 	factorY			[optional]	A factor scale along the Y axis
	 * 
	 * note that an offset equal to halfwidth/halfheight of the source is set per default. Because most terrains are placed centered at 0,0,0 
	 */
	public function new(sourcebmd:BitmapData, ?factorX:Float=0, ?factorY:Float=0) {
		// autogenerated
		super();
		this._oDetect = {};
		
		
		this._detectBmd = sourcebmd;
		this._factorX = factorX;
		this._factorY = factorY;
		this._offsetX = sourcebmd.rect.width * .5;
		this._offsetY = sourcebmd.rect.height * .5;
	}

	/**
	 * If at the given coordinates a color is found that matches a defined color event, the color event will be triggered.
	 * 
	 * @param 	x			X coordinate on the source bmd
	 * @param 	y			Y coordinate on the source bmd
	 *
	 * note that offsetX, offsetY, factorX, factorY are applied in this handler
	 */
	public function read(x:Float, y:Float):Void {
		
		var col:Float = x / _factorX;
		var row:Float = y / _factorY;
		col += _offsetX;
		row += _offsetY;
		var color:Float = _detectBmd.getPixel(col, row);
		if (Reflect.field(_oDetect, "_" + color) != null) {
			fireColorEvent(Reflect.field(_oDetect, "_" + color).eventID);
		}
	}

	/**
	 * If at the given coordinates a color is found that matches a defined color event, the color event will be triggered.
	 * 
	 * @param 	x			X coordinate on the source bmd
	 * @param 	y			Y coordinate on the source bmd
	 *
	 * @return		A Number, the color value at coordinates x, y
	 *
	 * note that offsetX, offsetY, factorX, factorY are applied in this handler
	 */
	public function getColorAt(x:Float, y:Float):Float {
		
		var col:Float = x / _factorX;
		var row:Float = y / _factorY;
		col += _offsetX;
		row += _offsetY;
		return _detectBmd.getPixel(col, row);
	}

	/**
	 * Defines a color event for this class
	 * 
	 * @param 	color			A color Number
	 * @param 	eventid		A string to identify that event
	 * @param 	listener		The function  that must be triggered
	 *
	 * note that offsetX, offsetY, factorX, factorY are applied in this handler
	 */
	public function setColorEvent(color:Float, eventid:String, listener:Dynamic):Void {
		
		Reflect.setField(_oDetect, "_" + color, {color:color, eventID:eventid, min:color, max:color});
		addEventListener(eventid, listener, false, 0, false);
	}

	/**
	 * getter/setter for the offsetX, offsetY
	 */
	public function setOffsetX(val:Float):Float {
		
		_offsetX = val;
		return val;
	}

	public function setOffsetY(val:Float):Float {
		
		_offsetY = val;
		return val;
	}

	public function getOffsetX():Float {
		
		return _offsetX;
	}

	public function getOffsetY():Float {
		
		return _offsetY;
	}

	/**
	 * getter/setter for the factorX, factorY
	 */
	public function setFactorX(val:Float):Float {
		
		_factorX = val;
		return val;
	}

	public function setFactorY(val:Float):Float {
		
		_factorY = val;
		return val;
	}

	public function getFactorX():Float {
		
		return _factorX;
	}

	public function getFactorY():Float {
		
		return _factorY;
	}

	/**
	 * getter/setter for source bitmapdata
	 */
	public function setSource(bmd:BitmapData):BitmapData {
		
		this._detectBmd = bmd;
		return bmd;
	}

	public function getSource():BitmapData {
		
		return this._detectBmd;
	}

}

