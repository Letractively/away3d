package away3d.extrusions;    import away3d.core.math.*;    import away3d.containers.*;    import away3d.core.base.*;    import away3d.materials.*;    import away3d.core.utils.*;	import flash.geom.Point;	class SegmentsExtrude extends Mesh {				var varr:Array<Dynamic> ;		var varr2:Array<Dynamic> ;		var uvarr:Array<Dynamic> ;				        public function new(aPoints:Dynamic, ?init:Dynamic = null)        {						
						varr = new Array();
						varr2 = new Array();
						uvarr = new Array();
						if(init.material != null) init.materials = {defaultmaterial:init.material};			if(init.material == null && init.materials != null) init.material = init.materials.defaultmaterial;						init = Init.parse(init);		 	super(init);             var axis:String = init.getString("axis", "y");            var offset:Int = init.getNumber("offset", 10);            var subdivision:Int = init.getInt("subdivision", 1, {min:1});			var thickness:Int = Math.abs(init.getNumber("thickness", 0));			var thickness_subdivision:Int = init.getInt("thickness_subdivision", 1, {min:1});			var flip:Bool = init.getBoolean("flip", false);			var scaling:Int = init.getNumber("scaling", 1);			var oMat:Dynamic = init.getObject("materials", null);			var omit:String = init.getString("omit", "");			var coverall:Bool = init.getBoolean("coverall", false);			var recenter:Bool = init.getBoolean("recenter", false);			var closepath:Bool = init.getBoolean("closepath", false);						if(closepath) omit += "left,right";						if(Std.is( aPoints[0], Array)){				//in case more extrudes are done in one mesh				for(i in 0...aPoints.length){										if(aPoints[i].length > 1){						varr = new Array();						varr2 = new Array();						uvarr = new Array();						generate(aPoints[i], oMat, axis, offset, subdivision, thickness, thickness_subdivision, scaling, omit, coverall, closepath, flip);					} else {						trace("SegmentsExtrude error: at index "+i+" , at least 2 points are required per extrude!");					}				}							}else{				if(closepath)  aPoints.push(new Number3D(aPoints[0].x, aPoints[0].y, aPoints[0].z));				if(aPoints.length > 1){            		 generate(aPoints, oMat, axis, offset, subdivision, thickness, thickness_subdivision, scaling, omit, coverall, closepath, flip);				} else {					trace("SegmentsExtrude error: at least 2 points in an array are required per extrude!");				}							}			 			if(recenter) {				applyPosition((this.minX+this.maxX)*.5, (this.minY+this.maxY)*.5, (this.minZ+this.maxZ)*.5);			} else {				var isArr:Bool = (Std.is( aPoints[0], Array));				x =  (isArr)? aPoints[0][0].x : aPoints[0].x;				y =  (isArr)? aPoints[0][0].y : aPoints[0].y;				z =  (isArr)? aPoints[0][0].z : aPoints[0].z;			}						varr = null;			varr2 = null;			uvarr = null;						type = "SegmentsExtrude";        	url = "Extrude";        }						function generate(points:Array<Dynamic>, ?oMat:Dynamic = null, ?axis:String = "y", ?origoffset:Int = 0, ?subdivision:Int = 1,  ?thickness:Int = 0, ?thickness_subdivision:Int = 1, ?scaling:Int = 1, ?omit:String = "", ?coverall:Bool = false, ?closepath:Bool = false, ?flip:Bool = false):Void		{											var i:Int;			var j:Int;			var vector:Dynamic;			var vector2:Dynamic;			var increase:Int = (subdivision == 1)? origoffset : origoffset/subdivision;			var basemaxX:Int  = points[0].x;			var baseminX:Int = points[0].x;			var basemaxY:Int = points[0].y;			var baseminY:Int = points[0].y; 			var basemaxZ:Int = points[0].z;			var baseminZ:Int = points[0].z;			 			for (i in 0...points.length) {								if(scaling != 1){					points[i].x *= scaling;					points[i].y *= scaling;					points[i].z *= scaling;				}				 				basemaxX = Math.max(points[i].x, basemaxX);				baseminX = Math.min(points[i].x, baseminX);				basemaxY = Math.max(points[i].y, basemaxY);				baseminY = Math.min(points[i].y, baseminY);				basemaxZ = Math.max(points[i].z, basemaxZ);				baseminZ = Math.min(points[i].z, baseminZ);				 			}			 			var basemax:Float;			var basemin:Float;			var offset:Int = 0;						switch(axis){				case "x":					basemax = Math.abs(basemaxX) - Math.abs(baseminX);					if(baseminZ >0 && basemaxZ >0){						basemin =  basemaxZ - baseminZ;						offset = -baseminZ;					}else if(baseminZ <0 && basemaxZ <0){						basemin =  Math.abs(baseminZ - basemaxZ);						offset = -baseminZ;					}else{											basemin =  Math.abs(basemaxZ) + Math.abs(baseminZ);						offset = Math.abs(baseminZ)+((basemaxZ<0)? -basemaxZ: 0);					}					break;									case "y":					basemax = Math.abs(basemaxY) - Math.abs(baseminY);					if(baseminX >0 && basemaxX >0){						basemin =  basemaxX - baseminX;						offset = -baseminX;					}else if(baseminX <0 && basemaxX <0){						basemin =  Math.abs(baseminX - basemaxX);						offset = -baseminX;					}else{											basemin =  Math.abs(basemaxX) + Math.abs(baseminX);						offset = Math.abs(baseminX)+((basemaxX<0)? -basemaxX: 0);					}					break;									case "z":					basemax = Math.abs(basemaxZ) - Math.abs(baseminZ);					if(baseminY >0 && basemaxY >0){						basemin =  basemaxY - baseminY;						offset = -baseminY;					}else if(baseminY <0 && basemaxY <0){						basemin =  Math.abs(baseminY - basemaxY);						offset = -baseminY; 					}else{											basemin =  Math.abs(basemaxY) + Math.abs(baseminY);						offset = Math.abs(baseminY)+((basemaxY<0)? -basemaxY: 0);					}					break;			}						var Lines:Array<Dynamic>;			var prop1:String;			var prop2:String;			var prop3:String;						var aListsides:Array<Dynamic> = ["top","bottom", "right", "left", "front", "back"];						if(thickness != 0) {								var oRenderside:Dynamic = {};				for(i in 0...aListsides.length){					oRenderside[aListsides[i]] = (omit.indexOf(aListsides[i]) == -1);				}				 				switch(axis){					case"x":						prop1 = "z";						prop2 = "y";						prop3 = "x";					break;										case"y":						prop1 = "x";						prop2 = "z";						prop3 = "y";					break;										case"z":						prop1 = "y";						prop2 = "x";						prop3 = "z";				}								Lines = buildThicknessPoints(points, thickness, prop1, prop2, closepath);				 				var oPoints:Dynamic;				var oPrevPoints:Dynamic;				var vector3:Dynamic;				var vector4:Dynamic;								for(i in 0...Lines.length){										oPoints = Lines[i];					vector = {};					vector2 = {};					 					if(i == 0){						vector[prop1] = oPoints.pt2.x.toFixed(4);						vector[prop2] = oPoints.pt2.y.toFixed(4);						vector[prop3] = points[0][prop3];						varr.push(new Vertex(vector.x,vector.y,vector.z));												vector2[prop1] = oPoints.pt1.x.toFixed(4);						vector2[prop2] = oPoints.pt1.y.toFixed(4);						vector2[prop3] = points[0][prop3];						varr2.push(new Vertex(vector2.x,vector2.y,vector2.z));						  						elevate(subdivision, axis, vector, vector2, basemin, basemax, increase);												if(Lines.length == 1) {													 	vector3 = {};							vector4 = {};														vector3[prop1] = oPoints.pt4.x.toFixed(4);							vector3[prop2] = oPoints.pt4.y.toFixed(4);							vector3[prop3] = points[0][prop3];							varr.push(new Vertex(vector3.x,vector3.y,vector3.z));														vector4[prop1] = oPoints.pt3.x.toFixed(4);							vector4[prop2] = oPoints.pt3.y.toFixed(4);							vector4[prop3] = points[0][prop3];													varr2.push(new Vertex(vector4.x,vector4.y,vector4.z));														elevate(subdivision, axis, vector3, vector4, basemin, basemax, increase);						} 						 					} else if (i == Lines.length-1) {						 						vector[prop1] = oPoints.pt2.x;						vector[prop2] = oPoints.pt2.y;						vector[prop3] = points[i][prop3];						varr.push(new Vertex(vector.x,vector.y,vector.z));												vector2[prop1] = oPoints.pt1.x;						vector2[prop2] = oPoints.pt1.y;						vector2[prop3] = points[i][prop3];						varr2.push(new Vertex(vector2.x,vector2.y,vector2.z));												elevate(subdivision, axis, vector, vector2, basemin, basemax, increase);						vector3 = {};						vector4 = {};												vector3[prop1] = oPoints.pt4.x;						vector3[prop2] = oPoints.pt4.y;						vector3[prop3] = points[i][prop3];						varr.push(new Vertex(vector3.x,vector3.y,vector3.z));												vector4[prop1] = oPoints.pt3.x;						vector4[prop2] = oPoints.pt3.y;						vector4[prop3] = points[i][prop3];						varr2.push(new Vertex(vector4.x,vector4.y,vector4.z));												elevate(subdivision, axis, vector3, vector4, basemin, basemax, increase);											 } else {						 						vector[prop1] = oPoints.pt2.x;						vector[prop2] = oPoints.pt2.y;						vector[prop3] = points[i][prop3];						varr.push(new Vertex(vector.x,vector.y,vector.z));												vector2[prop1] = oPoints.pt1.x;						vector2[prop2] = oPoints.pt1.y;						vector2[prop3] = points[i][prop3];												varr2.push(new Vertex(vector2.x,vector2.y,vector2.z));												elevate(subdivision, axis, vector, vector2, basemin, basemax, increase);											}									}			 			 			} else {			 					for (i in 0...points.length) {						vector = {x:points[i].x, y:points[i].y, z:points[i].z};						varr.push(new Vertex(vector.x,vector.y,vector.z));						switch(axis){							case "x":								uvarr.push(new UV(Math.abs(vector.z%basemin), vector.x%basemax));								break;							case "y":								uvarr.push(new UV(Math.abs(vector.x%basemin), vector.y%basemax));								break;							case "z":								uvarr.push(new UV(Math.abs(vector.y%basemin), vector.z%basemax));								break;						}								for(j in 0...subdivision){							vector[axis] += increase;							switch(axis){								case "x":									uvarr.push(new UV(Math.abs(vector.z%basemin), vector.x%basemax));									break;								case "y":									uvarr.push(new UV(Math.abs(vector.x%basemin), vector.y%basemax));									break;								case "z":									uvarr.push(new UV(Math.abs(vector.y%basemin), vector.z%basemax));									break;							}							varr.push(new Vertex(vector.x,vector.y,vector.z));						}											}								}						//axis switch for elevation			switch(axis){				case"x":					axis = "z";				break;								case"y":					axis = "x";				break;								case"z":					axis = "y";			}						var index:Int = 0;			var k:Int;			var aProps:String = ["x","y","z"];						if(thickness != 0) {				var mf:Dynamic;				var mb:Dynamic;				var mt:Dynamic;				var mbo:Dynamic;				var mr:Dynamic;				var ml:Dynamic;								if(oMat != null){					mf = (oMat.front != null)? oMat.front : null;					mb = (oMat.back != null)? oMat.back : null;					mt = (oMat.top != null)? oMat.top : null;					mbo = (oMat.bottom != null)? oMat.bottom : null;					mr = (oMat.right != null)? oMat.right : null;					ml = (oMat.left != null)? oMat.left : null;				}				 			}						var uva:UV; //downleft			var uvb:UV; //topleft			var uvc:UV; //topright			var uvd:UV; //downright						for (i in 0...points.length-1) {								var pt1:Int = ( Math.abs(points[i][axis]+offset) / basemin )/1 ;				var pt2:Int = ( Math.abs(points[i+1][axis]+offset) / basemin ) /1;								for (j in 0...subdivision) {						 						if(coverall){							uva = new UV(  pt1 , j/subdivision );							uvb = new UV(  pt1  , (j+1)/subdivision );							uvc = new UV(  pt2  , (j+1)/subdivision );							uvd = new UV(  pt2  , j/subdivision );						} else{							uva = new UV( 0 , j/subdivision );							uvb = new UV(  0  , (j+1)/subdivision );							uvc = new UV(1  , (j+1)/subdivision );							uvd = new UV(  1  , j/subdivision );						}						 						if(thickness == 0){							if(flip){								addFace(new Face(varr[(index+j) + 1],varr[index+j],varr[((index+j) + (subdivision + 2))], null, uvb, uva, uvc  ));								addFace(new Face(varr[((index+j) + (subdivision + 2))],varr[(index+j)],varr[((index+j) + (subdivision + 1))], null,  uvc, uva, uvd));							} else{								addFace(new Face(varr[index+j],varr[(index+j) + 1],varr[((index+j) + (subdivision + 2))], null, uva, uvb, uvc  ));								addFace(new Face(varr[(index+j)],varr[((index+j) + (subdivision + 2))],varr[((index+j) + (subdivision + 1))], null, uva, uvc, uvd));							}						} else {							//body side 1							var v1a:Vertex = varr[index+j];							var v1b:Vertex = varr[(index+j) + 1];							var v1c:Vertex = varr[((index+j) + (subdivision + 2))];							var v2a:Vertex = varr[(index+j)];							var v2b:Vertex = varr[((index+j) + (subdivision + 2))];							var v2c:Vertex = varr[((index+j) + (subdivision + 1))];														//body side 2							var v3a:Vertex = varr2[index+j];							var v3b:Vertex = varr2[(index+j) + 1];							var v3c:Vertex = varr2[((index+j) + (subdivision + 2))];							var v4a:Vertex = varr2[(index+j)];							var v4b:Vertex = varr2[((index+j) + (subdivision + 2))];							var v4c:Vertex = varr2[((index+j) + (subdivision + 1))];														//body + reversed uv's							if(oRenderside.front){								if(flip){									addFace(new Face(v1b, v1a, v1c, mf, new UV(1-uvb.u, uvb.v), new UV(1-uva.u, uva.v) , new UV(1-uvc.u, uvc.v) ));									addFace(new Face(v2b, v2a, v2c, mf, new UV(1-uvc.u, uvc.v), new UV(1-uva.u, uva.v) , new UV(1-uvd.u, uvd.v) ));								}else{									addFace(new Face(v1a, v1b, v1c, mf, new UV(1-uva.u, uva.v) , new UV(1-uvb.u, uvb.v), new UV(1-uvc.u, uvc.v) ));									addFace(new Face(v2a, v2b, v2c, mf, new UV(1-uva.u, uva.v) , new UV(1-uvc.u, uvc.v), new UV(1-uvd.u, uvd.v) ));								}							}														if(oRenderside.back){								if(flip){									addFace(new Face(v3b, v4c, v3a, mb, uvb, uvd, uva ));									addFace(new Face(v4b, v4c, v3b, mb, uvc, uvd, uvb ));								}else{									addFace(new Face(v4c, v3b, v3a, mb, uvd, uvb, uva ));									addFace(new Face(v4c, v4b, v3b, mb, uvd, uvc, uvb ));								}							}							//bottom							if(j == 0 && oRenderside.bottom){								addThicknessSubdivision([v2c, v1a], [v4c, v3a], thickness_subdivision, uvd.u, uvb.u, mt , flip);								}														//top							if(j == subdivision-1 && oRenderside.top){								addThicknessSubdivision([v1b, v1c], [v3b, v3c], thickness_subdivision, 1-uva.u, 1-uvc.u, mt , flip);																}									 					//left							if(i == 0 && oRenderside.left){								//addThicknessSubdivision([v3a, v1a], [v3b, v1b], thickness_subdivision, 1, 0, mt , flip);																	if(flip){  									addFace(new Face(v3b, v3a, v1b, mr, new UV(1-uvb.u, uvb.v), new UV(1-uva.u, uva.v), new UV(1-uvc.u, uvc.v) ));									addFace(new Face(v1b, v3a, v1a, mr, new UV(1-uvc.u, uvc.v), new UV(1-uva.u, uva.v), new UV(1-uvd.u, uvd.v) ));								} else {									addFace(new Face(v3a, v3b, v1b, mr, new UV(1-uva.u, uva.v), new UV(1-uvb.u, uvb.v), new UV(1-uvc.u, uvc.v) ));									addFace(new Face(v3a, v1b, v1a, mr, new UV(1-uva.u, uva.v), new UV(1-uvc.u, uvc.v), new UV(1-uvd.u, uvd.v) ));								}								 							}							 							//right 							if(i == points.length-2 && oRenderside.right){								//addThicknessSubdivision([v2c, v4c], [v2b, v3c], thickness_subdivision, 1, 0, mt , flip);																	if(flip){  									addFace(new Face(v2b, v2c, v3c, ml, new UV(1-uvb.u, uvb.v), new UV(1-uva.u, uva.v), new UV(1-uvc.u, uvc.v) ));									addFace(new Face(v3c, v2c, v4c, ml, new UV(1-uvc.u, uvc.v), new UV(1-uva.u, uva.v), new UV(1-uvd.u, uvd.v) ));								} else {									addFace(new Face(v2c, v2b, v3c, ml, new UV(1-uva.u, uva.v), new UV(1-uvb.u, uvb.v), new UV(1-uvc.u, uvc.v) ));									addFace(new Face(v2c, v3c, v4c, ml, new UV(1-uva.u, uva.v), new UV(1-uvc.u, uvc.v), new UV(1-uvd.u, uvd.v) ));								}								 							}							 						}									}								index += subdivision+1;							}		}				function addThicknessSubdivision(points1:Array<Dynamic>, points2:Array<Dynamic>, subdivision:Int, u1:Float, u2:Float, ?material:Dynamic = null, ?flip:Bool = false):Void		{						var i:Int;			var j:Int;			var stepx:Float;			var stepy:Float;			var stepz:Float;						var uva:UV; //downleft			var uvb:UV; //topleft			var uvc:UV; //topright			var uvd:UV; //downright						var va:Vertex;			var vb:Vertex;			var vc:Vertex;			var vd:Vertex;						//var u1:Number;			//var u2:Number;			var index:Int = 0;			//var bu:Number = 0;			//var bincu = 1/(points1.length-1);			var v1:Int = 0;			var v2:Int = 0;						var tmp:Array<Dynamic> = new Array();			 			for( i in 0...points1.length){				stepx = (points2[i].x - points1[i].x) / subdivision;				stepy = (points2[i].y - points1[i].y) / subdivision;				stepz = (points2[i].z - points1[i].z)  / subdivision;								for( j in 0...subdivision+1){					tmp.push( new Vertex( points1[i].x+(stepx*j) , points1[i].y+(stepy*j), points1[i].z+(stepz*j)) );				}			}									for( i in 0...points1.length-1){				//u1 = bu;				//bu += bincu;				//u2 = bu;								for( j in 0...subdivision){										v1 = j/subdivision;					v2 = (j+1)/subdivision;										uva = new UV( u1 , v1);					uvb = new UV( u1 , v2 );					uvc = new UV( u2 , v2 );					uvd = new UV( u2 , v1 );											va = tmp[index+j];					vb = tmp[(index+j) + 1];					vc = tmp[((index+j) + (subdivision + 2))];					vd = tmp[((index+j) + (subdivision + 1))];					 					if(flip){						addFace(new Face(vb,va,vc, (material == null)? null : material, uvb, uva, uvc ));						addFace(new Face(vc,va,vd, (material == null)? null : material, uvc, uva, uvd));					}else{						addFace(new Face(va,vb,vc, (material == null)? null : material, uva, uvb, uvc ));						addFace(new Face(va,vc,vd, (material == null)? null : material, uva, uvc, uvd));					}				}				index += subdivision +1;			}					}				private function elevate(subdivision, axis, vector:Object, vector2:Object, basemin:Number, basemax:Number, increase:Number):void		{						switch(axis){						case "x":							uvarr.push(new UV(Math.abs(vector.z%basemin), vector.x%basemax));							break;						case "y":							uvarr.push(new UV(Math.abs(vector.x%basemin), vector.y%basemax));							break;						case "z":							uvarr.push(new UV(Math.abs(vector.y%basemin), vector.z%basemax));							break;			}								var j:int;			for(j = 0; j < subdivision; j++){				vector[axis] += increase;				vector2[axis] += increase;				 				switch(axis){					case "x":						uvarr.push(new UV(Math.abs(vector.z%basemin), vector.x%basemax));						break;					case "y":						uvarr.push(new UV(Math.abs(vector.x%basemin), vector.y%basemax));						break;					case "z":						uvarr.push(new UV(Math.abs(vector.y%basemin), vector.z%basemax));						break;				