package away3d.materials;

import away3d.haxeutils.Error;
import flash.events.EventDispatcher;
import away3d.containers.View3D;
import flash.utils.Dictionary;
import away3d.core.light.PointLight;
import away3d.events.MaterialEvent;
import away3d.core.light.DirectionalLight;
import away3d.core.draw.ScreenVertex;
import away3d.core.base.Object3D;
import away3d.core.base.Mesh;
import away3d.core.light.LightPrimitive;
import away3d.core.utils.Init;
import away3d.core.render.AbstractRenderSession;
import flash.display.Sprite;
import away3d.core.math.Number3D;
import away3d.core.draw.DrawTriangle;
import away3d.core.light.AmbientLight;
import away3d.core.draw.DrawPrimitive;
import away3d.core.math.Matrix3D;
import flash.display.Graphics;


// use namespace arcane;

/**
 * Abstract class for materials that calculate lighting for the face's center
 * Not intended for direct use - use <code>ShadingColorMaterial</code> or <code>WhiteShadingBitmapMaterial</code>.
 */
class CenterLightingMaterial extends EventDispatcher, implements ITriangleMaterial {
	public var visible(getVisible, null) : Bool;
	
	/** @private */
	public var v0:ScreenVertex;
	/** @private */
	public var v1:ScreenVertex;
	/** @private */
	public var v2:ScreenVertex;
	/** @private */
	public var session:AbstractRenderSession;
	private var point:PointLight;
	private var directional:DirectionalLight;
	private var global:AmbientLight;
	private var focus:Float;
	private var zoom:Float;
	private var v0x:Float;
	private var v0y:Float;
	private var v0z:Float;
	private var v1x:Float;
	private var v1y:Float;
	private var v1z:Float;
	private var v2x:Float;
	private var v2y:Float;
	private var v2z:Float;
	private var d1x:Float;
	private var d1y:Float;
	private var d1z:Float;
	private var d2x:Float;
	private var d2y:Float;
	private var d2z:Float;
	private var pa:Float;
	private var pb:Float;
	private var pc:Float;
	private var pdd:Float;
	private var c0x:Float;
	private var c0y:Float;
	private var c0z:Float;
	private var kar:Float;
	private var kag:Float;
	private var kab:Float;
	private var kdr:Float;
	private var kdg:Float;
	private var kdb:Float;
	private var ksr:Float;
	private var ksg:Float;
	private var ksb:Float;
	private var red:Float;
	private var green:Float;
	private var blue:Float;
	private var dfx:Float;
	private var dfy:Float;
	private var dfz:Float;
	private var df:Float;
	private var nx:Float;
	private var ny:Float;
	private var nz:Float;
	private var fade:Float;
	private var amb:Float;
	private var nf:Float;
	private var diff:Float;
	private var rfx:Float;
	private var rfy:Float;
	private var rfz:Float;
	private var spec:Float;
	private var rf:Float;
	private var graphics:Graphics;
	private var cz:Float;
	private var cx:Float;
	private var cy:Float;
	private var ncz:Float;
	private var ncx:Float;
	private var ncy:Float;
	private var sum:Float;
	private var ffz:Float;
	private var ffx:Float;
	private var ffy:Float;
	private var fz:Float;
	private var fx:Float;
	private var fy:Float;
	private var rz:Float;
	private var rx:Float;
	private var ry:Float;
	private var draw_normal:Bool;
	private var draw_fall:Bool;
	private var draw_fall_k:Float;
	private var draw_reflect:Bool;
	private var draw_reflect_k:Float;
	private var _diffuseTransform:Matrix3D;
	private var _specularTransform:Matrix3D;
	private var _viewPosition:Number3D;
	private var _source:Mesh;
	private var _view:View3D;
	/**
	 * Instance of the Init object used to hold and parse default property values
	 * specified by the initialiser object in the 3d object constructor.
	 */
	private var ini:Init;
	/**
	 * Coefficient for ambient light level
	 */
	public var ambient_brightness:Float;
	/**
	 * Coefficient for diffuse light level
	 */
	public var diffuse_brightness:Float;
	/**
	 * Coefficient for specular light level
	 */
	public var specular_brightness:Float;
	/**
	 * Coefficient for shininess level
	 */
	public var shininess:Float;
	

	/** @private */
	private function renderTri(tri:DrawTriangle, session:AbstractRenderSession, kar:Float, kag:Float, kab:Float, kdr:Float, kdg:Float, kdb:Float, ksr:Float, ksg:Float, ksb:Float):Void {
		
		throw new Error();
	}

	/**
	 * @private
	 */
	public function new(?init:Dynamic=null) {
		// autogenerated
		super();
		this.draw_normal = false;
		this.draw_fall = false;
		this.draw_fall_k = 1;
		this.draw_reflect = false;
		this.draw_reflect_k = 1;
		this.ambient_brightness = 1;
		this.diffuse_brightness = 1;
		this.specular_brightness = 1;
		this.shininess = 20;
		
		
		ini = Init.parse(init);
		shininess = ini.getColor("shininess", 20);
	}

	/**
	 * @inheritDoc
	 */
	public function updateMaterial(source:Object3D, view:View3D):Void {
		
		for (__i in 0...source.lightarray.directionals.length) {
			directional = source.lightarray.directionals[__i];

			if (!directional.diffuseTransform[cast source] || view.scene.updatedObjects[cast source]) {
				directional.setDiffuseTransform(source);
			}
			if (!directional.specularTransform[cast source]) {
				directional.specularTransform[cast source] = new Dictionary();
			}
			if (!directional.specularTransform[cast source][cast view] || view.scene.updatedObjects[cast source] || view.updated) {
				directional.setSpecularTransform(source, view);
			}
		}

		for (__i in 0...source.lightarray.points.length) {
			point = source.lightarray.points[__i];

			if (!point.viewPositions[cast view] || view.scene.updatedObjects[cast source] || view.updated) {
				point.setViewPosition(view);
			}
		}

	}

	/**
	 * @inheritDoc
	 */
	public function renderTriangle(tri:DrawTriangle):Void {
		
		session = tri.source.session;
		v0 = tri.v0;
		v1 = tri.v1;
		v2 = tri.v2;
		focus = tri.view.camera.focus;
		zoom = tri.view.camera.zoom;
		v0x = v0.vx;
		v0y = v0.vy;
		v0z = v0.z;
		v1x = v1.vx;
		v1y = v1.vy;
		v1z = v1.z;
		v2x = v2.vx;
		v2y = v2.vy;
		v2z = v2.z;
		d1x = v1x - v0x;
		d1y = v1y - v0y;
		d1z = v1z - v0z;
		d2x = v2x - v0x;
		d2y = v2y - v0y;
		d2z = v2z - v0z;
		pa = d1y * d2z - d1z * d2y;
		pb = d1z * d2x - d1x * d2z;
		pc = d1x * d2y - d1y * d2x;
		pdd = Math.sqrt(pa * pa + pb * pb + pc * pc);
		pa /= pdd;
		pb /= pdd;
		pc /= pdd;
		c0x = (v0x + v1x + v2x) / 3;
		c0y = (v0y + v1y + v2y) / 3;
		c0z = (v0z + v1z + v2z) / 3;
		kar = kag = kab = kdr = kdg = kdb = ksr = ksg = ksb = 0;
		_source = cast(tri.source, Mesh);
		_view = tri.view;
		for (__i in 0...tri.source.lightarray.directionals.length) {
			directional = tri.source.lightarray.directionals[__i];

			_diffuseTransform = directional.diffuseTransform[cast _source];
			red = directional.red;
			green = directional.green;
			blue = directional.blue;
			dfx = _diffuseTransform.szx;
			dfy = _diffuseTransform.szy;
			dfz = _diffuseTransform.szz;
			nx = tri.faceVO.face.normal.x;
			ny = tri.faceVO.face.normal.y;
			nz = tri.faceVO.face.normal.z;
			amb = directional.ambient * ambient_brightness;
			kar += red * amb;
			kag += green * amb;
			kab += blue * amb;
			nf = dfx * nx + dfy * ny + dfz * nz;
			if (nf < 0) {
				continue;
			}
			diff = directional.diffuse * nf * diffuse_brightness;
			kdr += red * diff;
			kdg += green * diff;
			kdb += blue * diff;
			_specularTransform = directional.specularTransform[cast _source][cast _view];
			rfx = _specularTransform.szx;
			rfy = _specularTransform.szy;
			rfz = _specularTransform.szz;
			rf = rfx * nx + rfy * ny + rfz * nz;
			spec = directional.specular * Math.pow(rf, shininess) * specular_brightness;
			ksr += red * spec;
			ksg += green * spec;
			ksb += blue * spec;
		}

		for (__i in 0...tri.source.lightarray.points.length) {
			point = tri.source.lightarray.points[__i];

			red = point.red;
			green = point.green;
			blue = point.blue;
			_viewPosition = point.viewPositions[cast tri.view];
			dfx = _viewPosition.x - c0x;
			dfy = _viewPosition.y - c0y;
			dfz = _viewPosition.z - c0z;
			df = Math.sqrt(dfx * dfx + dfy * dfy + dfz * dfz);
			dfx /= df;
			dfy /= df;
			dfz /= df;
			fade = 1 / df / df;
			amb = point.ambient * fade * ambient_brightness;
			kar += red * amb;
			kag += green * amb;
			kab += blue * amb;
			nf = dfx * pa + dfy * pb + dfz * pc;
			if (nf < 0) {
				continue;
			}
			diff = point.diffuse * fade * nf * diffuse_brightness;
			kdr += red * diff;
			kdg += green * diff;
			kdb += blue * diff;
			rfz = dfz - 2 * nf * pc;
			if (rfz < 0) {
				continue;
			}
			rfx = dfx - 2 * nf * pa;
			rfy = dfy - 2 * nf * pb;
			spec = point.specular * fade * Math.pow(rfz, shininess) * specular_brightness;
			ksr += red * spec;
			ksg += green * spec;
			ksb += blue * spec;
		}

		renderTri(tri, session, kar, kag, kab, kdr, kdg, kdb, ksr, ksg, ksb);
		if (draw_fall || draw_reflect || draw_normal) {
			graphics = session.graphics;
			cz = c0z;
			cx = c0x * zoom / (1 + cz / focus);
			cy = c0y * zoom / (1 + cz / focus);
			if (draw_normal) {
				ncz = (c0z + 30 * pc);
				ncx = (c0x + 30 * pa) * zoom * focus / (focus + ncz);
				ncy = (c0y + 30 * pb) * zoom * focus / (focus + ncz);
				graphics.lineStyle(1, 0x000000, 1);
				graphics.moveTo(cx, cy);
				graphics.lineTo(ncx, ncy);
				graphics.moveTo(cx, cy);
				graphics.drawCircle(cx, cy, 2);
			}
			if (draw_fall || draw_reflect) {
				for (__i in 0...tri.source.lightarray.points.length) {
					point = tri.source.lightarray.points[__i];

					red = point.red;
					green = point.green;
					blue = point.blue;
					sum = (red + green + blue) / 0xFF;
					red /= sum;
					green /= sum;
					blue /= sum;
					dfx = _viewPosition.x - c0x;
					dfy = _viewPosition.y - c0y;
					dfz = _viewPosition.z - c0z;
					df = Math.sqrt(dfx * dfx + dfy * dfy + dfz * dfz);
					dfx /= df;
					dfy /= df;
					dfz /= df;
					nf = dfx * pa + dfy * pb + dfz * pc;
					if (nf < 0) {
						continue;
					}
					if (draw_fall) {
						ffz = (c0z + 30 * dfz * (1 - draw_fall_k));
						ffx = (c0x + 30 * dfx * (1 - draw_fall_k)) * zoom * focus / (focus + ffz);
						ffy = (c0y + 30 * dfy * (1 - draw_fall_k)) * zoom * focus / (focus + ffz);
						fz = (c0z + 30 * dfz);
						fx = (c0x + 30 * dfx) * zoom * focus / (focus + fz);
						fy = (c0y + 30 * dfy) * zoom * focus / (focus + fz);
						graphics.lineStyle(1, Std.int(red) * 0x10000 + Std.int(green) * 0x100 + Std.int(blue), 1);
						graphics.moveTo(ffx, ffy);
						graphics.lineTo(fx, fy);
						graphics.moveTo(ffx, ffy);
					}
					if (draw_reflect) {
						rfx = dfx - 2 * nf * pa;
						rfy = dfy - 2 * nf * pb;
						rfz = dfz - 2 * nf * pc;
						rz = (c0z - 30 * rfz * draw_reflect_k);
						rx = (c0x - 30 * rfx * draw_reflect_k) * zoom * focus / (focus + rz);
						ry = (c0y - 30 * rfy * draw_reflect_k) * zoom * focus / (focus + rz);
						graphics.lineStyle(1, Std.int(red * 0.5) * 0x10000 + Std.int(green * 0.5) * 0x100 + Std.int(blue * 0.5), 1);
						graphics.moveTo(cx, cy);
						graphics.lineTo(rx, ry);
						graphics.moveTo(cx, cy);
					}
				}

			}
		}
	}

	/**
	 * @private
	 */
	public function getVisible():Bool {
		
		throw new Error();
		
		// autogenerated
		return false;
	}

	/**
	 * @inheritDoc
	 */
	public function addOnMaterialUpdate(listener:Dynamic):Void {
		
		addEventListener(MaterialEvent.MATERIAL_UPDATED, listener, false, 0, true);
	}

	/**
	 * @inheritDoc
	 */
	public function removeOnMaterialUpdate(listener:Dynamic):Void {
		
		removeEventListener(MaterialEvent.MATERIAL_UPDATED, listener, false);
	}

}

