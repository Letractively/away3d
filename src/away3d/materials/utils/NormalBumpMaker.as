package away3d.materials.utils{	import away3d.core.math.Number3D;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.BitmapDataChannel;	import flash.display.BlendMode;	import flash.geom.Point;	import flash.geom.Rectangle;		/**	 * Utility class, principally to transform bump map data into normal map data. 	 *  	 * Additional function to transform a source normal map into another one for which the displacements	 * are in a different direction	 */	public class NormalBumpMaker {				public function NormalBumpMaker() {		} 		/**		 * Returns a positional vector for (ui, vi), taking into account bump map displacement.		 * Calls external function if geometrical relationship known between (ui, vi) and (x, y, z)		 */		private function getPosition(bumpMapData:BitmapData, i:int, j:int, amplitude:Number, u:Number, v:Number, geometryFunction:Function):Number3D {			var bump:Number = amplitude * getDisplacement(bumpMapData, i, j);						var position:Number3D;			if (geometryFunction != null) {				position = geometryFunction.call(this, u, v, bump);			} else {				position = new Number3D(u, v, bump);			}			return position;		}						/**		 * Converts a pixel value into a displacement between 0 and 1. Assumes greyscale data so only uses the blue channel.		 */		private function getDisplacement(bumpMapData:BitmapData, i:int, j:int):Number {			return (bumpMapData.getPixel(i, j) & 0xFF) / 255.0;		}						/**		 * Calculates normal from cross product between two vectors on the bump surface.		 * Each vector on surface calculated from two positional vectors		 */		private function calculateNormal(p1:Number3D, p2:Number3D, p3:Number3D, p4:Number3D):Number3D {			// calculate directional vectors between the points			var vu:Number3D = new Number3D();			vu.sub(p1, p2);			var vv:Number3D = new Number3D();			vv.sub(p3, p4);						// calculate normal from cross product			var normal:Number3D = new Number3D();			normal.cross(vu, vv);						return normal;		}						/**		 * Converts the calculated normal vector into RGB values and sets the pixel value. 		 * Takes into account different coordinate systems. For example "xyz" is traditional left-handed coordinate system		 * "xzy" is a righthanded coordinate system (such as in Away3D)		 * 		 * For a bump map on a plane, the first two axes are the u-v coordinates, the last being the displacement direction		 */		protected function setNormal(normalMapData:BitmapData, x:int, y:int, normal:Number3D, coordinates:String):void {			normal.normalize();						var nx:Number;			var ny:Number;			var nz:Number;						// Map normal components from [-1, 1] to [0, 255]			if (coordinates == "xyz") {				nx = (normal.x / 2) + 0.5;				ny = (normal.y / 2) + 0.5;				nz = (normal.z / 2) + 0.5;							} else if (coordinates == "xzy") {				nx = (normal.x / 2) + 0.5;				ny = (normal.z / 2) + 0.5;				nz = (normal.y / 2) + 0.5;							}						// Set components into RGB pixel values			var color:int = nx*0xFF << 16 | ny*0xFF << 8 | nz*0xFF;						normalMapData.setPixel(x, y, color);			}						/**		 * Transforms a source normal map to account for displacements in different direction.		 * For example a normal map created for "z" displacements can be converted to one with "y" displacements.		 * The direction of a particular component can also be negated.		 *		 * @param sourceData 			BitmapData. The source bitmapdata;		 * @param redSource 				[optional] uint. The uint representating the red channel. Default is BitmapDataChannel.RED.		 * @param greenSource 			[optional] uint. The uint representating the green channel. Default BitmapDataChannel.GREEN.		 * @param blueSource 			[optional] uint. The uint representating the blue channel. Default BitmapDataChannel.BLUE.		 * @param invertRed 				[optional] Boolean. If the red channel needs to be inverted. Default false.		 * @param invertGreen 			[optional] Boolean. If the green channel needs to be inverted. Default false.		 * @param invertBlue 			[optional] Boolean. If the blue channel needs to be inverted. Default false.		 *		 * @return A bitmapdata		 */		public static function convertNormalChannels(sourceData:BitmapData, redSource:uint=BitmapDataChannel.RED, greenSource:uint=BitmapDataChannel.GREEN, blueSource:uint=BitmapDataChannel.BLUE, invertRed:Boolean=false, invertGreen:Boolean=false, invertBlue:Boolean=false):BitmapData		{			var width:Number = sourceData.width;			var height:Number = sourceData.height;			var rect:Rectangle = new Rectangle(0, 0, width, height);			var point:Point = new Point(0, 0);			// Create new bitmapData for return result			var destData:BitmapData = new BitmapData(width, height, false, 0x000000);						// Create an inverted bitmap (255-value) for all channels if needed			// This is needed if we want a particular vector component to be negated			var inverseSourceData:BitmapData;			if (invertRed || invertGreen || invertBlue) {				inverseSourceData = new BitmapData(width, height, false, 0xFFFFFF);				inverseSourceData.copyPixels(sourceData, rect, point);				inverseSourceData.draw(new Bitmap(new BitmapData(width, height, false, 0x000000)), null, null, BlendMode.INVERT);			}						// Copy destination vector component to red channel, negating if necessary			if (invertRed) {				destData.copyChannel(inverseSourceData, new Rectangle(0, 0, width, height), new Point(0, 0), redSource, BitmapDataChannel.RED);			} else {				destData.copyChannel(sourceData, new Rectangle(0, 0, width, height), new Point(0, 0), redSource, BitmapDataChannel.RED);			}						// Copy destination vector component to green channel, negating if necessary			if (invertGreen) {				destData.copyChannel(inverseSourceData, new Rectangle(0, 0, width, height), new Point(0, 0), greenSource, BitmapDataChannel.GREEN);							} else {				destData.copyChannel(sourceData, new Rectangle(0, 0, width, height), new Point(0, 0), greenSource, BitmapDataChannel.GREEN);			}						// Copy destination vector component to blue channel, negating if necessary			if (invertBlue) {				destData.copyChannel(inverseSourceData, new Rectangle(0, 0, width, height), new Point(0, 0), blueSource, BitmapDataChannel.BLUE);			} else {				destData.copyChannel(sourceData, new Rectangle(0, 0, width, height), new Point(0, 0), blueSource, BitmapDataChannel.BLUE);			}			return destData;				}				/**		 * Function to convert bump map displacements into a normal map		 * 		 * Calculations are performed to calculate the vectors on the original bump map and from these the 		 * normal is obtained. 		 * 		 * Conversion utility allows for a geometrical function to map from the (u, v) coordinates of the bump map		 * to (x, y, z) coordinates of a particular model. The amplitude of the bump can also be specified with relation		 * to the maximum u and v values of the bumpmap (being equal to 1). If the bump map has repeated boundaries (for		 * example with a sphere or torus) this can be specified as well.		 * 		 * By default bump displacements are assumed to be in the "y" direction (for planes) but this can be specifying		 * a coordinate value, for example "xyz" assumes u and v are in the x and y direction, displacements in the z.		 * 		 * For example, for a sphere the geometry function would be:		 * 		 * 		public function convertToSpherical(ui:Number, vi:Number, disp:Number):Number3D {		 *			var theta:Number = ui * 2 * Math.PI;		 *			var phi:Number = vi * Math.PI;		 *			var p:Number3D = new Number3D(Math.cos(theta)*Math.sin(phi), Math.sin(theta)*Math.sin(phi), Math.cos(phi));		 *			 *			var pScaled:Number3D = new Number3D();		 *			pScaled.scale(p, 1 + disp);		 *			 *			return pScaled;		 *		}		 * 		 * The call to create a spherical normal map with bump map data having a max amplitude of 0.1, that is 		 * repeated along the u direction would be:		 * 		 * 		convertToNormal(bumpMapData, convertToSpherical, 0.1, true, false);		 *		 *		 * @param bumpMapData 			BitmapData. The bitmapdata with the bump information.		 * @param geometryFunction 		[optional] Function. The geometrical function to apply. Default null.		 * @param amplitude 					[optional] Number. The amount of amplitude. Default 0.05.		 * @param uRepeat 					[optional] Boolean. If the U coordinate should be repeated. Default false;		 * @param vRepeat 					[optional] Boolean. If the V coordinate should be repeated. Default false;		 * @param coordinates 				[optional] String. The amount of amplitude. Default "xzy";		 *		 * @return A bitmapdata		 */		public function convertToNormalMap(bumpMapData:BitmapData, geometryFunction:Function=null, amplitude:Number=0.05, uRepeat:Boolean=false, vRepeat:Boolean=false, coordinates:String="xzy"):BitmapData {						if (bumpMapData == null) {				return null;			}						var ui  :Number;			var uim1:Number;			var uip1:Number;			var vi  :Number;			var vim1:Number;			var vip1:Number;			var p_uivim1:Number3D;			var p_uivip1:Number3D;			var p_uim1vi:Number3D;			var p_uip1vi:Number3D;			var normal:Number3D;						var width:Number = bumpMapData.width;			var height:Number = bumpMapData.height;						// Create new bitmap data to store normal map			var normalMapData:BitmapData = new BitmapData(width, height, false, 0x000000);			// Copy bump map into a larger bitmap data so that we can more easily account for boundary conditions			var extendedBumpMapData:BitmapData = new BitmapData(width+2, height+2, false, 0xFFFFFF);			extendedBumpMapData.copyPixels(bumpMapData, new Rectangle(0, 0, width, height), new Point(1, 1));						// Copy the left and right edges to the opposite sides if bump map is repeated in the u direction			if (uRepeat) {				extendedBumpMapData.copyPixels(bumpMapData, new Rectangle(0, 0, 1, height), new Point(width+1, 1));				extendedBumpMapData.copyPixels(bumpMapData, new Rectangle(width-1, 0, 1, height), new Point(0, 1));							} else {				extendedBumpMapData.copyPixels(bumpMapData, new Rectangle(0, 0, 1, height), new Point(0, 1));				extendedBumpMapData.copyPixels(bumpMapData, new Rectangle(width-1, 0, 1, height), new Point(width+1, 1));			}						// Copy the top and bottom edges to the opposite sides if bump map is repeated in the v direction			if (vRepeat) {				extendedBumpMapData.copyPixels(bumpMapData, new Rectangle(0, 0, width, 1), new Point(1, height+1));				extendedBumpMapData.copyPixels(bumpMapData, new Rectangle(0, height-1, width, 1), new Point(1, 0));							} else {				extendedBumpMapData.copyPixels(bumpMapData, new Rectangle(0, 0, width, 1), new Point(1, 0));				extendedBumpMapData.copyPixels(bumpMapData, new Rectangle(0, height-1, width, 1), new Point(1, height+1));			}						// Calculate normals over entire surface			for (var i:Number = 0; i < width; i++) {								ui   = i / (width - 1);				uim1 = (i-1) / (width - 1);				uip1 = (i+1) / (width - 1);								for (var j:Number = 0; j < height; j++) {					vi   = j / (height - 1);					vim1 = (j-1) / (height - 1);					vip1 = (j+1) / (height - 1);										// Get positional vectors for points around position (ui, vi)					p_uivim1 = getPosition(extendedBumpMapData, i+1, j, amplitude, ui, vim1, geometryFunction);					p_uivip1 = getPosition(extendedBumpMapData, i+1, j+2, amplitude, ui, vip1, geometryFunction);					p_uim1vi = getPosition(extendedBumpMapData, i  , j+1, amplitude, uim1, vi, geometryFunction);					p_uip1vi = getPosition(extendedBumpMapData, i+2, j+1, amplitude, uip1, vi, geometryFunction);					// Calculate normal from positional vectors					normal = calculateNormal(p_uivip1, p_uivim1, p_uip1vi, p_uim1vi);										// set the pixel in the normal map data taking into account the coordinate systems					setNormal(normalMapData, i, j, normal, coordinates);				}							}			return normalMapData;		}							}}