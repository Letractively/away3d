package away3d.materials.shaders;	import away3d.containers.*;	import away3d.arcane;	import away3d.core.base.*;	import away3d.core.draw.*;	import away3d.core.math.*;	import away3d.core.render.*;	import away3d.core.utils.*;		import flash.display.*;	import flash.geom.*;		use namespace arcane;		/**	 * Shader class for environment lighting.	 */    class EnviroShader extends AbstractShader {        public var bitmap(getBitmap, null) : BitmapData        ;        public var height(getHeight, null) : Float        ;        public var reflectiveness(getReflectiveness, setReflectiveness) : Float;        public var width(getWidth, null) : Float        ;        /** @private */		        /** @private */		arcane var _bitmap:BitmapData;        /** @private */		arcane var _reflectiveness:Float;        /** @private */		arcane var _colorTransform:ColorTransform;        		var _width:Int;		var _height:Int;		var _halfWidth:Int;		var _halfHeight:Int;		var _enviroTransform:Matrix3D;		var _specularTransform:Matrix3D;		var _nFace:Number3D;		var _nFaceTransZ:Float;		var specVal1:Float;		var specVal2:Float;		var specVal3:Float;		var specValFace:Float;		var coeff1:Float;		var coeff2:Float;		var coeff3:Float;		var _sxx:Float;		var _sxy:Float;		var _sxz:Float;        var _syx:Float;        var _syy:Float;        var _syz:Float;        var _szx:Float;        var _szy:Float;        var _szz:Float;                        /**        * Calculates the mapping matrix required to draw the triangle texture to screen.        *         * @param	source	The source object of the material.        * @param	face	The face object of the material.        * @return			The required matrix object.        */		function getMapping(source:Mesh, face:Face):Matrix		{    		_n0 = source.geometry.getVertexNormal(face.v0);			_n1 = source.geometry.getVertexNormal(face.v1);			_n2 = source.geometry.getVertexNormal(face.v2);        				_sxx = _enviroTransform.sxx;			_sxy = _enviroTransform.sxy;			_sxz = _enviroTransform.sxz;						_syx = _enviroTransform.syx;			_syy = _enviroTransform.syy;			_syz = _enviroTransform.syz;						eTri0x = _n0.x * _sxx + _n0.y * _sxy + _n0.z * _sxz;			eTri0y = _n0.x * _syx + _n0.y * _syy + _n0.z * _syz;			eTri1x = _n1.x * _sxx + _n1.y * _sxy + _n1.z * _sxz;			eTri1y = _n1.x * _syx + _n1.y * _syy + _n1.z * _syz;			eTri2x = _n2.x * _sxx + _n2.y * _sxy + _n2.z * _sxz;			eTri2y = _n2.x * _syx + _n2.y * _syy + _n2.z * _syz;						//catch mapping where points are the same (flat surface)			if (eTri1x == eTri0x && eTri1y == eTri0y) {				eTri1x += 0.1;				eTri1y += 0.1;			}			if (eTri2x == eTri1x && eTri2y == eTri1y) {				eTri2x += 0.1;				eTri2y += 0.1;			}			if (eTri0x == eTri2x && eTri0y == eTri2y) {				eTri0x += 0.1;				eTri0y += 0.1;			}						//calulate mapping			_mapping.a = _halfWidth*(eTri1x - eTri0x);			_mapping.b = _halfHeight*(eTri1y - eTri0y);			_mapping.c = _halfWidth*(eTri2x - eTri0x);			_mapping.d = _halfHeight*(eTri2y - eTri0y);			_mapping.tx = _halfWidth*eTri0x + _halfWidth;			_mapping.ty = _halfHeight*eTri0y + _halfHeight;            _mapping.invert();                        return _mapping;		}				/**		 * @inheritDoc		 */		override function clearFaceDictionary(source:Object3D, view:View3D):Void        {        	notifyMaterialUpdate();        	        	for (_faceVO in _faceDictionary) {        		if (source == _faceVO.source && view == _faceVO.view) {	        		if (!_faceVO.cleared)	        			_faceVO.clear();	        		_faceVO.invalidated = true;	        	}        	}        }        		/**		 * @inheritDoc		 */        override function renderShader(tri:DrawTriangle):Void        {			//store a clone			if (_faceVO.cleared && !_parentFaceVO.updated) {				_faceVO.bitmap = _parentFaceVO.bitmap.clone();				_faceVO.bitmap.lock();			}						_faceVO.cleared = false;			_faceVO.updated = true;						_face = tri.face;						_mapping = getMapping(cast( tri.source, Mesh), _face);            _mapping.concat(_faceVO.invtexturemapping);            			//draw into faceBitmap			_faceVO.bitmap.draw(_bitmap, _mapping, _colorTransform, blendMode, _faceVO.bitmap.rect, smooth);        }        		/**		 * Setting for possible mapping methods.		 */		public var mode:String;                /**        * Returns the width of the bitmapData being used as the shader environment map.        */        public function getHeight():Float        {            return _bitmap.height;        }                /**        * Returns the height of the bitmapData being used as the shader environment map.        */		public function getWidth():Float        {            return _bitmap.width;        }                /**        * Returns the bitmapData object being used as the shader environment map.        */        public function getBitmap():BitmapData        {        	return _bitmap;        }						/**		 * Coefficient for the reflectiveness of the environment map.		 */        public function getReflectiveness():Float{        	return _reflectiveness;        }                public function setReflectiveness(val:Float):Float{            _reflectiveness = val;            _colorTransform = new ColorTransform(1, 1, 1, _reflectiveness, 0, 0, 0, 0);        	return val;           }				/**		 * Creates a new <code>EnviroShader</code> object.		 * 		 * @param	bitmap			The bitmapData object to be used as the material's environment map.		 * @param	init	[optional]	An initialisation object for specifying default instance properties.		 */        public function new(bitmap:BitmapData, ?init:Dynamic = null)        {        	super(init);        	            _bitmap = bitmap;                        mode = ini.getString("mode", "linear");            reflectiveness = ini.getNumber("reflectiveness", 0.5, {min:0, max:1});                    	_width = _bitmap.width;        	_height = _bitmap.height;			                        _halfWidth = _width/2;            _halfHeight = _height/2;        }        		/**		 * @inheritDoc		 */		public override function updateMaterial(source:Object3D, view:View3D):Void        {        	clearShapeDictionary();        	        	_enviroTransform = view.camera.viewTransforms[source];        	        	if (view.scene.updatedObjects[source] || view.updated)        		clearFaceDictionary(source, view);        }        		/**		 * @inheritDoc		 */        public override function renderLayer(tri:DrawTriangle, layer:Sprite, level:Int):Void        {        	super.renderLayer(tri, layer, level);			    		_shape = getShape(layer);        	_shape.blendMode = blendMode;        	_shape.transform.colorTransform = _colorTransform;    					_source.session.renderTriangleBitmap(_bitmap, getMapping(_source, _face), tri.v0, tri.v1, tri.v2, smooth, false, _shape.graphics);						if (debug)                _source.session.renderTriangleLine(0, 0x0000FF, 1, tri.v0, tri.v1, tri.v2);        }    }