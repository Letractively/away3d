package away3d.core.render;

import away3d.haxeutils.Error;
import away3d.containers.View3D;
import flash.geom.Matrix;
import flash.utils.Dictionary;
import flash.display.BitmapData;
import flash.display.BlendMode;
import flash.display.Bitmap;
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.display.Shape;
import flash.display.Graphics;


// use namespace arcane;

/**
 * Drawing session object that renders all drawing primitives into a <code>Bitmap</code> container.
 */
class BitmapRenderSession extends AbstractRenderSession  {
	
	private var _container:Sprite;
	private var _bitmapContainer:Bitmap;
	private var _bitmapContainers:Dictionary;
	private var _width:Int;
	private var _height:Int;
	private var _bitmapwidth:Int;
	private var _bitmapheight:Int;
	private var _scale:Float;
	private var _cm:Matrix;
	private var _cx:Float;
	private var _cy:Float;
	private var _base:BitmapData;
	private var mStore:Array<Dynamic>;
	private var mActive:Array<Dynamic>;
	private var layers:Array<Dynamic>;
	private var layer:DisplayObject;
	

	/**
	 * Creates a new <code>BitmapRenderSession</code> object.
	 *
	 * @param	scale	[optional]	Defines the scale of the pixel resolution in base pixels. Default value is 2.
	 */
	public function new(?scale:Float=2) {
		// autogenerated
		super();
		this._bitmapContainers = new Dictionary(true);
		this.mStore = new Array<Dynamic>();
		this.mActive = new Array<Dynamic>();
		this.layers = [];
		
		
		if (_scale <= 0) {
			throw new Error("scale cannot be negative or zero");
		}
		_scale = scale;
	}

	/**
	 * @inheritDoc
	 */
	public override function getContainer(view:View3D):DisplayObject {
		
		_bitmapContainer = getBitmapContainer(view);
		if (_containers[untyped view] == null) {
			_container = _containers[untyped view] = new Sprite();
			_container.addChild(_bitmapContainer);
			return _container;
		}
		return _containers[untyped view];
	}

	public function getBitmapContainer(view:View3D):Bitmap {
		
		if (_bitmapContainers[untyped view] == null) {
			return _bitmapContainers[untyped view] = new Bitmap();
		}
		return _bitmapContainers[untyped view];
	}

	/**
	 * Returns a bitmapData object containing the rendered view.
	 * 
	 * @param	view	The view object being rendered.
	 * @return			The bitmapData object.
	 */
	public function getBitmapData(view:View3D):BitmapData {
		
		_container = cast(getContainer(view), Sprite);
		if (_bitmapContainer.bitmapData == null) {
			_bitmapwidth = Std.int((_width = Std.int(view.screenClipping.maxX - view.screenClipping.minX)) / _scale);
			_bitmapheight = Std.int((_height = Std.int(view.screenClipping.maxY - view.screenClipping.minY)) / _scale);
			return _bitmapContainer.bitmapData = new BitmapData(_bitmapwidth, _bitmapheight, true, 0);
		}
		return _bitmapContainer.bitmapData;
	}

	/**
	 * @inheritDoc
	 */
	public override function addDisplayObject(child:DisplayObject):Void {
		//add child to layers
		
		layers.push(child);
		child.visible = true;
		//add child to children
		children[untyped child] = child;
		_layerDirty = true;
	}

	/**
	 * @inheritDoc
	 */
	public override function addLayerObject(child:Sprite):Void {
		//add child to layers
		
		layers.push(child);
		child.visible = true;
		//add child to children
		children[untyped child] = child;
		newLayer = child;
	}

	/**
	 * @inheritDoc
	 */
	private override function createLayer():Void {
		//create new canvas for remaining triangles
		
		if ((_doStore.length > 0)) {
			_shape = _doStore.pop();
		} else {
			_shape = new Shape();
		}
		//update graphics reference
		graphics = _shape.graphics;
		//store new canvas
		_doActive.push(_shape);
		//add new canvas to layers
		layers.push(_shape);
		_layerDirty = false;
	}

	/**
	 * @inheritDoc
	 */
	public override function clear(view:View3D):Void {
		
		super.clear(view);
		if (updated) {
			_base = getBitmapData(view);
			_cx = _bitmapContainer.x = view.screenClipping.minX;
			_cy = _bitmapContainer.y = view.screenClipping.minY;
			_bitmapContainer.scaleX = _scale;
			_bitmapContainer.scaleY = _scale;
			_cm = new Matrix();
			_cm.scale(1 / _scale, 1 / _scale);
			_cm.translate(-view.screenClipping.minX / _scale, -view.screenClipping.minY / _scale);
			//clear base canvas
			_base.lock();
			_base.fillRect(_base.rect, 0);
			//remove all children
			children = new Dictionary(true);
			newLayer = null;
			//remove all layers
			layers = [];
			_layerDirty = true;
		}
		if (((filters != null) && (filters.length > 0)) || ((_bitmapContainer.filters != null) && (_bitmapContainer.filters.length > 0))) {
			_bitmapContainer.filters = filters;
		}
		_bitmapContainer.alpha = (alpha > 0) ? alpha : 1;
		_bitmapContainer.blendMode = (blendMode != null) ? blendMode : BlendMode.NORMAL;
	}

	/**
	 * @inheritDoc
	 */
	public override function render(view:View3D):Void {
		
		super.render(view);
		if (updated) {
			for (__i in 0...layers.length) {
				layer = layers[__i];

				if (layer != null) {
					_base.draw(layer, _cm, layer.transform.colorTransform, layer.blendMode, _base.rect);
				}
			}

			_base.unlock();
		}
	}

	/**
	 * @inheritDoc
	 */
	public override function clone():AbstractRenderSession {
		
		return new BitmapRenderSession(_scale);
	}

}

