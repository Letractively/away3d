package away3d.core.render;

import flash.events.EventDispatcher;
import away3d.containers.View3D;
import flash.utils.Dictionary;
import flash.events.Event;
import flash.geom.Rectangle;
import away3d.core.clip.Clipping;
import flash.display.BlendMode;
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.display.Shape;
import flash.display.Graphics;
import away3d.events.SessionEvent;


// use namespace arcane;

/**
 * Drawing session object that renders all drawing primitives into a <code>Sprite</code> container.
 */
class SpriteRenderSession extends AbstractRenderSession  {
	
	private var _container:Sprite;
	private var _clip:Clipping;
	public var cacheAsBitmap:Bool;
	

	private override function onSessionUpdate(event:SessionEvent):Void {
		
		super.onSessionUpdate(event);
		cacheAsBitmap = false;
	}

	/**
	 * Creates a new <code>SpriteRenderSession</code> object.
	 */
	public function new():Void {
		// autogenerated
		super();
		
		
	}

	/**
	 * @inheritDoc
	 */
	public override function getContainer(view:View3D):DisplayObject {
		
		if (_containers[untyped view] == null) {
			return _containers[untyped view] = new Sprite();
		}
		return _containers[untyped view];
	}

	/**
	 * @inheritDoc
	 */
	public override function addDisplayObject(child:DisplayObject):Void {
		//add to container
		
		_container.addChild(child);
		child.visible = true;
		//add child to children
		children[untyped child] = child;
		_layerDirty = true;
	}

	/**
	 * @inheritDoc
	 */
	public override function addLayerObject(child:Sprite):Void {
		//add to container
		
		_container.addChild(child);
		child.visible = true;
		//add child to children
		children[untyped child] = child;
		newLayer = child;
	}

	/**
	 * @inheritDoc
	 */
	private override function createLayer():Void {
		//create new canvas for remaining triangles
		
		if ((_doStore.length > 0)) {
			_shape = _doStore.pop();
		} else {
			_shape = new Shape();
		}
		//update graphics reference
		graphics = _shape.graphics;
		//store new canvas
		_doActive.push(_shape);
		//add new canvas to base canvas
		_container.addChild(_shape);
		_layerDirty = false;
	}

	/**
	 * @inheritDoc
	 */
	public override function clear(view:View3D):Void {
		
		super.clear(view);
		_container = cast(getContainer(view), Sprite);
		if (updated) {
			graphics = _container.graphics;
			//clip the edges of the root container with  scrollRect
			if (this == view.session) {
				_clip = view.screenClipping;
				_container.scrollRect = new Rectangle(_clip.minX - 1, _clip.minY - 1, _clip.maxX - _clip.minX + 2, _clip.maxY - _clip.minY + 2);
				_container.x = _clip.minX - 1;
				_container.y = _clip.minY - 1;
			}
			_container.cacheAsBitmap = false;
			//clear base canvas
			graphics.clear();
			//remove all children
			i = _container.numChildren;
			while ((i-- > 0)) {
				_container.removeChild(_container.getChildAt(i));
			}

			children = new Dictionary(true);
			newLayer = null;
		} else {
			_container.cacheAsBitmap = cacheAsBitmap;
		}
		if (((filters != null) && (filters.length > 0)) || ((_container.filters != null) && (_container.filters.length > 0))) {
			_container.filters = filters;
		}
		_container.alpha = alpha;
		if (blendMode == null) {
			_container.blendMode = BlendMode.NORMAL;
		} else {
			_container.blendMode = blendMode;
		}
	}

	/**
	 * @inheritDoc
	 */
	public override function clone():AbstractRenderSession {
		
		return new SpriteRenderSession();
	}

}

