/* * Copyright 2007 (c) Gabriel Putnam * * Permission is hereby granted, free of charge, to any person * obtaining a copy of this software and associated documentation * files (the "Software"), to deal in the Software without * restriction, including without limitation the rights to use, * copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following * conditions: * * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR * OTHER DEALINGS IN THE SOFTWARE. */package away3d.primitives;	import away3d.arcane;    import away3d.core.base.*;    	use namespace arcane;	    /**    * Creates a 3d geodesic sphere primitive.    */ 	class GeodesicSphere extends AbstractPrimitive {		public var fractures(getFractures, setFractures) : Float;		public var radius(getRadius, setRadius) : Float;				var _radius:Float;		var _fractures:Float;				function buildGeodesicSphere( radius_in:Float, fractures_in:Int ):Void		{			// Set up variables for keeping track of the vertices, faces, and texture coords.			var aVertice:Array<Dynamic> = [];             var aUV:Array<Dynamic>  = []; 						// Set up variables for keeping track of the number of iterations and the angles			var iVerts:UInt = fractures_in + 1, jVerts:UInt;			var j:UInt, Theta:Int=0, Phi:Int=0, ThetaDel:Float, PhiDel:Float;			var cosTheta:Float, sinTheta:Float, rcosPhi:Float, rsinPhi:Float;			// Set up variables for figuring out the texture coordinates using a diamond ~equal area map projection			// This is done so that there is the minimal amount of distortion of textures around poles.			// Visually, this map projection looks like this.			/*	Phi   /\0,0				|    /  \				\/  /    \				   /      \				  /        \				 / 1,0      \0,1				 \ Theta->  /				  \        /				   \      /				    \    /					 \  /					  \/1,1			*/			var Pd4:Int = Math.PI / 4, cosPd4:Int = Math.cos(Pd4), sinPd4:Int = Math.sin(Pd4), PIInv:Int = 1/Math.PI;			var R_00:Int = cosPd4, R_01:Int = -sinPd4, R_10:Int = sinPd4, R_11:Int = cosPd4;			var Scale:Int = Math.SQRT2, uOff:Float = 0.5, vOff:Float = 0.5;			var oVtx:Vertex, UU:Float, VV:Float, u:Float, v:Float;			PhiDel = Math.PI / ( 2 * iVerts);			// Build the top vertex			aVertice.push( createVertex( 0, 0, radius_in ) );			//i++;			Phi += PhiDel;			// Build the tops worth of vertices for the sphere progressing in rings around the sphere			var i:Int;						i = 1 ;			while ( i <= iVerts){				j = 0;				jVerts = i*4;				Theta = 0;				ThetaDel = 2* Math.PI / jVerts;				rcosPhi = Math.cos( Phi ) * radius_in;				rsinPhi = Math.sin( Phi ) * radius_in;				j;									while ( j < jVerts){										UU = Theta * PIInv - 0.5;					VV = ( Phi * PIInv - 1 ) * ( 0.5 - Math.abs( UU ) );										u = ( UU * R_00 + VV * R_01 ) * Scale + uOff;					v = ( UU * R_10 + VV * R_11 ) * Scale + vOff;					cosTheta = Math.cos( Theta );					sinTheta = Math.sin( Theta );					 					aVertice.push( createVertex( cosTheta * rsinPhi, sinTheta * rsinPhi, rcosPhi ) );					aUV.push(createUV( u, v ) );					Theta += ThetaDel;					++j ;									}				Phi += PhiDel;				++i;			}			// Build the bottom worth of vertices for the sphere.			i = iVerts-1;			i;			while ( i >0){				j = 0;				jVerts = i*4;				Theta = 0;				ThetaDel = 2* Math.PI / jVerts;				rcosPhi = Math.cos( Phi ) * radius_in;				rsinPhi = Math.sin( Phi ) * radius_in;				j;				while ( j < jVerts){					cosTheta = Math.cos( Theta );					sinTheta = Math.sin( Theta );					oVtx = createVertex( cosTheta * rsinPhi, sinTheta * rsinPhi, rcosPhi );					aVertice.push( oVtx );					Theta += ThetaDel;					++j ;				}				Phi += PhiDel;				i-- ;			}						// Build the last vertice			aVertice.push( createVertex( 0, 0, -radius_in ) );			// Build the faces for the sphere			// Build the upper four sections			var k:UInt, L_Ind_s:UInt, U_Ind_s:UInt, U_Ind_e:UInt, L_Ind_e:UInt, L_Ind:UInt, U_Ind:UInt;			var isUpTri:Bool, Pt0:UInt, Pt1:UInt, Pt2:UInt, triInd:UInt, tris:UInt;			tris = 1;						var v0:Vertex;			var v1:Vertex;			var v2:Vertex;			var uv0:Vertex;			var uv1:Vertex;						L_Ind_s = 0; L_Ind_e = 0;			for( i in 0...iVerts){				U_Ind_s = L_Ind_s;				U_Ind_e = L_Ind_e;				if( i == 0 ) L_Ind_s++;				L_Ind_s += 4*i;				L_Ind_e += 4*(i+1);				U_Ind = U_Ind_s;				L_Ind = L_Ind_s;				for( k in 0...4){					isUpTri = true;					for( triInd in 0...tris){						if( isUpTri ){							Pt0 = U_Ind;							Pt1 = L_Ind;							L_Ind++;							if( L_Ind > L_Ind_e ) L_Ind = L_Ind_s;							Pt2 = L_Ind;							isUpTri = false;						} else {							Pt0 = L_Ind;							Pt2 = U_Ind;							U_Ind++;							if( U_Ind > U_Ind_e ) U_Ind = U_Ind_s;							Pt1 = U_Ind;							isUpTri = true;						}						addFace( createFace( aVertice[Pt1],aVertice[Pt0], aVertice[Pt2] , null,  aUV[Pt1],aUV[Pt0],aUV[Pt2] ) );											}				}				tris += 2;			}			U_Ind_s = L_Ind_s; U_Ind_e = L_Ind_e;			// Build the lower four sections			 			i = iVerts-1;			while ( i >= 0){				L_Ind_s = U_Ind_s; L_Ind_e = U_Ind_e; U_Ind_s = L_Ind_s + 4*(i+1); U_Ind_e = L_Ind_e + 4*i;				if( i == 0 ) U_Ind_e++;				tris -= 2;				U_Ind = U_Ind_s;				L_Ind = L_Ind_s;				for( k in 0...4){					isUpTri = true;					for( triInd in 0...tris){						if( isUpTri ){							Pt0 = U_Ind;							Pt1 = L_Ind;							L_Ind++;							if( L_Ind > L_Ind_e ) L_Ind = L_Ind_s;							Pt2 = L_Ind;							isUpTri = false;						} else {							Pt0 = L_Ind;							Pt2 = U_Ind;							U_Ind++;							if( U_Ind > U_Ind_e ) U_Ind = U_Ind_s;							Pt1 = U_Ind;							isUpTri = true;						}						addFace( createFace( aVertice[Pt2],aVertice[Pt0],aVertice[Pt1] , null, aUV[Pt2],aUV[Pt0],aUV[Pt1] ) );					}				}				i-- ;			}		}		    	/**    	 * Defines the radius of the sphere. Defaults to 100.    	 */    	public function getRadius():Float{    		return _radius;    	}    	    	public function setRadius(val:Float):Float{    		if (_radius == val)    			return;    		    		_radius = val;    		_primitiveDirty = true;    		return val;    	}    	    	/**    	 * Defines the fractures of the sphere. Defaults to 2.    	 */    	public function getFractures():Float{    		return _fractures;    	}    	    	public function setFractures(val:Float):Float{    		if (_fractures == val)    			return;    		    		_fractures = val;    		_primitiveDirty = true;    		return val;    	}				/**		 * Creates a new <code>GeodesicSphere</code> object.		 *		 * @param	init			[optional]	An initialisation object for specifying default instance properties.		 */		public function new( ?init:Dynamic = null)        {            super(init);            			_radius = ini.getNumber("radius", 100, {min:100});            _fractures = ini.getInt("fractures", 2, {min:2});			 			buildGeodesicSphere(_radius, _fractures);						type = "GeoSphere";        	url = "primitive"; 		}		    		/**		 * @inheritDoc		 */    	public override function buildPrimitive():Void    	{    		super.buildPrimitive();    		            buildGeodesicSphere(_radius, _fractures);    	}	}