package away3d.primitives;	import away3d.arcane;    import away3d.core.base.*;    import away3d.core.math.*;    import away3d.core.utils.*;    	use namespace arcane;	    /**    * Creates a regular polygon.    */     class RegularPolygon extends AbstractPrimitive {        public var radius(getRadius, setRadius) : Float;        public var sides(getSides, setSides) : Float;        public var subdivision(getSubdivision, setSubdivision) : Float;        public var yUp(getYUp, setYUp) : Bool;                var _radius:Float;        var _sides:Float;        var _subdivision:Float;        var _yUp:Bool;    	        function buildRegularPolygon(radius:Float, sides:Int, subdivision:Int, yUp:Bool):Void        {			var tmpPoints:Array<Dynamic> = new Array();			var i:Int = 0;			var j:Int = 0;						var innerstep:Int = radius/subdivision;						var radstep:Int = 360/sides;			var ang:Int = 0;			var ang_inc:Int = radstep;						var uva:UV;			var uvb:UV;			var uvc:UV;			var uvd:UV;											var facea:Vertex;			var faceb:Vertex;			var facec:Vertex;			var faced:Vertex;						i;			while (i <= subdivision) {				tmpPoints.push(new Number3D(i*innerstep, 0, 0));				i++;			}						var base:Number3D = new Number3D(0,0,0);			var zerouv:UV = createUV(0.5, 0.5);			 			for (i in 0...sides) {								for (j in 0...tmpPoints.length-1) {											uva = createUV( (Math.cos(-ang_inc/180*Math.PI) / ((subdivision*2)/j) ) + .5, (Math.sin(ang_inc/180*Math.PI) / ((subdivision*2)/j)) +.5 );					uvb = createUV( (Math.cos(-ang/180*Math.PI) / ((subdivision*2)/(j+1)) ) + .5, (Math.sin(ang/180*Math.PI) / ((subdivision*2)/(j+1)) ) + .5   );					uvc = createUV( (Math.cos(-ang_inc/180*Math.PI) / ((subdivision*2)/(j+1)) ) + .5, (Math.sin(ang_inc/180*Math.PI) / ((subdivision*2)/(j+1))) + .5  );					uvd = createUV( (Math.cos(-ang/180*Math.PI) / ((subdivision*2)/j)) + .5, (Math.sin(ang/180*Math.PI) / ((subdivision*2)/j) ) +.5  );					if(j==0){						if (yUp) {							facea = createVertex(base.x, base.y, base.z);							faceb = createVertex(Math.cos(-ang/180*Math.PI) *  tmpPoints[1].x, base.y, Math.sin(ang/180*Math.PI) * tmpPoints[1].x);							facec = createVertex(Math.cos(-ang_inc/180*Math.PI) *  tmpPoints[1].x, base.y, Math.sin(ang_inc/180*Math.PI) * tmpPoints[1].x);							} else {							facea = createVertex(base.x, base.y, base.z);							faceb = createVertex(Math.cos(-ang/180*Math.PI) *  tmpPoints[1].x, Math.sin(ang/180*Math.PI) * tmpPoints[1].x, base.z);							facec = createVertex(Math.cos(-ang_inc/180*Math.PI) *  tmpPoints[1].x, Math.sin(ang_inc/180*Math.PI) * tmpPoints[1].x, base.z);							}									addFace(createFace(facea, faceb, facec, null, zerouv, uvb, uvc ) );											} else {						if (yUp) {							facea = createVertex(Math.cos(-ang_inc/180*Math.PI) *  tmpPoints[j].x, base.y, Math.sin(ang_inc/180*Math.PI) * tmpPoints[j].x);							faceb = createVertex(Math.cos(-ang_inc/180*Math.PI) *  tmpPoints[j+1].x, base.y, Math.sin(ang_inc/180*Math.PI) * tmpPoints[j+1].x);							facec = createVertex(Math.cos(-ang/180*Math.PI) *  tmpPoints[j+1].x, base.y, Math.sin(ang/180*Math.PI) * tmpPoints[j+1].x);							faced = createVertex(Math.cos(-ang/180*Math.PI) *  tmpPoints[j].x, base.y, Math.sin(ang/180*Math.PI) * tmpPoints[j].x);						} else {							facea = createVertex(Math.cos(-ang_inc/180*Math.PI) *  tmpPoints[j].x, Math.sin(ang_inc/180*Math.PI) * tmpPoints[j].x, base.z);							faceb = createVertex(Math.cos(-ang_inc/180*Math.PI) *  tmpPoints[j+1].x, Math.sin(ang_inc/180*Math.PI) * tmpPoints[j+1].x, base.z);							facec = createVertex(Math.cos(-ang/180*Math.PI) *  tmpPoints[j+1].x, Math.sin(ang/180*Math.PI) * tmpPoints[j+1].x, base.z);							faced = createVertex(Math.cos(-ang/180*Math.PI) *  tmpPoints[j].x, Math.sin(ang/180*Math.PI) * tmpPoints[j].x, base.z);						}						 						addFace(createFace(facec, faceb, facea, null, uvb, uvc, uva ) );						addFace(createFace(facec, facea, faced, null, uvb, uva, uvd ) );						 					}														}								ang += radstep;				ang_inc += radstep;							}				        }            	/**    	 * Defines the radius of the polygon. Defaults to 100.    	 */    	public function getRadius():Float{    		return _radius;    	}    	    	public function setRadius(val:Float):Float{    		if (_radius == val)    			return;    		    		_radius = val;    		_primitiveDirty = true;    		return val;    	}    			    	/**    	 * Defines the number of sides of the polygon. Defaults to 8 (octohedron).    	 */    	public function getSides():Float{    		return _sides;    	}    	    	public function setSides(val:Float):Float{    		if (_sides == val)    			return;    		    		_sides = val;    		_primitiveDirty = true;    		return val;    	}    			    	/**    	 * Defines the subdivision of the polygon. Defaults to 1.    	 */    	public function getSubdivision():Float{    		return _subdivision;    	}    	    	public function setSubdivision(val:Float):Float{    		if (_subdivision == val)    			return;    		    		_subdivision = val;    		_primitiveDirty = true;    		return val;    	}    	    	/**    	 * Defines whether the coordinates of the polygon points use a yUp orientation (true) or a zUp orientation (false). Defaults to true.    	 */    	public function getYUp():Bool{    		return _yUp;    	}    	    	public function setYUp(val:Bool):Bool{    		if (_yUp == val)    			return;    		    		_yUp = val;    		_primitiveDirty = true;    		return val;    	}    			/**		 * Creates a new <code>RegularPolygon</code> object.		 *		 * @param	init			[optional]	An initialisation object for specifying default instance properties.		 */        public function new(?init:Dynamic = null)        {            super(init);            _radius = ini.getNumber("radius", 100, {min:0});			_sides = ini.getInt("sides", 8, {min:3});			_subdivision = ini.getInt("subdivision", 1, {min:1}); 			_yUp = ini.getBoolean("yUp", true);						buildRegularPolygon(_radius, _sides, _subdivision, _yUp);						type = "RegularPolygon";        	url = "primitive";        }        		/**		 * @inheritDoc		 */    	public override function buildPrimitive():Void    	{    		super.buildPrimitive();    		            buildRegularPolygon(_radius, _sides, _subdivision, _yUp);    	}    }