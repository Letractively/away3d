package away3d.loaders.utils;

import away3d.core.utils.Debug;
import away3d.loaders.data.GeometryData;


/**
 * Store for all geometries associated with an externally loaded file.
 */
class GeometryLibrary extends Hash<GeometryData>  {
	
	private var _geometry:GeometryData;
	private var _geometryArray:Array<GeometryData>;
	private var _geometryArrayDirty:Bool;
	/**
	 * The name of the geometry used as a unique reference.
	 */
	public var name:String;
	

	private function updateGeometryArray():Void {
		
		_geometryArray = [];
		for (_geometry in this.iterator()) {
			if (_geometry != null) {
				_geometryArray.push(_geometry);
			}
		}

	}

	/**
	 * Adds a geometry name reference to the library.
	 */
	public function addGeometry(name:String, ?geoXML:Xml=null, ?ctrlXML:Xml=null):GeometryData {
		//return if geometry already exists
		
		if ((this.get(name) != null)) {
			return this.get(name);
		}
		_geometryArrayDirty = true;
		var geometryData:GeometryData = new GeometryData();
		geometryData.geoXML = geoXML;
		geometryData.ctrlXML = ctrlXML;
		geometryData.name = name;
		this.set(name, geometryData);
		return geometryData;
	}

	/**
	 * Returns a geometry data object for the given name reference in the library.
	 */
	public function getGeometry(name:String):GeometryData {
		//return if geometry exists
		
		if ((this.get(name) != null)) {
			return this.get(name);
		}
		Debug.warning("Geometry '" + name + "' does not exist");
		return null;
	}

	/**
	 * Returns an array of all geometries.
	 */
	public function getGeometryArray():Array<GeometryData> {
		
		if (_geometryArrayDirty) {
			updateGeometryArray();
		}
		return _geometryArray;
	}

	// autogenerated
	public function new () {
		super();
		
	}

	

}

