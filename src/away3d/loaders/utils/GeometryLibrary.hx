package away3d.loaders.utils;

import away3d.core.utils.Debug;
import flash.utils.Dictionary;
import away3d.loaders.data.GeometryData;


/**
 * Store for all geometries associated with an externally loaded file.
 */
class GeometryLibrary extends Dictionary  {
	
	private var _geometry:GeometryData;
	private var _geometryArray:Array<Dynamic>;
	private var _geometryArrayDirty:Bool;
	/**
	 * The name of the geometry used as a unique reference.
	 */
	public var name:String;
	

	private function updateGeometryArray():Void {
		
		_geometryArray = [];
		var __keys:Iterator<Dynamic> = untyped (__keys__(this)).iterator();
		for (__key in __keys) {
			_geometry = this[untyped __key];

			if (_geometry != null) {
				_geometryArray.push(_geometry);
			}
		}

	}

	/**
	 * Adds a geometry name reference to the library.
	 */
	public function addGeometry(name:String, ?geoXML:Xml=null, ?ctrlXML:Xml=null):GeometryData {
		//return if geometry already exists
		
		if ((this[untyped name] != null)) {
			return this[untyped name];
		}
		_geometryArrayDirty = true;
		var geometryData:GeometryData = new GeometryData();
		geometryData.geoXML = geoXML;
		geometryData.ctrlXML = ctrlXML;
		this[untyped geometryData.name = name] = geometryData;
		return geometryData;
	}

	/**
	 * Returns a geometry data object for the given name reference in the library.
	 */
	public function getGeometry(name:String):GeometryData {
		//return if geometry exists
		
		if ((this[untyped name] != null)) {
			return this[untyped name];
		}
		Debug.warning("Geometry '" + name + "' does not exist");
		return null;
	}

	/**
	 * Returns an array of all geometries.
	 */
	public function getGeometryArray():Array<Dynamic> {
		
		if (_geometryArrayDirty) {
			updateGeometryArray();
		}
		return _geometryArray;
	}

	// autogenerated
	public function new () {
		super();
		
	}

	

}

