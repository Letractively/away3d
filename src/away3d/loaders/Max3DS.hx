package away3d.loaders;	import away3d.containers.*;	import away3d.arcane;	import away3d.core.base.*;	import away3d.core.utils.*;	import away3d.loaders.data.*;	import away3d.loaders.utils.*;	import away3d.materials.*;		import flash.utils.ByteArray;	import flash.utils.Endian;	use namespace arcane;	    /**    * File loader for the 3DS file format.    */	class Max3DS extends AbstractParser {		/** @private */				/** @private */		arcane var ini:Init;				/** An array of bytes from the 3ds files. */		var _data:ByteArray;		var _materialData:MaterialData;		var _meshData:MeshData;		var _geometryData:GeometryData;		var _faceData:FaceData;		var averageX:Float;		var averageY:Float;		var averageZ:Float;		var numVertices:Int;		var _meshMaterialData:MeshMaterialData;		var _faceListIndex:Int;			var _face:Face;		var _vertex:Vertex;		var _totalChunks:Int ;        var _parsedChunks:Int ;				//>----- Color Types --------------------------------------------------------				var AMBIENT:String ;		var DIFFUSE:String ;		var SPECULAR:String ;				//>----- Main Chunks --------------------------------------------------------				var PRIMARY:Int ;		var EDIT3DS:Int ;  // Start of our actual objects		var KEYF3DS:Int ;  // Start of the keyframe information				//>----- General Chunks -----------------------------------------------------				var VERSION:Int ;		var MESH_VERSION:Int ;		var KFVERSION:Int ;		var COLOR_F:Int ;		var COLOR_RGB:Int ;		var LIN_COLOR_24:Int ;		var LIN_COLOR_F:Int ;		var INT_PERCENTAGE:Int ;		var FLOAT_PERC:Int ;		var MASTER_SCALE:Int ;		var IMAGE_FILE:Int ;		var AMBIENT_LIGHT:Int X2100;				//>----- Object Chunks -----------------------------------------------------				var MESH:Int ;		var MESH_OBJECT:Int ;		var MESH_VERTICES:Int ;		var VERTEX_FLAGS:Int ;		var MESH_FACES:Int ;		var MESH_MATER:Int ;		var MESH_TEX_VERT:Int ;		var MESH_XFMATRIX:Int ;		var MESH_COLOR_IND:Int ;		var MESH_TEX_INFO:Int ;		var HEIRARCHY:Int ;				//>----- Material Chunks ---------------------------------------------------				var MATERIAL:Int ;		var MAT_NAME:Int ;		var MAT_AMBIENT:Int ;		var MAT_DIFFUSE:Int ;		var MAT_SPECULAR:Int ;		var MAT_SHININESS:Int ;		var MAT_FALLOFF:Int ;		var MAT_EMISSIVE:Int ;		var MAT_SHADER:Int ;		var MAT_TEXMAP:Int ;		var MAT_TEXFLNM:Int ;		var OBJ_LIGHT:Int ;		var OBJ_CAMERA:Int ;				//>----- KeyFrames Chunks --------------------------------------------------				var ANIM_HEADER:Int ;		var ANIM_OBJ:Int ;		var ANIM_NAME:Int ;		var ANIM_POS:Int ;		var ANIM_ROT:Int ;		var ANIM_SCALE:Int ;				var texturePath:String;        var autoLoadTextures:Bool;                /**        * Reference container for all materials used in the 3ds object.        */		public var materialLibrary:MaterialLibrary ;    	    	public var animationLibrary:AnimationLibrary;    	    	public var geometryLibrary:GeometryLibrary;    	    	/**    	 * Array of mesh data objects used for storing the parsed 3ds data structure.    	 */		public var meshDataList:Array<Dynamic> ;						/**		* In the 3ds file only the file names of texture files are given.		* If the textures are stored in a specific path, that path can be		* specified through the constructor.		*/		var centerMeshes:Bool;		var material:ITriangleMaterial;				var _maxX:Float;		var _minX:Float;		var _maxY:Float;		var _minY:Float;		var _maxZ:Float;		var _minZ:Float;				/**		 * Read id and length of 3ds chunk		 * 		 * @param chunk 		 * 		 */				function readChunk(chunk:Chunk3ds):Void		{			chunk.id = _data.readUnsignedShort();			chunk.length = _data.readUnsignedInt();			chunk.bytesRead = 6;		}				/**		 * Skips past a chunk. If we don't understand the meaning of a chunk id,		 * we just skip past it.		 * 		 * @param chunk		 * 		 */				function skipChunk(chunk:Chunk3ds):Void		{			_data.position += chunk.length - chunk.bytesRead;			chunk.bytesRead = chunk.length;		}				/**		 * Read the base 3DS object.		 * 		 * @param chunk		 * 		 */				function parse3DS(chunk:Chunk3ds):Void		{			while (chunk.bytesRead < chunk.length)			{				var subChunk:Chunk3ds = new Chunk3ds();				readChunk(subChunk);				switch (subChunk.id)				{					case EDIT3DS:						parseEdit3DS(subChunk);						break;					case KEYF3DS:						skipChunk(subChunk);						break;					default:						skipChunk(subChunk);				}				chunk.bytesRead += subChunk.length;			}		}				/**		 * Read the Edit chunk		 * 		 * @param chunk		 * 		 */		function parseEdit3DS(chunk:Chunk3ds):Void		{			while (chunk.bytesRead < chunk.length)			{				var subChunk:Chunk3ds = new Chunk3ds();				readChunk(subChunk);				switch (subChunk.id)				{					case MATERIAL:						parseMaterial(subChunk);						break;					case MESH:						_meshData = new MeshData();						readMeshName(subChunk);        				_meshData.geometry = geometryLibrary.addGeometry(_meshData.name);						parseMesh(subChunk);						meshDataList.push(_meshData);						break;					default:						skipChunk(subChunk);				}								chunk.bytesRead += subChunk.length;			}		}				function parseMaterial(chunk:Chunk3ds):Void		{			while (chunk.bytesRead < chunk.length)			{				var subChunk:Chunk3ds = new Chunk3ds();				readChunk(subChunk);				switch (subChunk.id)				{					case MAT_NAME:						readMaterialName(subChunk);						break;					case MAT_AMBIENT:						readColor(AMBIENT);						break;					case MAT_DIFFUSE:						readColor(DIFFUSE);						break;					case MAT_SPECULAR:						readColor(SPECULAR);						break;					case MAT_TEXMAP:						parseMaterial(subChunk);						break;					case MAT_TEXFLNM:						readTextureFileName(subChunk);						break;					default:						skipChunk(subChunk);				}				chunk.bytesRead += subChunk.length;			}		}				function readMaterialName(chunk:Chunk3ds):Void		{			_materialData = materialLibrary.addMaterial(readASCIIZString(_data));						chunk.bytesRead = chunk.length;		}				function readColor(type:String):Void		{			_materialData.materialType = MaterialData.SHADING_MATERIAL;						var color:Int;			var chunk:Chunk3ds = new Chunk3ds();			readChunk(chunk);			switch (chunk.id)			{				case COLOR_RGB:					color = readColorRGB(chunk);					break;				case COLOR_F:				// TODO: write implentation code					trace("COLOR_F not implemented yet");					skipChunk(chunk);					break;				default:					skipChunk(chunk);					trace("unknown ambient color format");			}						switch (type)			{				case AMBIENT:					_materialData.ambientColor = color;					break;				case DIFFUSE:					_materialData.diffuseColor = color;					break;				case SPECULAR:					_materialData.specularColor = color;					break;			}		}				function readColorRGB(chunk:Chunk3ds):Int		{			var color:Int = 0;						for (i in 0...3)			{				var c:Int = _data.readUnsignedByte();				color += c*Math.pow(0x100, 2-i);				chunk.bytesRead++;			}						return color;		}				function readTextureFileName(chunk:Chunk3ds):Void		{			_materialData.textureFileName = readASCIIZString(_data);			_materialData.materialType = MaterialData.TEXTURE_MATERIAL;						chunk.bytesRead = chunk.length;		}				function parseMesh(chunk:Chunk3ds):Void		{			while (chunk.bytesRead < chunk.length)			{				var subChunk:Chunk3ds = new Chunk3ds();				readChunk(subChunk);				switch (subChunk.id)				{					case MESH_OBJECT:						parseMesh(subChunk);						break;					case MESH_VERTICES:						readMeshVertices(subChunk);						break;					case MESH_FACES:						readMeshFaces(subChunk);						parseMesh(subChunk);						break;					case MESH_MATER:						readMeshMaterial(subChunk);						break;					case MESH_TEX_VERT:						readMeshTexVert(subChunk);						break;					default:						skipChunk(subChunk);				}				chunk.bytesRead += subChunk.length;			}		}				function readMeshName(chunk:Chunk3ds):Void		{			_meshData.name = readASCIIZString(_data);			chunk.bytesRead += _meshData.name.length + 1;		}				function readMeshVertices(chunk:Chunk3ds):Void		{			var numVerts:Int = _data.readUnsignedShort();			chunk.bytesRead += 2;						for (i in 0...numVerts)			{				_meshData.geometry.vertices.push(new Vertex(-_data.readFloat(), _data.readFloat(), _data.readFloat()));				chunk.bytesRead += 12;			}		}				function readMeshFaces(chunk:Chunk3ds):Void		{			var numFaces:Int = _data.readUnsignedShort();			chunk.bytesRead += 2;			for (i in 0...numFaces)			{				_faceData = new FaceData();								_faceData.v0 = _data.readUnsignedShort();				_faceData.v1 = _data.readUnsignedShort();				_faceData.v2 = _data.readUnsignedShort();				_faceData.visible = (cast( _data.readUnsignedShort(), Boolean));				chunk.bytesRead += 8;								_meshData.geometry.faces.push(_faceData);			}		}					/**		 * Read the Mesh Material chunk		 * 		 * @param chunk		 * 		 */		function readMeshMaterial(chunk:Chunk3ds):Void		{			var meshMaterial:MeshMaterialData = new MeshMaterialData();			meshMaterial.symbol = readASCIIZString(_data);			chunk.bytesRead += meshMaterial.symbol.length +1;						var numFaces:Int = _data.readUnsignedShort();			chunk.bytesRead += 2;			for (i in 0...numFaces)			{				meshMaterial.faceList.push(_data.readUnsignedShort());				chunk.bytesRead += 2;			}						_meshData.geometry.materials.push(meshMaterial);		}				function readMeshTexVert(chunk:Chunk3ds):Void		{			var numUVs:Int = _data.readUnsignedShort();			chunk.bytesRead += 2;						for (i in 0...numUVs)			{				_meshData.geometry.uvs.push(new UV(_data.readFloat(), _data.readFloat()));				chunk.bytesRead += 8;			}		}				/**		 * Reads a null-terminated ascii string out of a byte array.		 * 		 * @param data The byte array to read from.		 * @return The string read, without the null-terminating character.		 * 		 */				function readASCIIZString(data:ByteArray):String		{			//var readLength:int = 0; // length of string to read			var l:Int = data.length - data.position;			var tempByteArray:ByteArray = new ByteArray();						for (i in 0...l)			{				var c:Int = data.readByte();								if (c == 0)				{					break;				}				tempByteArray.writeByte(c);			}						var asciiz:String = "";			tempByteArray.position = 0;			for (i in 0...tempByteArray.length)			{				asciiz += String.fromCharCode(tempByteArray.readByte());			}			return asciiz;		}				function buildMeshes():Void		{						for (_meshData in meshDataList)			{				//create Mesh object				var mesh:Mesh = new Mesh({name:_meshData.name});								_geometryData = _meshData.geometry;				var geometry:Geometry = _geometryData.geometry;								if (!geometry) {					geometry = _geometryData.geometry = new Geometry();										mesh.geometry = geometry;										//set materialdata for each face					for (_meshMaterialData in _geometryData.materials) {						for (_faceListIndex in _meshMaterialData.faceList) {							_faceData = cast( _geometryData.faces[_faceListIndex], FaceData);							_faceData.materialData = materialLibrary[_meshMaterialData.symbol];						}					}										for (_faceData in _geometryData.faces) {						_face = new Face(_geometryData.vertices[_faceData.v0],													_geometryData.vertices[_faceData.v1],													_geometryData.vertices[_faceData.v2],													cast( _faceData.materialData.material, ITriangleMaterial),													_geometryData.uvs[_faceData.v0],													_geometryData.uvs[_faceData.v1],													_geometryData.uvs[_faceData.v2]);						geometry.addFace(_face);						_faceData.materialData.elements.push(_face);					}				} else {					mesh.geometry = geometry;				}							if (centerMeshes) {					//center vertex points in mesh for better bounding radius calulations					_maxX = -Infinity;					_minX = Infinity;					_maxY = -Infinity;					_minY = Infinity;					_maxZ = -Infinity;					_minZ = Infinity;                    for (_vertex in mesh.geometry.vertices) {						if (_maxX < _vertex._x)							_maxX = _vertex._x;						if (_minX > _vertex._x)							_minX = _vertex._x;						if (_maxY < _vertex._y)							_maxY = _vertex._y;						if (_minY > _vertex._y)							_minY = _vertex._y;						if (_maxZ < _vertex._z)							_maxZ = _vertex._z;						if (_minZ > _vertex._z)							_minZ = _vertex._z;                    }					mesh.movePivot((_maxX + _minX)*.5, (_maxY + _minY)*.5, (_maxZ + _minZ)*.5);					mesh.moveTo((_maxX + _minX)*.5, (_maxY + _minY)*.5, (_maxZ + _minZ)*.5);				}								mesh.type = ".3ds";				(cast( container, ObjectContainer3D)).addChild(mesh);			}		}				function buildMaterials():Void		{			for (_materialData in materialLibrary)			{				//overridden by the material property in constructor				if (material)					_materialData.material = material;								//overridden by materials passed in contructor				if (_materialData.material)					continue;								switch (_materialData.materialType)				{					case MaterialData.TEXTURE_MATERIAL:						materialLibrary.loadRequired = true;						break;					case MaterialData.SHADING_MATERIAL:						_materialData.material = new ShadingColorMaterial({ambient:_materialData.ambientColor, diffuse:_materialData.diffuseColor, specular:_materialData.specularColor});						break;					case MaterialData.WIREFRAME_MATERIAL:						_materialData.material = new WireColorMaterial();						break;				}			}		}				/**		 * Creates a new <code>Max3DS</code> object. Not intended for direct use, use the static <code>parse</code> or <code>load</code> methods.		 * 		 * @param	data				The binary data of a loaded file.		 * @param	init	[optional]	An initialisation object for specifying default instance properties.		 * 		 * @see away3d.loaders.Max3DS#parse()		 * @see away3d.loaders.Max3DS#load()		 */		public function new(data:Dynamic, ?init:Dynamic = null)		{			
			_totalChunks = 0;
			_parsedChunks = 0;
			AMBIENT = "ambient";
			DIFFUSE = "diffuse";
			SPECULAR = "specular";
			PRIMARY = 0x4D4D;
			EDIT3DS = 0x3D3D;
			KEYF3DS = 0xB000;
			VERSION = 0x0002;
			MESH_VERSION = 0x3D3E;
			KFVERSION = 0x0005;
			COLOR_F = 0x0010;
			COLOR_RGB = 0x0011;
			LIN_COLOR_24 = 0x0012;
			LIN_COLOR_F = 0x0013;
			INT_PERCENTAGE = 0x0030;
			FLOAT_PERC = 0x0031;
			MASTER_SCALE = 0x0100;
			IMAGE_FILE = 0x1100;
			AMBIENT_LIGHT = 0;
			MESH = 0x4000;
			MESH_OBJECT = 0x4100;
			MESH_VERTICES = 0x4110;
			VERTEX_FLAGS = 0x4111;
			MESH_FACES = 0x4120;
			MESH_MATER = 0x4130;
			MESH_TEX_VERT = 0x4140;
			MESH_XFMATRIX = 0x4160;
			MESH_COLOR_IND = 0x4165;
			MESH_TEX_INFO = 0x4170;
			HEIRARCHY = 0x4F00;
			MATERIAL = 0xAFFF;
			MAT_NAME = 0xA000;
			MAT_AMBIENT = 0xA010;
			MAT_DIFFUSE = 0xA020;
			MAT_SPECULAR = 0xA030;
			MAT_SHININESS = 0xA040;
			MAT_FALLOFF = 0xA052;
			MAT_EMISSIVE = 0xA080;
			MAT_SHADER = 0xA100;
			MAT_TEXMAP = 0xA200;
			MAT_TEXFLNM = 0xA300;
			OBJ_LIGHT = 0x4600;
			OBJ_CAMERA = 0x4700;
			ANIM_HEADER = 0xB00A;
			ANIM_OBJ = 0xB002;
			ANIM_NAME = 0xB010;
			ANIM_POS = 0xB020;
			ANIM_ROT = 0xB021;
			ANIM_SCALE = 0xB022;
			materialLibrary = new MaterialLibrary();
			meshDataList = [];
			_data = Cast.bytearray(data);			_data.endian = Endian.LITTLE_ENDIAN;						ini = Init.parse(init);			texturePath = ini.getString("texturePath", "");			autoLoadTextures = ini.getBoolean("autoLoadTextures", true);			material = ini.getMaterial("material");			centerMeshes = ini.getBoolean("centerMeshes", false);						var materials:Dynamic = ini.getObject("materials") || {};						for (var name:String in materials) {                _materialData = materialLibrary.addMaterial(name);                _materialData.material = Cast.material(materials[name]);                                //determine material type                if (Std.is( _materialData.material, BitmapMaterial))                	_materialData.materialType = MaterialData.TEXTURE_MATERIAL;                else if (Std.is( _materialData.material, ShadingColorMaterial))                	_materialData.materialType = MaterialData.SHADING_MATERIAL;                else if (Std.is( _materialData.material, WireframeMaterial))                	_materialData.materialType = MaterialData.WIREFRAME_MATERIAL;   			}            			container = new ObjectContainer3D(ini);			container.name = "max3ds";						materialLibrary = container.materialLibrary = new MaterialLibrary();			animationLibrary = container.animationLibrary = new AnimationLibrary();			geometryLibrary = container.geometryLibrary = new GeometryLibrary();			materialLibrary.autoLoadTextures = autoLoadTextures;			materialLibrary.texturePath = texturePath;						//first chunk is always the primary, so we simply read it and parse it			var chunk:Chunk3ds = new Chunk3ds();			readChunk(chunk);			parse3DS(chunk);						//build materials			buildMaterials();						//build the meshes			buildMeshes();		}    	    	/**    	 * Loads and parses a 3ds file into a 3d container object.    	 *     	 * @param	url					The url location of the file to load.    	 * @param	init	[optional]	An initialisation object for specifying default instance properties.    	 * @return						A 3d loader object that can be used as a placeholder in a scene while the file is loading.    	 */        public static function load(url:String, ?init:Dynamic = null):Object3DLoader        {        	//texturePath as model folder			if (url)			{				var _pathArray:Array<Dynamic> = url.split("/");				var _imageName:String = _pathArray.pop();				var _texturePath:String = (_pathArray.length>0)?_pathArray.join("/")+"/":_pathArray.join("/");				if (init){					init.texturePath = (init.texturePath)?init.texturePath:_texturePath;				}else {					init = { texturePath:_texturePath };				}			}            return Object3DLoader.loadGeometry(url, Max3DS, true, init);        }		/**		 * Creates a 3d container object from the raw binary data of a 3ds file.		 * 		 * @param	data				The binary data of a loaded file.		 * @param	init	[optional]	An initialisation object for specifying default instance properties.		 * 		 * @return						A 3d container object representation of the 3ds file.		 */        public static function parse(data:Dynamic, ?init:Dynamic = null):ObjectContainer3D        {        	return cast( Object3DLoader.parseGeometry(data, Max3DS, init).handle, ObjectContainer3D);        }	}