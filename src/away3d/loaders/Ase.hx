package away3d.loaders;

import away3d.core.utils.ValueObject;
import away3d.core.base.Face;
import away3d.core.base.Object3D;
import away3d.core.base.Mesh;
import away3d.core.utils.Cast;
import away3d.core.utils.Init;
import away3d.core.base.UV;
import away3d.core.base.Vertex;
import away3d.core.base.Element;


// use namespace arcane;

/**
 * File loader for the ASE file format.
 */
class Ase extends AbstractParser  {
	
	private var mesh:Mesh;
	private var scaling:Float;
	private var ini:Init;
	

	private function parseAse(data:String):Void {
		
		var lines:Array<Dynamic> = data.split('\r\n');
		var vertices:Array<Dynamic> = [];
		var uvs:Array<Dynamic> = [];
		var faces:Array<Dynamic> = [];
		if (lines.length == 1) {
			lines = data.split('\n');
		}
		while (lines.length > 0) {
			var line:String = lines.shift();
			line = line.substr(line.indexOf('*') + 1);
			if (line.indexOf('}') >= 0) {
				continue;
			}
			var chunk:String = line.substr(0, line.indexOf(' '));
			switch (chunk) {
				case 'MESH_VERTEX_LIST' :
					while (true) {
						var vertexline:String = lines.shift();
						if (vertexline.indexOf('}') >= 0) {
							break;
						}
						vertexline = vertexline.substr(vertexline.indexOf('*') + 1);
						var mvl:Array<Dynamic> = vertexline.split('\t');
						// Swapped Y and Z
						var x:Float = Std.parseFloat(mvl[1]) * scaling;
						var z:Float = Std.parseFloat(mvl[2]) * scaling;
						var y:Float = Std.parseFloat(mvl[3]) * scaling;
						vertices.push(new Vertex(x, y, z));
					}

				case 'MESH_FACE_LIST' :
					while (true) {
						var faceline:String = lines.shift();
						if (faceline.indexOf('}') >= 0) {
							break;
						}
						faceline = faceline.substr(faceline.indexOf('*') + 1);
						// ignore: [MESH_SMOOTHING,MESH_MTLID]
						var mfl:String = faceline.split('\t')[0];
						// separate here
						var drc:Array<Dynamic> = mfl.split(':');
						var con:String;
						con = drc[2];
						var a:Vertex = vertices[Std.parseInt(con.substr(0, con.lastIndexOf(' ')))];
						con = drc[3];
						var b:Vertex = vertices[Std.parseInt(con.substr(0, con.lastIndexOf(' ')))];
						con = drc[4];
						var c:Vertex = vertices[Std.parseInt(con.substr(0, con.lastIndexOf(' ')))];
						faces.push(new Face(a, b, c));
					}

				case 'MESH_TVERTLIST' :
					while (true) {
						var textureline:String = lines.shift();
						if (textureline.indexOf('}') >= 0) {
							break;
						}
						textureline = textureline.substr(textureline.indexOf('*') + 1);
						var mtvl:Array<Dynamic> = textureline.split('\t');
						uvs.push(new UV(Std.parseFloat(mtvl[1]), Std.parseFloat(mtvl[2])));
					}

				case 'MESH_TFACELIST' :
					var num:Int = 0;
					while (true) {
						var mapline:String = lines.shift();
						if (mapline.indexOf('}') >= 0) {
							break;
						}
						mapline = mapline.substr(mapline.indexOf('*') + 1);
						var mtfl:Array<Dynamic> = mapline.split('\t');
						var face:Face = faces[num];
						face.uv0 = uvs[Std.parseInt(mtfl[1])];
						face.uv1 = uvs[Std.parseInt(mtfl[2])];
						face.uv2 = uvs[Std.parseInt(mtfl[3])];
						num++;
					}

				

			}
		}

		for (__i in 0...faces.length) {
			var f:Face = faces[__i];

			if (f != null) {
				mesh.addFace(f);
			}
		}

		mesh.type = ".Ase";
	}

	/**
	 * Creates a new <code>Ase</code> object. Not intended for direct use, use the static <code>parse</code> or <code>load</code> methods.
	 * 
	 * @param	Data				The ascii data of a loaded file.
	 * @param	init	[optional]	An initialisation object for specifying default instance properties.
	 * 
	 * @see away3d.loaders.Ase#parse()
	 * @see away3d.loaders.Ase#load()
	 */
	public function new(data:Dynamic, ?init:Dynamic=null) {
		// autogenerated
		super();
		
		
		ini = Init.parse(init);
		scaling = ini.getNumber("scaling", 1) * 100;
		mesh = cast((container = new Mesh(ini)), Mesh);
		parseAse(Cast.string(data));
	}

	/**
	 * Creates a 3d mesh object from the raw ascii data of the ase file.
	 * 
	 * @param	data				The ascii data of a loaded file.
	 * @param	init	[optional]	An initialisation object for specifying default instance properties.
	 * @param	loader	[optional]	Not intended for direct use.
	 * 
	 * @return						A 3d mesh object representation of the ase file.
	 */
	public static function parse(data:Dynamic, ?init:Dynamic=null):Mesh {
		
		return cast(Object3DLoader.parseGeometry(data, Ase, init).handle, Mesh);
		//return new Ase(Cast.string(data), init).mesh;
		
	}

	/**
	 * Loads and parses an ase file into a 3d mesh object.
	 * 
	 * @param	url					The url location of the file to load.
	 * @param	init	[optional]	An initialisation object for specifying default instance properties.
	 * @return						A 3d loader object that can be used as a placeholder in a scene while the file is loading.
	 */
	public static function load(url:String, ?init:Dynamic=null):Object3DLoader {
		
		return Object3DLoader.loadGeometry(url, Ase, false, init);
	}

}

