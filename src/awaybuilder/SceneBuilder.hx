package awaybuilder;

import away3d.haxeutils.Error;
import away3d.containers.ObjectContainer3D;
import away3d.containers.View3D;
import away3d.core.base.Mesh;
import away3d.core.base.Object3D;
import away3d.loaders.Collada;
import away3d.loaders.Object3DLoader;
import away3d.materials.BitmapFileMaterial;
import away3d.materials.BitmapMaterial;
import away3d.materials.MovieMaterial;
import awaybuilder.abstracts.AbstractBuilder;
import awaybuilder.camera.CameraFactory;
import awaybuilder.events.SceneEvent;
import awaybuilder.geometry.GeometryAttributes;
import awaybuilder.geometry.GeometryFactory;
import awaybuilder.geometry.GeometryType;
import awaybuilder.interfaces.IAssetContainer;
import awaybuilder.interfaces.IBuilder;
import awaybuilder.interfaces.ISceneContainer;
import awaybuilder.material.MaterialAttributes;
import awaybuilder.material.MaterialFactory;
import awaybuilder.material.MaterialType;
import awaybuilder.utils.ConvertCoordinates;
import awaybuilder.vo.DynamicAttributeVO;
import awaybuilder.vo.SceneCameraVO;
import awaybuilder.vo.SceneGeometryVO;
import awaybuilder.vo.SceneObjectVO;
import awaybuilder.vo.SceneSectionVO;
import flash.display.BitmapData;
import flash.display.DisplayObject;
import flash.display.MovieClip;
import flash.events.Event;
import flash.events.EventDispatcher;
import flash.display.Sprite;


class SceneBuilder extends AbstractBuilder, implements IBuilder, implements IAssetContainer, implements ISceneContainer {
	
	public var coordinateSystem:String;
	public var precision:Int;
	private var view:View3D;
	private var cameras:Array<Dynamic>;
	private var geometry:Array<Dynamic>;
	private var sections:Array<Dynamic>;
	private var mainSections:Array<Dynamic>;
	private var cameraFactory:CameraFactory;
	private var materialFactory:MaterialFactory;
	private var geometryFactory:GeometryFactory;
	private var bitmapDataAssets:Array<Dynamic>;
	private var displayObjectAssets:Array<Dynamic>;
	private var colladaAssets:Array<Dynamic>;
	

	public function new() {
		this.cameras = [];
		this.geometry = [];
		this.sections = [];
		this.bitmapDataAssets = [];
		this.displayObjectAssets = [];
		this.colladaAssets = [];
		
		
		super();
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	// Public Methods
	//
	////////////////////////////////////////////////////////////////////////////////
	override public function build(view:View3D, sections:Array<Dynamic>):Void {
		
		this.view = view;
		this.mainSections = sections;
		this.createCameraFactory();
		this.createGeometryFactory();
		this.createMaterialFactory();
		this.createSections();
		this.applyValues();
		this.dispatchEvent(new Event(Event.COMPLETE));
	}

	override public function addBitmapDataAsset(id:String, data:BitmapData):Void {
		
		this.bitmapDataAssets[id] = data;
	}

	override public function addDisplayObjectAsset(id:String, data:DisplayObject):Void {
		
		this.displayObjectAssets[id] = data;
	}

	override public function addColladaAsset(id:String, data:Xml):Void {
		
		this.colladaAssets[id] = data;
	}

	override public function getCameras():Array<Dynamic> {
		
		return this.cameras;
	}

	override public function getGeometry():Array<Dynamic> {
		
		return this.geometry;
	}

	override public function getSections():Array<Dynamic> {
		
		return this.sections;
	}

	override public function getCameraById(id:String):SceneCameraVO {
		
		for (__i in 0...this.cameras.length) {
			var vo:SceneCameraVO = this.cameras[__i];

			if (vo != null) {
				if (vo.id == id) {
					return vo;
				}
			}
		}

		if (this.cameras.length == 0) {
			throw new Error("no cameras available");
		} else {
			throw new Error("camera with id [" + id + "] not found");
		}
		
		// autogenerated
		return null;
	}

	override public function getGeometryById(id:String):SceneGeometryVO {
		
		for (__i in 0...this.geometry.length) {
			var vo:SceneGeometryVO = this.geometry[__i];

			if (vo != null) {
				if (vo.id == id) {
					return vo;
				}
			}
		}

		if (this.geometry.length == 0) {
			throw new Error("no geometry available");
		} else {
			throw new Error("geometry with id [" + id + "] not found");
		}
		
		// autogenerated
		return null;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	// Protected Methods
	//
	////////////////////////////////////////////////////////////////////////////////
	private function createCameraFactory():Void {
		
		this.cameraFactory = new CameraFactory();
	}

	private function createGeometryFactory():Void {
		
		this.geometryFactory = new GeometryFactory();
		this.geometryFactory.coordinateSystem = this.coordinateSystem;
		this.geometryFactory.precision = this.precision;
	}

	private function createMaterialFactory():Void {
		
		this.materialFactory = new MaterialFactory();
	}

	private function createSections():Void {
		
		for (__i in 0...this.mainSections.length) {
			var section:SceneSectionVO = this.mainSections[__i];

			if (section != null) {
				if (section.enabled) {
					this.createSection(section);
				}
			}
		}

	}

	private function createSection(section:SceneSectionVO):Void {
		
		if (section.enabled) {
			this.view.scene.addChild(section.pivot);
			this.createCameras(section);
			this.createGeometry(section);
			this.createSubSections(section);
			this.sections.push(section);
		}
	}

	private function createSubSections(section:SceneSectionVO):Void {
		
		for (__i in 0...section.sections.length) {
			var subSection:SceneSectionVO = section.sections[__i];

			if (subSection != null) {
				this.createSection(subSection);
			}
		}

	}

	private function applyValues():Void {
		
		this.dispatchEvent(new SceneEvent(SceneEvent.RENDER));
		for (__i in 0...this.geometry.length) {
			var geometryVO:SceneGeometryVO = this.geometry[__i];

			if (geometryVO != null) {
				switch (geometryVO.geometryType) {
					case GeometryType.COLLADA :
						break;
					default :
						this.applyPosition(geometryVO.mesh, geometryVO.values);
						this.applyMeshRotation(geometryVO.mesh, geometryVO.values);
						this.applyScale(cast(geometryVO.mesh, Mesh), geometryVO.values);
					

				}
			}
		}

		// FIXME: Implement group position and scale conversion.
		for (__i in 0...this.mainSections.length) {
			var sectionVO:SceneSectionVO = this.mainSections[__i];

			if (sectionVO != null) {
				this.applyPosition(sectionVO.pivot, sectionVO.values);
				this.applyGroupRotation(sectionVO.pivot, sectionVO.values);
				this.applyPivotScale(sectionVO.pivot, sectionVO.values);
			}
		}

		for (__i in 0...this.cameras.length) {
			var cameraVO:SceneCameraVO = this.cameras[__i];

			if (cameraVO != null) {
				this.applyPosition(cameraVO.camera, cameraVO.values);
				this.applyCameraRotation(cameraVO.camera, cameraVO.values);
			}
		}

		this.dispatchEvent(new SceneEvent(SceneEvent.RENDER));
	}

	private function applyColladaValues(target:Object3D, values:SceneObjectVO):Void {
		
		this.applyPosition(target, values);
		this.applyColladaRotation(target, values);
		this.applyColladaScale(target, values);
	}

	private function createCameras(section:SceneSectionVO):Void {
		
		for (__i in 0...section.cameras.length) {
			var vo:SceneCameraVO = section.cameras[__i];

			if (vo != null) {
				vo = this.cameraFactory.build(vo);
				this.cameras.push(vo);
			}
		}

	}

	private function createGeometry(section:SceneSectionVO):Void {
		
		for (__i in 0...section.geometry.length) {
			var geometry:SceneGeometryVO = section.geometry[__i];

			if (geometry != null) {
				var useDefaultGeometry:Bool = true;
				this.createMaterial(geometry);
				for (__i in 0...geometry.geometryExtras.length) {
					var attribute:DynamicAttributeVO = geometry.geometryExtras[__i];

					if (attribute != null) {
						switch (attribute.key) {
							case GeometryAttributes.CLASS :
								geometry = this.geometryFactory.build(attribute, geometry);
								useDefaultGeometry = false;
								break;
							

						}
					}
				}

				if (useDefaultGeometry) {
					geometry = geometryFactory.buildDefault(geometry);
				}
				this.applyExternalAssets(section, geometry);
			}
		}

	}

	private function createMaterial(geometry:SceneGeometryVO):Void {
		
		var useDefaultMaterial:Bool = true;
		for (__i in 0...geometry.materialExtras.length) {
			var attribute:DynamicAttributeVO = geometry.materialExtras[__i];

			if (attribute != null) {
				switch (attribute.key) {
					case MaterialAttributes.CLASS :
						geometry = materialFactory.build(attribute, geometry);
						useDefaultMaterial = false;
						break;
					

				}
			}
		}

		if (useDefaultMaterial) {
			geometry = materialFactory.buildDefault(geometry);
		}
	}

	private function applyExternalAssets(section:SceneSectionVO, vo:SceneGeometryVO):Void {
		
		switch (vo.materialType) {
			case MaterialType.BITMAP_MATERIAL :
				var bitmapData:BitmapData = this.bitmapDataAssets[vo.assetClass];
				vo.materialData = bitmapData;
				vo.material = new BitmapMaterial(bitmapData);
				Reflect.setField(vo.material, MaterialAttributes.SMOOTH, vo.smooth);
				Reflect.setField(vo.material, MaterialAttributes.PRECISION, vo.precision);
				Mesh(vo.mesh).material = cast(vo.material, BitmapMaterial);
				break;
			case MaterialType.BITMAP_FILE_MATERIAL :
				vo.material = new BitmapFileMaterial(vo.assetFile);
				Reflect.setField(vo.material, MaterialAttributes.SMOOTH, vo.smooth);
				Reflect.setField(vo.material, MaterialAttributes.PRECISION, vo.precision);
				Mesh(vo.mesh).material = cast(vo.material, BitmapFileMaterial);
				if ((vo.assetFileBack != null)) {
					vo.materialBack = new BitmapFileMaterial(vo.assetFileBack);
					Reflect.setField(vo.materialBack, MaterialAttributes.SMOOTH, vo.smooth);
					Reflect.setField(vo.materialBack, MaterialAttributes.PRECISION, vo.precision);
					Mesh(vo.mesh).back = cast(vo.materialBack, BitmapFileMaterial);
				}
				break;
			case MaterialType.MOVIE_MATERIAL :
				var movieClip:MovieClip = this.displayObjectAssets[vo.assetClass];
				vo.materialData = movieClip;
				vo.material = new MovieMaterial(movieClip);
				Mesh(vo.mesh).material = cast(vo.material, MovieMaterial);
				break;
			

		}
		switch (vo.geometryType) {
			case GeometryType.COLLADA :
				if (vo.assetClass != null) {
					var xml:Xml = this.colladaAssets[vo.assetClass];
					var container:ObjectContainer3D = Collada.parse(xml);
					vo.mesh = container;
					section.pivot.addChild(container);
					this.applyColladaValues(container, vo.values);
				} else if (vo.assetFile != null) {
					var loader:Object3DLoader = Collada.load(vo.assetFile);
					vo.mesh = (loader.handle);
					loader.extra = vo;
					loader.addOnSuccess(this.onColladaLoadSuccess);
					section.pivot.addChild(loader);
				}
				break;
			default :
				if (vo.enabled) {
					section.pivot.addChild(vo.mesh);
				}
			

		}
		this.geometry.push(vo);
	}

	private function onColladaLoadSuccess(event:Event):Void {
		
		var loader:Object3DLoader = cast(event.target, Object3DLoader);
		var handle:Object3D = loader.handle;
		var vo:SceneGeometryVO = cast(loader.extra, SceneGeometryVO);
		this.applyColladaValues(handle, vo.values);
		this.dispatchEvent(new SceneEvent(SceneEvent.RENDER));
	}

	private function applyPosition(target:Object3D, values:SceneObjectVO):Void {
		
		var s:Int = this.precision;
		var c:String = this.coordinateSystem;
		target.x = s * ConvertCoordinates.positionX(values.x, c);
		target.y = s * ConvertCoordinates.positionY(values.y, c);
		target.z = s * ConvertCoordinates.positionZ(values.z, c);
	}

	private function applyMeshRotation(target:Object3D, values:SceneObjectVO):Void {
		
		var c:String = this.coordinateSystem;
		target.rotationX = ConvertCoordinates.meshRotationX(values.rotationX, c);
		target.rotationY = ConvertCoordinates.meshRotationY(values.rotationY, c);
		target.rotationZ = ConvertCoordinates.meshRotationZ(values.rotationZ, c);
	}

	private function applyGroupRotation(target:Object3D, values:SceneObjectVO):Void {
		
		var c:String = this.coordinateSystem;
		target.rotationX = ConvertCoordinates.groupRotationX(values.rotationX, c);
		target.rotationY = ConvertCoordinates.groupRotationY(values.rotationY, c);
		target.rotationZ = ConvertCoordinates.groupRotationZ(values.rotationZ, c);
	}

	private function applyColladaRotation(target:Object3D, values:SceneObjectVO):Void {
		
		var c:String = this.coordinateSystem;
		target.rotationX = ConvertCoordinates.colladaRotationX(values.rotationX, c);
		target.rotationY = ConvertCoordinates.colladaRotationY(values.rotationY, c);
		target.rotationZ = ConvertCoordinates.colladaRotationZ(values.rotationZ, c);
	}

	private function applyCameraRotation(target:Object3D, values:SceneObjectVO):Void {
		
		var c:String = this.coordinateSystem;
		target.rotationX = ConvertCoordinates.cameraRotationX(values.rotationX, c);
		target.rotationY = ConvertCoordinates.cameraRotationY(values.rotationY, c);
		target.rotationZ = ConvertCoordinates.cameraRotationZ(values.rotationZ, c);
	}

	private function applyScale(target:Mesh, values:SceneObjectVO):Void {
		// NOTE: Input Y and Z are switched. This is due to differences in creation plane.
		
		target.scaleX = values.scaleX;
		target.scaleY = values.scaleZ;
		target.scaleZ = values.scaleY;
	}

	private function applyPivotScale(target:Object3D, values:SceneObjectVO):Void {
		
		target.scale(values.scaleX);
	}

	private function applyColladaScale(target:Object3D, values:SceneObjectVO):Void {
		
		var multiplier:Int;
		switch (this.coordinateSystem) {
			case CoordinateSystem.MAYA :
				multiplier = Std.int(this.precision / 100);
				break;
			case CoordinateSystem.NATIVE :
				multiplier = 1;
				break;
			

		}
		// FIXME: Use custom geometry scaling property instead of geometry x scale value?
		target.scale(multiplier * values.scaleX);
	}

}

