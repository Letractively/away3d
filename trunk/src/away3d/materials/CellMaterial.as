package away3d.materials{    import away3d.core.*;    import away3d.core.base.*;    import away3d.core.draw.*;    import away3d.core.math.*;    import away3d.core.render.*;    import away3d.core.utils.*;        import flash.display.*;    import flash.geom.*;    import flash.utils.Dictionary;    /** Basic fast Cell material */    public class CellMaterial implements ITriangleMaterial, IUVMaterial    {    	use namespace arcane;		    	internal var _bitmap:BitmapData;      	        public var smooth:Boolean;        public var debug:Boolean;		private var _hw:Number;		private var _hh:Number;        		internal var _mapping:Matrix;		internal var _n0:Number3D = new Number3D();		internal var _n1:Number3D = new Number3D();		internal var _n2:Number3D = new Number3D();				private var T0x:Number;		private var T0y:Number;		private var T1x:Number;		private var T1y:Number;		private var T2x:Number;		private var T2y:Number;		        public function get width():Number        {            return _bitmap.width;        }        public function get height():Number        {            return _bitmap.height;        }                public function get bitmap():BitmapData        {        	return _bitmap;        }              public function CellMaterial(color1:uint = 0xFFFFFF, color2:uint = 0xCCCCCC, color3:uint = 0x333333, init:Object = null)        {			generateGradient(color1, color2, color3);            init = Init.parse(init);            smooth = init.getBoolean("smooth", false);            debug = init.getBoolean("debug", false);			_hw = (width * .5);			_hh = (height * .5);        }				private function generateGradient(color1:uint, color2:uint, color3:uint):void		{			_bitmap = new BitmapData(256, 256, false, 0x000000);			var tmpsprite = new Sprite();			var graphic = tmpsprite.graphics;			graphic.beginFill(color3, .4);			graphic.drawRect(0,0,256, 256);			graphic.beginFill(color3, .4);			graphic.drawCircle(100,100,136);			graphic.beginFill(color3, 1);			graphic.drawCircle(100,100,124);			graphic.beginFill(color2, .4);			graphic.drawCircle(100,100,100);			graphic.beginFill(color2, 1);			graphic.drawCircle(100,100,65);			graphic.beginFill(color1, .2);			graphic.drawCircle(100,100,50);			graphic.beginFill(color1, .5);			graphic.drawCircle(100,100,30);			graphic.beginFill(color1, 1);			graphic.drawCircle(100,100,20);			graphic.beginFill(0xFFFFFF, .2);			graphic.drawCircle(100, 100, 10);			graphic.beginFill(0xFFFFFF, .2);			graphic.drawCircle(100, 100, 5);			_bitmap.draw(tmpsprite,null,null,null,_bitmap.rect,true);		}		        public function renderTriangle(tri:DrawTriangle):void        {        	_mapping = getMapping(tri);						var t:Matrix3D = tri.source.viewTransform;			_n0.rotate((tri.source as Mesh).geometry.getVertexNormal(tri.face.v0), t);			_n1.rotate((tri.source as Mesh).geometry.getVertexNormal(tri.face.v1), t);			_n2.rotate((tri.source as Mesh).geometry.getVertexNormal(tri.face.v2), t);						T0x =  (_hw * _n0.x) + _hw;			T0y =  (_hh * -_n0.y) + _hh;			T1x =  (_hw * _n1.x) + _hw;			T1y =  (_hh *- _n1.y) + _hh;			T2x =  (_hw * _n2.x) + _hw;			T2y =  (_hh * -_n2.y) + _hh;							_mapping.a = T1x - T0x;			_mapping.b = T1y - T0y;			_mapping.c = T2x - T0x;			_mapping.d = T2y - T0y;			_mapping.tx = T0x;			_mapping.ty = T0y;			_mapping.invert();						tri.source.session.renderTriangleBitmap(_bitmap, _mapping, tri.v0, tri.v1, tri.v2, smooth, false);						if (debug)                tri.source.session.renderTriangleLine(0, 0x0000FF, 1, tri.v0, tri.v1, tri.v2);        }				public function getMapping(tri:DrawTriangle):Matrix		{			return tri.texturemapping || tri.transformUV(this);		}		         public function get visible():Boolean        {            return true;        }				public function getPixel32(u:Number, v:Number):uint        {        	return _bitmap.getPixel32(u*_bitmap.width, (1 - v)*_bitmap.height);        }				public function addOnResize(listener:Function):void        {        	return;        }                public function removeOnResize(listener:Function):void        {        	return;        }     }}