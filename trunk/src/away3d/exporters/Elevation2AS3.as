package away3d.exporters{   	import flash.display.BitmapData;	import away3d.core.math.Number3D;		/**	* Class Elevation2AS3 generates a string class of the elevation to pass to the SkinClass and ElevationReader in order to save space and processing time.	* 	*/	public class Elevation2AS3 {				private var _minElevation = 0;		private var _maxElevation = 255;		//private var _readermap:Boolean;		private var _classname:String;		private var _packagename:String;		 		/**		* Locks elevation factor beneath this level. Default is 0;		*		*/		public function set minElevation(val:Number):void        {			_minElevation = val;		}		public function get minElevation():Number        {			return _minElevation;		}		/**		* Locks elevation factor above this level. Default is 255;		*		*/		public function set maxElevation(val:Number):void        {			_maxElevation = val;		}		public function get maxElevation():Number        {			return _maxElevation;		}				/**		* Creates a generate an as3 file of the elevation array.		* @param	classname			String, the name of the class that will be exported.		* @param	packagename	[optional] String. the name of the package that will be exported.		*		*/				// @param	readermap			[optional] Boolean. Defines if the class should generate an array to pass to the ElevationReader.		public function Elevation2AS3(classname:String, packagename:String = "")//, readermap:Boolean = false        {			//_readermap = readermap;			_classname = classname.substring(0,1).toUpperCase()+classname.substring(1,classname.length);			_packagename = packagename.toLowerCase();		}				/**		* Generate the string representing the mesh and optionally color information for the reader.		*		* @param	sourceBmd				Bitmapdata. The bitmapData to read from.		* @param	channel					[optional] String. The channel information to read. supported "a", alpha, "r", red, "g", green, "b", blue and "av" (averages and luminance). Default is red channel "r".		* @param	subdivisionX			[optional] int. The subdivision to read the pixels along the x axis. Default is 10.		* @param	subdivisionY			[optional] int. The subdivision to read the pixels along the y axis. Default is 10.		* @param	scalingX					[optional] Number. The scale multiplier along the x axis. Default is 1.		* @param	scalingY					[optional] Number. The scale multiplier along the y axis. Default is 1.		* @param	elevate					[optional] Number. The scale multiplier along the z axis. Default is .5.		*/				public function export(sourceBmd:BitmapData, channel:String = "r", subdivisionX:int = 10, subdivisionY:int = 10, scalingX:Number = 1, scalingY:Number = 1, elevate:Number = .5):void		{						var source:String = "package "+_packagename+"\n{\n\timport away3d.core.math.Number3D;\n\n\tpublic class "+_classname+"\n\t{\n";			source += "\t\tprivate var arr:Array;\n\n";			source += "\t\tpublic function "+_classname+"()\n\t\t{\n\t\t\tarr =[";			 			channel = channel.toLowerCase();						var w:int = sourceBmd.width;			var h:int = sourceBmd.height;			var i:int;			var j:int;			var x:Number = 0;			var y:Number = 0; 			var z:Number = 0;			var totalArray:Array = [];			var tmpArray:Array = [];			var color:uint;			var cha:Number;						for(j = h-1; j >-subdivisionY; j-=subdivisionY)			{				y = (j<0)? 0 : j;				tmpArray = [];				source += (j == h-1)? "[" : "],[";				for(i = 0; i < w+subdivisionX; i+=subdivisionX)				{					source += (i > 0)? "," : "";					x = (i<w-1)? i : w-1; 										color = (channel == "a")? sourceBmd.getPixel32(x, y) : sourceBmd.getPixel(x, y);										switch(channel){						case "a":							cha = color >> 24 & 0xFF;							break;						case "r":							cha = color >> 16 & 0xFF;							break;						case "g":							cha = color >> 8 & 0xFF;							break;						case "b":							cha = color & 0xFF;						case "av":							cha = ((color >> 16 & 0xFF)*0.212671) + ((color >> 8 & 0xFF)*0.715160) + ((color >> 8 & 0xFF)*0.072169);					}										if(maxElevation < cha)						cha = maxElevation;											if(minElevation > cha)						cha = minElevation;											z = cha*elevate;					source += (x*scalingX)+","+(y*scalingY)+","+z;				}			}						source += "]];\n\t\t}\n\n\t\tpublic function get data():Array\n\t\t{\n\t\t\t\ var output:Array = [];\n\t\t\t var i:int;\n\t\t\t var j:int;\n\t\t\t var tmp:Array;\n\t\t\t var tmp2:Array;\n\n\t\t\t for(i = 0;i<arr.length;++i){\n\t\t\t\ttmp = arr[i];\n\t\t\t\ttmp2 = [];\n\t\t\t\tfor(j = 0;j<tmp.length;j+=3){\n\t\t\t\t\ttmp2.push(new Number3D(tmp[j], tmp[j+1], tmp[j+2]));\n\t\t\t\t}\n\t\t\t\toutput.push(tmp2);\n\t\t\t }\n\t\t\t\ return output;\n\t\t}\n\n\t}\n}";						trace(source);		}			}}