package project.scenebuilder{	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;		import away3d.containers.View3D;		import awaybuilder.abstracts.AbstractBuilder;	import awaybuilder.abstracts.AbstractCameraController;	import awaybuilder.abstracts.AbstractGeometryController;	import awaybuilder.abstracts.AbstractParser;	import awaybuilder.camera.CameraController;	import awaybuilder.camera.CameraFocus;	import awaybuilder.camera.CameraZoom;	import awaybuilder.collada.ColladaParser;	import awaybuilder.events.CameraEvent;	import awaybuilder.events.GeometryEvent;	import awaybuilder.events.SceneEvent;	import awaybuilder.geometry.GeometryController;	import awaybuilder.interfaces.IAssetContainer;	import awaybuilder.interfaces.ICameraController;	import awaybuilder.interfaces.ISceneContainer;	import awaybuilder.utils.CoordinateCopy;	import awaybuilder.vo.SceneCameraVO;	import awaybuilder.vo.SceneGeometryVO;				/**	 * @author andreasengstrom	 */	public class WorldBuilder extends Sprite implements IAssetContainer , ISceneContainer , ICameraController	{		private var view : View3D ;		private var parser : AbstractParser ;		private var builder : AbstractBuilder ;		private var cameraController : AbstractCameraController ;		private var geometryController : AbstractGeometryController ;		// getters and setters
		private var _source : String = SceneSource.MAYA ;		private var _data : XML ;		private var _precision : uint = ScenePrecision.PERFECT ;		private var _startCamera : String ;		private var _update : String = SceneUpdate.CONTINUOUS ;		private var _cameraZoom : Number = CameraZoom.MAYA_W720_H502 ;						public function WorldBuilder ( )		{			this.initialize ( ) ;		}								////////////////////		// PUBLIC METHODS //		////////////////////								public function build ( ) : void		{			this.createView ( ) ;			this.createParser ( ) ;		}								public function addBitmapDataAsset ( id : String , data : BitmapData ) : void		{			this.builder.addBitmapDataAsset ( id , data ) ;		}						public function addDisplayObjectAsset ( id : String , data : DisplayObject ) : void		{			this.builder.addDisplayObjectAsset ( id , data ) ;		}						public function addColladaAsset ( id : String , data : XML ) : void		{			this.builder.addColladaAsset ( id , data ) ;		}								public function getCameras ( ) : Array		{			return this.builder.getCameras ( ) ;		}						public function getGeometry ( ) : Array		{			return this.builder.getGeometry ( ) ;		}						public function getSections ( ) : Array		{			return this.builder.getSections ( ) ;		}						public function getCameraById ( id : String ) : SceneCameraVO		{			return this.builder.getCameraById ( id ) ;		}						public function getGeometryById ( id : String ) : SceneGeometryVO		{			return this.builder.getGeometryById ( id ) ;		}								public function navigateTo ( vo : SceneCameraVO ) : void		{			this.cameraController.navigateTo ( vo ) ;		}								public function teleportTo ( vo : SceneCameraVO ) : void		{			this.cameraController.teleportTo ( vo ) ;		}						override public function toString ( ) : String		{			return "WorldBuilder" ;		}						/////////////////////		// PRIVATE METHODS //		/////////////////////								private function initialize ( ) : void		{			this.builder = new SceneBuilder ( ) ;			this.addEventListener ( Event.ADDED_TO_STAGE , this.onAddedToDisplayList ) ;		}						private function createView ( ) : void		{			this.view = new View3D ( ) ;			this.addChild ( this.view ) ;		}								private function createParser ( ) : void		{			switch ( this.source )			{				case SceneSource.MAYA :				{					this.parser = new ColladaParser ( ) ;					this.parser.addEventListener ( Event.COMPLETE , this.onParsingComplete ) ;					this.parser.parse ( this.data ) ;										break ;				}			}		}
				
		
		private function setupCamera ( ) : void		{			switch ( this.source )			{				case SceneSource.MAYA :				{					this.view.camera.zoom = this.cameraZoom ;					this.view.camera.focus = CameraFocus.MAYA ;										break ;				}			}						if ( this.startCamera != null )			{				var vo : SceneCameraVO = this.builder.getCameraById ( this.startCamera ) ;								CoordinateCopy.position ( vo.camera , this.view.camera ) ;				CoordinateCopy.rotation ( vo.camera , this.view.camera ) ;			}		}								private function setupBuilder ( ) : void		{			switch ( this.source )			{				case SceneSource.MAYA :				{					var builder : SceneBuilder = this.builder as SceneBuilder ;					var sections : Array = this.parser.getSections ( ) ;										builder.coordinateSystem = CoordinateSystem.MAYA ;					builder.precision = this.precision ;					builder.addEventListener ( SceneEvent.RENDER , this.render ) ;					builder.addEventListener ( Event.COMPLETE , this.onBuildingComplete ) ;					builder.build ( this.view , sections ) ;										break ;				}			}		}								private function createCameraController ( ) : void		{			this.cameraController = new CameraController ( this.view.camera ) ;			this.cameraController.update = this.update ;						if ( this.startCamera != null )			{				var startCamera : SceneCameraVO = this.builder.getCameraById ( this.startCamera ) ;								this.cameraController.mainCamera = startCamera ;				this.cameraController.teleportTo ( startCamera ) ;			}						this.cameraController.addEventListener ( SceneEvent.RENDER , this.render ) ;			this.cameraController.addEventListener ( CameraEvent.ANIMATION_START , this.onCameraEvent ) ;			this.cameraController.addEventListener ( CameraEvent.ANIMATION_COMPLETE , this.onCameraEvent ) ;		}
		
		
		private function createGeometryController ( ) : void		{			this.geometryController = new GeometryController ( this.builder.getGeometry ( ) ) ;			this.geometryController.addEventListener ( GeometryEvent.DOWN , this.onGeometryEvent ) ;			this.geometryController.addEventListener ( GeometryEvent.MOVE , this.onGeometryEvent ) ;			this.geometryController.addEventListener ( GeometryEvent.OUT , this.onGeometryEvent ) ;			this.geometryController.addEventListener ( GeometryEvent.OVER , this.onGeometryEvent ) ;			this.geometryController.addEventListener ( GeometryEvent.UP , this.onGeometryEvent ) ;			this.geometryController.enableInteraction ( ) ;		}								private function setupSceneUpdate ( ) : void		{			switch ( this.update )			{				/* NOTE: Render events dispatched by the camera controller.				case SceneUpdate.ON_CAMERA_UPDATE :				*/				case SceneUpdate.CONTINUOUS :				{					this.addEventListener ( Event.ENTER_FRAME , this.render ) ;					break ;				}			}		}								private function render ( event : Event = null ) : void		{			switch ( this.update )			{				/* NOTE: Render events handled externally.				case SceneUpdate.MANUAL :				*/				case SceneUpdate.CONTINUOUS :				case SceneUpdate.ON_CAMERA_UPDATE :				{					this.view.render ( ) ;					break ;				}			}						this.dispatchEvent ( new SceneEvent ( SceneEvent.RENDER ) ) ;		}								////////////////////		// EVENT HANDLERS //		////////////////////								private function onAddedToDisplayList ( event : Event ) : void		{			this.removeEventListener ( Event.ADDED_TO_STAGE , this.onAddedToDisplayList ) ;			this.visible = false ;		}								private function onParsingComplete ( event : Event ) : void		{			this.setupBuilder ( ) ;		}								private function onBuildingComplete ( event : Event ) : void		{			this.setupCamera ( ) ;			this.createCameraController ( ) ;			this.createGeometryController ( ) ;			this.setupSceneUpdate ( ) ;			this.render ( ) ;						this.visible = true ;						this.dispatchEvent ( new Event ( Event.COMPLETE ) ) ;		}						private function onGeometryEvent ( event : GeometryEvent ) : void		{			var type : String = event.type ;			var geometry : SceneGeometryVO = event.geometry ;			var geometryEvent : GeometryEvent = new GeometryEvent ( type ) ;						switch ( type )			{				case GeometryEvent.UP :				{					if ( geometry.targetCamera != null )					{						var camera : SceneCameraVO = this.builder.getCameraById ( geometry.targetCamera ) ;						this.cameraController.navigateTo ( camera ) ;					}				}			}						geometryEvent.geometry = geometry ;			this.dispatchEvent ( geometryEvent ) ;		}								private function onCameraEvent ( event : CameraEvent ) : void		{			var cameraEvent : CameraEvent = new CameraEvent ( event.type ) ;						cameraEvent.targetCamera = event.targetCamera ;			this.dispatchEvent ( cameraEvent ) ;		}								/////////////////////////		// GETTERS AND SETTERS //		/////////////////////////								public function get worldView ( ) : View3D		{			return this.view ;		}						public function set source ( value : String ) : void		{			this._source = value ;		}								public function get source ( ) : String		{			return this._source ;		}								public function set data ( value : XML ) : void		{			this._data = value ;		}								public function get data ( ) : XML		{			return this._data ;		}								public function set precision ( value : uint ) : void		{			this._precision = value ;		}								public function get precision ( ) : uint		{			return this._precision ;		}						public function set startCamera ( value : String ) : void		{			this._startCamera = value ;		}								public function get startCamera ( ) : String		{			return this._startCamera ;		}								public function set update ( value : String ) : void		{			this._update = value ;		}								public function get update ( ) : String		{			return this._update ;		}								public function set cameraZoom ( value : Number ) : void		{			this._cameraZoom = value ;		}								public function get cameraZoom ( ) : Number		{			return this._cameraZoom ;		}	}}