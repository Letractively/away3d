package away3d.core.material{    import away3d.core.*;    import away3d.core.draw.*;    import away3d.core.math.*;    import away3d.core.mesh.*;    import away3d.core.render.*;    import away3d.core.scene.*;    import away3d.core.utils.*;        import flash.display.*;    import flash.events.Event;    import flash.geom.*;    import flash.utils.getTimer;    /**		Note :		- Animated bitmap texture material allows faster rendering because its generates and reuses instances instead of copying/redrawing information		- this class is not suitable for long animations since it would require too much RAM usage		- If interactive movieclip properties are required, please refer to MovieMaterial	*/	    public class AnimatedBitmapMaterial extends TransformBitmapMaterial implements ITriangleMaterial, IUVMaterial    {    	use namespace arcane;    	    	private var _movie:MovieClip;    	    	public var cache:Array;    	public var loop:Boolean;    	public var index:int;    	    	public function set movie(val:MovieClip):void    	{    		if (_movie == val)    			return;    		    		//clear existing event listener    		if (_movie != null)    			_movie.removeEventListener(Event.ENTER_FRAME, update);    			    		//set movie    		_movie = val;    		cache = new Array();    		    		//determine boundaries of this movie    		var i:int;    		var rect:Rectangle;    		var minX:Number = 100000;    		var minY:Number = 100000;    		var maxX:Number = -100000;    		var maxY:Number = -100000;    		    		i = _movie.totalFrames;    		while (i--)    		{    			_movie.gotoAndStop(i);    			rect = _movie.getBounds(_movie);    			if (minX > rect.left)    				minX = rect.left;    			if (minY > rect.top)    				minY = rect.top;    			if (maxX < rect.right)    				maxX = rect.right;    			if (maxY < rect.bottom)    				maxY = rect.bottom;    		}    		    		//draw the cached bitmaps    		var W:int = maxX - minX;			var H:int = maxY - minY;			var mat:Matrix = new Matrix(1, 0, 0, 1, -minX, -minY);			var tmp_bmd:BitmapData;			var timer:int = getTimer();    		for(i=1; i<_movie.totalFrames; i++) {    			//draw frame and store in cache    			_movie.gotoAndStop(i);    			tmp_bmd = new BitmapData(W, H, true, 0x00FFFFFF);				tmp_bmd.draw(_movie, mat, null, null, tmp_bmd.rect, true);				cache.push(tmp_bmd);								//error timeout for time over 2 seconds				if (getTimer() - timer > 2000) {					throw new Error("AnimatedBitmapMaterial contains too many frames. MovieMaterial should be used instead.");				}    		}    		    		//add listener    		_movie.addEventListener(Event.ENTER_FRAME, update);    	}    	    	public function get movie():MovieClip    	{    		return _movie;    	}    	        public function AnimatedBitmapMaterial(movie:MovieClip, init:Object = null)        {        	super(bitmap, init);			            this.movie = movie;                        init = Init.parse(init);			loop = init.getBoolean("loop", false);			index = init.getInt("index", 0, {min:0, max:_movie.totalFrames - 1});                		    		//trigger first frame    		update();        }        		private function update():void        {			_renderBitmap = _bitmap = cache[index];						//increment index        	if (index < cache.length - 1)        		index++;        	else if (loop)        		index = 0;		}    }}